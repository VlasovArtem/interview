<!-- TOC -->
* [Rest VS Grpc VS GraphQL](#rest-vs-grpc-vs-graphql)
  * [GraphQL - новый стандарт](#graphql---новый-стандарт)
  * [REST - по-прежнему самый популярный?](#rest---по-прежнему-самый-популярный)
  * [GRPC - производительность любой ценой](#grpc---производительность-любой-ценой)
  * [Нет универсального решения](#нет-универсального-решения)
  * [Другое](#другое)
  * [Полезные ссылки](#полезные-ссылки)
<!-- TOC -->

# Rest VS Grpc VS GraphQL

## GraphQL - новый стандарт

![Screenshot](../../resources/graphql.png)

`GraphQL` - это гибкая система для запроса данных, которая фокусируется на точных запросах и доставляет именно то, что требуется. Что отличает `GraphQL` от 
других `API`, так это его уникальный подход, ориентированный на клиента. Вместо того, чтобы обрабатывать его как обычно (то есть от сервера к клиенту), 
клиент решает, как все обрабатывать. Основные преимущества:
- **Адаптивность** - клиент решает, какие данные ему нужны и в каком формате он хочет их получить
- **Эффективность** - обеспечивает именно то, что запрашивает клиент, без избыточной выборки,
- **Гибкость** - `GraphQl` является кроссплатформенным и поддерживает более десятка языков (`Perl`, `Java`, `Python`, `PHP` и другие).

Наиболее известным примером приложения `GraphQL`, вероятно, является `GitHub`. Они перешли на него в 2016 году, сославшись на масштабируемость и гибкость в 
качестве двух основных причин. `REST` просто не помогал им, потому что часто требовалось несколько запросов для получения нужных данных, а также превышение 
количества данных по каждому из этих запросов. Учитывая стремительный рост `GitHub` и десятки миллионов пользователей, вы можете себе представить, насколько 
серьезной должна была быть эта проблема. `GraphQL` предоставил именно ту альтернативу, которая им была нужна, потому что он ориентирован на то, чтобы клиент 
мог запрашивать определенные данные в определенном формате для конкретного использования.

## REST - по-прежнему самый популярный?

![Screenshot](../../resources/rest_comparison.png)

После нескольких жалоб по этому поводу будет справедливо взглянуть на `REST`. Несмотря на некоторые вопросы, не устарел ли он, это все еще наиболее часто 
используемый `API`. `REST` - это архитектура без сохранения состояния для передачи данных. Системы `RESTful` делают упор на то, что они stateless и гипермедиа. 
В отличие от `GraphQL`, здесь разделяются обязанности клиента и сервера. Обычно упоминаемые преимущества:
- **Производительность** - лучше всего подходит для систем, требующих быстрой итерации и стандартизированного `HTTP`
- **Масштабируемость** - позволяет поддерживать большое количество компонентов и взаимодействий между ними
- **Простота** - `REST` имеет единый интерфейс, который упрощает и разделяет архитектуру
- **Возможность модификации** - компоненты могут быть изменены в соответствии с меняющимися потребностями даже во время работы приложения.

Как упоминалось выше, `REST` по-прежнему остается самым популярным `API`. `Twitter`, `Facebook`, `Google` и `Paypal` используют `RESTful API`. `REST` может 
связывать воедино множество ресурсов, которые можно запрашивать разными способами и в разных форматах для различных целей. Если вам нужен более универсальный 
`API`, чем точный `GraphQL`, это то, что вам нужно.

## GRPC - производительность любой ценой

![Screenshot](../../resources/grpc_comparison.png)

`gRPC` - это легкая и быстрая система для запроса данных, это свежий взгляд на старый метод, называемый удаленным вызовом процедур или `RPC`. Основное различие 
здесь в том, как он определяет переговоры по контракту. `REST` определяет взаимодействия с помощью стандартизованных терминов в своих запросах, `GraphQL` 
выполняет запросы по созданной схеме, чтобы получить именно то, что требуется. `RPC` работает по контрактам, согласование определяется отношениями между 
сервером и клиентом, а не архитектурой. Большая часть мощности полагается на клиентскую сторону, в то время как обработка и вычисления выгружаются на удаленный 
сервер, на котором размещен ресурс. Короче говоря, основные преимущества:
- **Легкий** - требует очень мало ресурсов, что делает его удобным решением даже для ситуаций с очень низким энергопотреблением
- **Эффективный** - `gPRC` использует `protobufs`, метод сериализации структурированных данных, который фокусируется на эффективной сериализации связи
- **Открытый исходный код** - который можно свободно использовать, изменять или разветвлять

Короче говоря, `gRPC` подходит для систем, которым требуется заданный объем данных или регулярная обработка, и в которых запрашивающая сторона имеет низкое 
энергопотребление или хочет сохранить ресурсы. Лучшими примерами являются чрезвычайно популярные устройства `IoT`, такие как голосовые контроллеры, 
интеллектуальные переключатели света, замки для дымовой сигнализации и камеры.

## Нет универсального решения

Как видите, у каждого из этих вариантов есть свои приложения и преимущества. Здесь нет явного победителя, и то, что вы должны использовать, или, скорее, то, 
что вы хотите использовать, в основном зависит от ваших целей и подхода. Итак, теперь, когда вы, надеюсь, немного знаете о каждом из них, посмотрите, что лучше 
всего подходит для вашего проекта, и выберите подходящий для себя.

## Другое

Grpc
- Поддерживает обратную совместимость. Также хотелось бы, чтобы протокол, который мы используем, достаточно хорошо поддерживал обратную совместимость: это очень важно с параллельными независимыми релизами
- строгий подход к обработке ошибок: все, кто делал REST-сервисы, знают — нельзя просто использовать HTTP-статус. Они обычно не позволяют детально описать проблему, приходится вводить какие-то свои статусы, свою детализацию. В REST-сервисах каждый вводит свою реализацию этих ошибок, приходится каждый раз по-разному с этим работать. Это не всегда удобно. 
- Хотелось бы также иметь управление таймаутами со стороны клиента. Опять же, те, кто работает с HTTP, понимают — если на стороне клиента мы выставили таймаут и он закончился, то клиент перестанет ожидать выполнения запроса, но сервер об этом ничего не узнает и продолжит его выполнять. Более того, посередине бывают различные прокси, которые ставят глобальные таймауты. И клиент может про них просто ничего не знать и конфигурировать их не всегда тривиально. 
- Например, для Java в случае ошибочного статуса выкидывается исключение. Для плюсов статус является просто результатом выполнения вызова функции и можно проверить и дальше уже действовать в зависимости от него. Внутри google.rpc.Status есть 3 поля: код ответа, сообщение и детали. Есть стандартный набор кодов ответа, которые можно использовать. В поле сообщения можно просто записать нелокализованное сообщение, чтобы разобраться с проблемой. Детали — это вектор, в котором можно передавать кастомные объекты, в том числе бинарные. 



При использовании swagger есть большой соблазн не поддерживать доку, ведь это чаще всего дополнительный геморрой. При использовании gRPC этого не получится, потому что инструмент продуман лучше и он упрощает жизнь разработчику. У вас не получиться сгенерировать код, не написав proto файл и не расшарив его между командами разработки.

Идеальный вариант использования gRPC — это общение между микросервисами и построение коммуникации с сервером для мобильных приложений.

gRPC — это в первую очередь RPC фреймворк и он больше про методы в стиле UpdateBalance, GetClient и прочие. REST же — он про ресурсы. GET /users, POST /users и так далее. В gRPC можно спокойно пилить кучу методов, в то время как кучу эндпоинтов запилить плохая идея.

https://medium.com/maddevs-io/go-rest-или-grpc-f5d52d7ffff6


Understanding gRPC APIs
As a variant of the RPC architecture, gRPC was created by Google to speed up data transmission between microservices and other systems that need to interact with each other. Compared to REST APIs, gRPC APIs are unique in the following ways: 
1. Protobuf Instead of JSON
2. Built on HTTP 2 Instead of HTTP 1.1
3. In-Born Code Generation Instead of Using Third-Party Tools Like Swagger
4. 7 to 10 times Faster Message Transmission
5. Slower Implementation than REST 
6. gRPC supports streaming
Let’s take a closer look at each of these differences between REST and gRPC APIs.

Protobuf Instead of JSON/XML
Both REST APIs and RPC APIs send and receive messages using the JSON or XML messaging formats. They can use other formats too, but JSON and XML are the most common. Of these, JSON has become the most popular format because it is flexible, efficient, platform neutral, and language agnostic. It’s also text-based and human-readable, which makes it easy for human operators to work with. The problem is that for certain use-cases, JSON isn’t fast enough or light-weight enough when transmitting data between systems. 
In contrast to REST and RPC, gRPC overcomes issues related to speed and weight — and offers greater efficiency when transmitting messages — by using theProtobuf(protocol buffers) messaging format. Here are a few details about Protobuf:
* Platform and language agnostic like JSON
* Serializes and deserializes structured data to communicate via binary.
* As a highly-compressed format, it doesn’t achieve JSON’s level of human-readability.
* Speeds up data transmission by removing a lot of the responsibilities that JSON manages so it can focus strictly on serializing and deserializing data. 
* Data transmission is faster because Protobuf reduces the size of messages and serves as a lightweight messaging format. 

В HTTP 2 для REST нельзя использовать стриминг

GRPC предоставляет три типа потоковой передачи:

- На стороне сервера: клиент отправляет сообщение запроса на сервер. Сервер возвращает поток ответов клиенту. После завершения ответов сервер отправляет сообщение о состоянии (и в некоторых случаях конечные метаданные), что завершает процесс. После получения всех ответов клиент завершает свой процесс.
- На стороне клиента: клиент отправляет поток сообщений запроса на сервер. Сервер возвращает один ответ клиенту. Он (обычно) отправляет ответ после получения всех запросов от клиента и сообщения о состоянии (и в некоторых случаях конечных метаданных).
- Двунаправленный: клиент и сервер передают данные друг другу без особого порядка. Клиент - это тот, кто инициирует такой вид двунаправленной потоковой передачи. Клиент также завершает соединение.

https://blog.dreamfactory.com/grpc-vs-rest-how-does-grpc-compare-with-traditional-rest-apis/

## Полезные ссылки

[GraphQL vs REST vs gRPC - medium](https://medium.com/devops-dudes/graphql-vs-rest-vs-grpc-411a0a60d18d)
