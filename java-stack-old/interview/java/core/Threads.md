<!-- TOC -->
* [Threads (Потоки)](#threads-потоки)
  * [Отличие процесса и потока](#отличие-процесса-и-потока)
  * [Как создать поток?](#как-создать-поток)
  * [Зачем нужна многопоточность](#зачем-нужна-многопоточность)
  * [В каком порядке запускаются потоки?](#в-каком-порядке-запускаются-потоки)
  * [Можно ли вызвать метод start() дважды?](#можно-ли-вызвать-метод-start-дважды)
  * [Асинхронность](#асинхронность)
  * [Завершение процесса и демоны (daemon)](#завершение-процесса-и-демоны-daemon)
  * [Завершение потоков](#завершение-потоков)
  * [Interruption (прерывание потоков)](#interruption-прерывание-потоков)
  * [Монитор/Мьютекс](#монитормьютекс)
  * [Пример Callable](#пример-callable)
  * [Как хендлить ошибки в Runnable и Callable?](#как-хендлить-ошибки-в-runnable-и-callable)
  * [Deadlock](#deadlock)
      * [Как избежать deadlock?](#как-избежать-deadlock)
  * [LiveLock](#livelock)
      * [Как избежать livelock?](#как-избежать-livelock)
  * [Race condition (состояние гонки)](#race-condition-состояние-гонки)
  * [Псевдопараллелизм](#псевдопараллелизм)
  * [Метод sleep()](#метод-sleep)
  * [Метод wait()](#метод-wait)
  * [Отличие sleep() и wait()](#отличие-sleep-и-wait)
  * [Методы notify() и notifyAll()](#методы-notify-и-notifyall)
  * [Метод Thread.yield()](#метод-threadyield)
  * [Метод join()](#метод-join)
  * [Что такое contention?](#что-такое-contention)
  * [Состояния потоков](#состояния-потоков)
  * [Приоритеты потоков](#приоритеты-потоков)
  * [Полезные методы класса Thread](#полезные-методы-класса-thread)
  * [synchronized (Синхронизация)](#synchronized-синхронизация)
  * [Блокировки](#блокировки)
      * [ReentrantLock](#reentrantlock)
      * [ReadWriteLock](#readwritelock)
  * [Семафоры](#семафоры)
  * [Блокировка на уровне объекта (блокировка экземпляра)](#блокировка-на-уровне-объекта-блокировка-экземпляра)
  * [Блокировка на уровне класса (статическая блокировка)](#блокировка-на-уровне-класса-статическая-блокировка)
  * [Некоторые важные замечания](#некоторые-важные-замечания)
  * [Можно ли создать новый объект класса, если выполняется его static synchronized метод?](#можно-ли-создать-новый-объект-класса-если-выполняется-его-static-synchronized-метод)
  * [Что такое ThreadGroup и зачем он нужен?](#что-такое-threadgroup-и-зачем-он-нужен)
  * [Что такое ThreadPool и зачем он нужен?](#что-такое-threadpool-и-зачем-он-нужен)
  * [Что такое ThreadLocal переменные?](#что-такое-threadlocal-переменные)
  * [Что такое Executor?](#что-такое-executor)
  * [Что такое ExecutorService?](#что-такое-executorservice)
      * [Callable и Future в исполнителях](#callable-и-future-в-исполнителях)
      * [Таймаут](#таймаут)
      * [InvokeAll()](#invokeall)
      * [InvokeAny()](#invokeany)
      * [Executors.newWorkStealingPool()](#executorsnewworkstealingpool)
      * [Как обрабатывать исключения в исполнителе?](#как-обрабатывать-исключения-в-исполнителе)
  * [ScheduledExecutorService](#scheduledexecutorservice)
  * [ForkJoinPool](#forkjoinpool)
      * [work-stealing алгоритм](#work-stealing-алгоритм)
      * [Как получить ForkJoinPool](#как-получить-forkjoinpool)
      * [ForkJoinTask<V>](#forkjointaskv)
      * [RecursiveAction пример](#recursiveaction-пример)
      * [RecursiveTask<V> пример](#recursivetaskv-пример)
      * [Отправка задач в ForkJoinPool](#отправка-задач-в-forkjoinpool)
  * [CompletableFuture](#completablefuture)
  * [Future VS CompletableFuture](#future-vs-completablefuture)
  * [Что такое атомарные типы?](#что-такое-атомарные-типы)
  * [Volatile](#volatile)
  * [Полезные ссылки](#полезные-ссылки)
<!-- TOC -->

# Threads (Потоки)

## Отличие процесса и потока

**Процесс** — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память) - 
вкладка в хроме. Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого.
Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. 
Это могут быть конвейеры, файлы, каналы связи между компьютерами и многое другое. Память процесса общая для всех его потоков. 

**Поток** — определенный способ выполнения процесса. Когда один поток изменяет ресурс процесса, это изменение сразу же становится видно другим потокам 
этого процесса. Каждый поток последовательно выполняет инструкции процесса. 
Поток использует то же самое пространство стека, что и процесс, а множество потоков совместно используют данные своих состояний. 
Как правило, каждый поток может работать (читать и писать) с одной и той же областью памяти, в отличие от процессов, 
которые не могут просто так получить доступ к памяти другого процесса. 
У каждого потока есть собственные регистры и собственный стек, но другие потоки могут их использовать.

## Как создать поток?

1. С помощью класса, реализующего `Runnable`
- Создать объект класса `Thread`
- Создать объект класса, реализующего интерфейс `Runnable`
- Вызвать у созданного объекта `Thread` метод `start()` (после этого запустится метод `run()` у переданного объекта, реализующего `Runnable`)
2. С помощью класса, расширяющего `Thread`
- Создать объект класса `ClassName extends Thread`
- Переопределить `run()` в этом классе (в теории этого можно не делать, тогда поток ничего не выполнит)
- Запуск происходит через метод `start()`
3. С помощью класса, реализующего `java.util.concurrent.Callable`
- Создать объект класса, реализующего интерфейс `Callable`
- Создать объект `ExecutorService` с указанием пула потоков.
- Создать объект `Future`. Запуск происходит через метод `submit()`; Сигнатура: `<T> Future<T> submit(Callable<T> task)`

## Зачем нужна многопоточность

Чтобы одновременно выполнять несколько действий и ускорить вычисления.

## В каком порядке запускаются потоки?

В случайном. Это решает планировщик потоков. 

## Можно ли вызвать метод start() дважды?

Нет. После того как поток был запущен, он не может быть запущен снова. 
Если вы попытаетесь снова запустить поток, он выдаст исключение `IllegalThreadStateException`.

## Асинхронность

Невозможно предсказать какой поток завершится раньше. Это происходит из-за так называемого «асинхронного выполнения кода». 
**Асинхронность** означает, что нельзя утверждать, что какая-либо инструкция одного потока выполнится раньше или позже инструкции другого. 
Или, другими словами, параллельные потоки независимы друг от друга, за исключением тех случаев, когда программист сам описывает зависимости 
между потоками с помощью предусмотренных для этого средств языка.
 
## Завершение процесса и демоны (daemon)

В Java процесс завершается тогда, когда завершается его последний поток. Даже если метод `main()` уже завершился, 
но еще выполняются порожденные им потоки, система будет ждать их завершения. 

Однако это правило не относится к особому виду потоков – **демонам**. Если завершился последний обычный поток процесса, и остались только потоки-демоны, 
то они будут принудительно завершены и выполнение процесса закончится. 
Чаще всего потоки-демоны используются для выполнения фоновых задач, обслуживающих процесс в течение его жизни.

Объявить поток демоном достаточно просто — нужно перед запуском потока вызвать его метод `setDaemon(true);`

Проверить, является ли поток демоном, можно вызвав его метод `boolean isDaemon();`

## Завершение потоков

Поток завершается тогда, когда завершится метод `run()` или `call()`. Для главного потока метод `main()`.

В Java существуют (существовали) средства для принудительного завершения потока. В частности метод `Thread.stop()` завершает поток незамедлительно 
после своего выполнения. Однако этот метод, а также `Thread.suspend()`, приостанавливающий поток, и `Thread.resume()`, продолжающий выполнение потока, 
были объявлены **устаревшими** и их использование отныне **крайне нежелательно**. Дело в том что поток может быть «убит» во время выполнения операции, 
обрыв которой на полуслове оставит некоторый объект в неправильном состоянии, что приведет к появлению трудно улавливаемой и 
случайным образом возникающей ошибке.

Вместо принудительного завершения потока применяется схема, в которой каждый поток сам ответственен за своё завершение. 
Поток может остановиться либо тогда, когда он закончит выполнение метода `run()`, (`main()` — для главного потока) либо по сигналу из другого потока. 
Причем как реагировать на такой сигнал — дело, опять же, самого потока. 
Получив его, поток может выполнить некоторые операции и завершить выполнение, а может и вовсе его проигнорировать и продолжить выполняться. 
Описание реакции на сигнал завершения потока лежит на плечах программиста.

## Interruption (прерывание потоков)

Класс `Thread` содержит в себе скрытое булево поле, которое называется флагом прерывания. Установить этот флаг можно вызвав метод `interrupt()` потока. 
Проверить же, установлен ли этот флаг, можно двумя способами:
- вызвать метод `bool isInterrupted()` объекта потока. Данный метод возвращает состояние флага прерывания и оставляет этот флаг нетронутым.
- вызвать статический метод `bool Thread.interrupted()`. Этот метод возвращает состояние флага и сбрасывает его. 

Заметьте что `Thread.interrupted()` — статический метод класса Thread, и его вызов возвращает значение флага прерывания того потока, из которого он был вызван.
Поэтому этот метод вызывается только изнутри потока и позволяет потоку проверить своё состояние прерывания.

У методов, приостанавливающих выполнение потока, таких как `sleep()`, `wait()` и `join()` есть одна особенность — если во время их выполнения будет 
вызван метод `interrupt()` этого потока, они, не дожидаясь конца времени ожидания, сгенерируют исключение `InterruptedException` и при этом сбрасывают
флаг `interrupted` обратно в `false`.


## Монитор/Мьютекс

**Монитором** принято называть объект, который хранит состояние занят/свободен.

Несколько потоков могут мешать друг другу при обращении к одним и тем же данным. Для решения этой проблемы придуман мьютекс (он же монитор). 
Он имеет два состояния — объект занят и объект свободен. 
Монитор (мьютекс) — высокоуровневый механизм взаимодействия и синхронизации потоков, обеспечивающий доступ к неразделяемым ресурсам.

Когда одному из потоков нужен общий для всех потоков объект, он проверяет мьютекс, связанный с этим объектом. 
Если мьютекс свободен, то поток блокирует его (помечает как занятый) и начинает использование общего ресурса. 
После того, как он сделал свои дела, мьютекс разблокируется (помечается как свободен).

Если же нить хочет использовать объект, а мьютекс заблокирован, то нить засыпает в ожидании. 
Когда мьютекс, наконец, освободится занятой нитью, наша нить тут же заблокирует его и приступит к работе. 
Мьютекс встроен в класс `Object` и следовательно он есть у каждого объекта.

## Пример Callable

```java
public interface Callable<V> {
    V call() throws Exception;
}

public class FactorialTask implements Callable<Integer> {
    int number;
 
    // standard constructors
 
    public Integer call() throws InvalidParamaterException {
        int fact = 1;
        // ...
        for(int count = number; count > 1; count--) {
            fact = fact * count;
        }
 
        return fact;
    }
}

@Test
public void whenTaskSubmitted_ThenFutureResultObtained(){
    FactorialTask task = new FactorialTask(5);
    Future<Integer> future = executorService.submit(task);
 
    assertEquals(120, future.get().intValue());
}
```

## Как хендлить ошибки в Runnable и Callable?

Поскольку в сигнатуре метода `run()` не указано `throws`, нет возможности хендлить **checked** исключения для `Runnable`.

Метод `call()` в `Callable` содержит `throws Exception`, поэтому мы можем легко прокидывать **checked** исключения дальше:

```java
public class FactorialCallableTask implements Callable<Integer> {
    
    private int number;
    
    FactorialCallableTask(int number) {
    	this.number = number;
    }
    
    public Integer call() throws InvalidParamaterException {
        if(number < 0) {
            throw new InvalidParamaterException("Number should be positive");
        }
    // ...
    }
}
```

В случае запуска `Callable` с использованием `ExecutorService` исключения собираются в объекте `Future`, что можно проверить, вызвав метод `Future.get()`. 
Это вызовет исключение `ExecutionException`, которое оборачивает исходное исключение:

```java
@Test(expected = ExecutionException.class)
public void whenException_ThenCallableThrowsIt() {
    FactorialCallableTask task = new FactorialCallableTask(-5);
    Future<Integer> future = executorService.submit(task);
    Integer result = future.get().intValue();
}
```

В приведенном выше тесте возникает исключение `ExecutionException`, поскольку мы передаем недопустимое число. Мы можем вызвать метод `getCause()` 
для этого объекта исключения, чтобы получить оригинальное исключение.

Если мы не вызовем метод `get()` класса `Future` - тогда код прописанный в методе `call()` всё равно будет выполнен, до места в котором выбрасывается 
исключение, НО само это исключение, сгенерированное методом `call()`, не будет возвращено, а задача останется помечена как незавершенная:

```java
@Test
public void whenException_ThenCallableDoesntThrowsItIfGetIsNotCalled(){
    FactorialCallableTask task = new FactorialCallableTask(-5);
    Future<Integer> future = executorService.submit(task);
    assertEquals(false, future.isDone());
}
```

Данный тест пройдет успешно, даже если мы выбросили исключение для отрицательных значений параметра в `FactorialCallableTask`.

## Deadlock

**Deadlock** это ситуация, при которой несколько потоков находятся в состоянии ожидания ресурсов, занятых друг другом, 
и ни один из них не может продолжать выполнение.

В этом примере мы создадим два потока, `T1` и `T2`. Поток `T1` вызывает `operation1()`, а поток `T2` вызывает `operation2()`. Чтобы завершить свои операции,
поток `T1` должен сначала получить `lock1`, а затем `lock2`, тогда как поток `T2` должен сначала получить `lock2`, а затем `lock1`. 
Получается, что оба потока пытаются получить блокировки в обратном порядке.

```java
public class DeadlockExample {
 
    private Lock lock1 = new ReentrantLock(true);
    private Lock lock2 = new ReentrantLock(true);
 
    public static void main(String[] args) {
        DeadlockExample deadlock = new DeadlockExample();
        new Thread(deadlock::operation1, "T1").start();
        new Thread(deadlock::operation2, "T2").start();
    }
 
    public void operation1() {
        lock1.lock();
        print("lock1 acquired, waiting to acquire lock2.");
        sleep(50);
 
        lock2.lock();
        print("lock2 acquired");
 
        print("executing first operation.");
 
        lock2.unlock();
        lock1.unlock();
    }
 
    public void operation2() {
        lock2.lock();
        print("lock2 acquired, waiting to acquire lock1.");
        sleep(50);
 
        lock1.lock();
        print("lock1 acquired");
 
        print("executing second operation.");
 
        lock1.unlock();
        lock2.unlock();
    }
 
    // helper methods
 
}
```

Как только мы запустим программу, мы увидим, что программа заходит в тупик и никогда не завершается. Лог показывает, что поток `T1` ожидает `lock2`, 
который удерживается потоком `T2`. Точно так же поток `T2` ожидает `lock1`, который удерживается потоком `T1`.

Результат выполнения
```java
Thread T1: lock1 acquired, waiting to acquire lock2.
Thread T2: lock2 acquired, waiting to acquire lock1.
```

#### Как избежать deadlock?

**Deadlock** - распространенная проблема параллелизма в Java. Следовательно, мы должны разработать приложение Java, 
чтобы избежать любых потенциальных условий взаимоблокировки.

Для начала нам следует **избегать необходимости устанавливать несколько блокировок для потока**. Однако, если потоку требуется несколько блокировок, 
мы должны убедиться, что **каждый поток получает блокировки в одном и том же порядке**, чтобы избежать любой циклической зависимости при получении блокировки.

Мы также можем использовать **попытки блокировки по времени**, такие как метод `tryLock()` в интерфейсе `Lock`, 
чтобы убедиться, что поток не блокируется бесконечно, если он не может получить блокировку.

## LiveLock

**Livelock** - еще одна проблема параллелизма, аналогичная deadlock. В livelock два или более потока продолжают передавать состояния друг другу вместо того, 
чтобы ждать бесконечно, как мы видели в примере взаимоблокировки. Следовательно, потоки не могут выполнять свои соответствующие задачи.

Прекрасным примером livelock является система обмена сообщениями, где при возникновении исключения потребитель сообщения откатывает транзакцию и 
помещает сообщение обратно в начало очереди. Затем одно и то же сообщение повторно считывается из очереди только для того, 
чтобы вызвать другое исключение и снова поместить в очередь. **Потребитель никогда не получит никаких других сообщений из очереди**.

Чтобы продемонстрировать состояние livelock, мы рассмотрим тот же пример взаимоблокировки, который мы обсуждали ранее. 
В этом примере также поток `T1` вызывает операцию `operation1()`, а поток `T2` вызывает операцию `operation2()`. 
Однако мы немного изменим логику этих операций.

Оба потока нуждаются в двух блокировках для завершения своей работы. Каждый поток получает свою первую блокировку, но обнаруживает, 
что вторая блокировка недоступна. Итак, чтобы позволить другому потоку завершить работу первым, 
каждый поток освобождает свою первую блокировку и снова пытается получить обе блокировки.

```java
public class LivelockExample {
 
    private Lock lock1 = new ReentrantLock(true);
    private Lock lock2 = new ReentrantLock(true);
 
    public static void main(String[] args) {
        LivelockExample livelock = new LivelockExample();
        new Thread(livelock::operation1, "T1").start();
        new Thread(livelock::operation2, "T2").start();
    }
 
    public void operation1() {
        while (true) {
            tryLock(lock1, 50);
            print("lock1 acquired, trying to acquire lock2.");
            sleep(50);
 
            if (tryLock(lock2)) {
                print("lock2 acquired.");
            } else {
                print("cannot acquire lock2, releasing lock1.");
                lock1.unlock();
                continue;
            }
 
            print("executing first operation.");
            break;
        }
        lock2.unlock();
        lock1.unlock();
    }
 
    public void operation2() {
        while (true) {
            tryLock(lock2, 50);
            print("lock2 acquired, trying to acquire lock1.");
            sleep(50);
 
            if (tryLock(lock1)) {
                print("lock1 acquired.");
            } else {
                print("cannot acquire lock1, releasing lock2.");
                lock2.unlock();
                continue;
            }
 
            print("executing second operation.");
            break;
        }
        lock1.unlock();
        lock2.unlock();
    }
 
    // helper methods
 
}
```

Как мы видим по логам, оба потока многократно устанавливают и снимают блокировки. Из-за этого **ни один из потоков не может завершить операцию**.

```java
Thread T1: lock1 acquired, trying to acquire lock2.
Thread T2: lock2 acquired, trying to acquire lock1.
Thread T1: cannot acquire lock2, releasing lock1.
Thread T2: cannot acquire lock1, releasing lock2.
Thread T2: lock2 acquired, trying to acquire lock1.
Thread T1: lock1 acquired, trying to acquire lock2.
Thread T1: cannot acquire lock2, releasing lock1.
Thread T1: lock1 acquired, trying to acquire lock2.
Thread T2: cannot acquire lock1, releasing lock2.
..
```

#### Как избежать livelock?

Чтобы избежать livelock, нам нужно изучить условие, которое вызывает livelock, и затем найти соответствующее решение.

Например, если у нас есть два потока, которые многократно получают и снимают блокировки, что приводит к динамической блокировке, 
мы можем разработать код так, чтобы потоки повторяли **получение блокировок через случайные промежутки времени**. 
Это даст потокам шанс получить необходимые им блокировки.

Другой способ решить livelock в примере системы обмена сообщениями, который мы обсуждали ранее, - это **поместить сообщения с ошибками в отдельную очередь** 
для дальнейшей обработки вместо того, чтобы снова помещать их обратно в ту же очередь.

## Race condition (состояние гонки)

Состояние гонки — ошибка проектирования многопоточной системы или приложения, 
при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода.

## Псевдопараллелизм

Одноядерный процессор может обрабатывать команды только последовательно. При псевдопараллельном выполнении потоков процессор мечется между выполнением
нескольких потоков, выполняя по очереди часть каждого из них. Какую именно часть одного из потоков выполнит процессор (имеется в виду какой объем работы) 
заранее не определено. То, что инструкции параллельных потоков выполняются вперемешку, в некоторых случаях может привести к конфликтам доступа к данным.

## Метод sleep()

`Thread.sleep()` — статический метод класса `Thread`, который приостанавливает выполнение потока, в котором он был вызван. 
Во время выполнения метода `sleep()` система перестает выделять потоку процессорное время, распределяя его между другими потоками. 
Метод `sleep()` может выполняться либо заданное кол-во времени (миллисекунды или наносекунды) либо до тех пор пока он не будет остановлен прерыванием 
(в этом случае он сгенерирует исключение `InterruptedException`).

## Метод wait()

Иногда в программе может оказаться такая ситуация, что нить вошла в блок кода `synchronized`, заблокировала монитор и не может работать дальше, 
т.к. каких-то данных еще не хватает: например, файл который она должна обработать еще не загрузился или что-нибудь в таком духе. 
Мы же можем просто подождать, когда файл скачается. Можно просто в цикле проверять – если файл еще не скачался – спать, например, секунду и 
опять проверять и т.д. -> `Thread.sleep(1000);` Но в нашем случае такое ожидание слишком дорого. 
Т.к. наша нить заблокировала монитор, то другие нити вынуждены тоже ждать, хотя их данные для работы могут быть уже готовы.

Для решения этой проблемы и был придуман метод `wait()`. Вызов этого метода приводит к тому, что нить освобождает монитор и «становится на паузу» 
перемещает текущий поток в так называемый **wait set**.

Метод `wait()` можно вызвать у объекта-монитора и только тогда, когда этот монитор занят – т.е. внутри блока `synchronized`. 
При этом нить временно прекращает работу, а монитор освобождается, чтобы им могли воспользоваться другие нити.

Часто встречаются ситуации, когда в блок `synchronized` зашла нить, вызвала там `wait()`, освободила монитор. 
Затем туда вошла вторая нить и тоже стала на паузу, затем третья и так далее.

## Отличие sleep() и wait()

|Параметр|`wait()`|`sleep()`|
|--------|--------|---------|
|Синхронизация|`wait()` должен вызываться из синзронизированного контекста, то есть из `synchronized` блока или метода. Иначе вы получите `IllegalMonitorStateException`|Не нужно вызывать из `synchronized` блока или метода |
|Вызывается на|Метод `wait()` работает с `Object` и определяется в классе `Object`. Вызывается на объекте-мьютексе. |Метод `sleep()` статический и работает в текущем потоке. Находится в классе `Thread`|
|Освобождение от блокировки|`wait()` освобождает от блокировки объект, для которого он вызывается, а также от других блокировок, если он их содержит|Метод `sleep()` вообще не снимает блокировку|
|Условия пробуждения|Действует до вызова `notify()` или `notifyAll()` из класса `Object`|Действует до истечения времени или вызова `interrupt()`|
|static|нестатический метод|статический метод|

## Методы notify() и notifyAll()

Методы `notify()/notifyAll()` можно вызвать у объекта-монитора и только, когда этот монитор занят – т.е. внутри блока `synchronized`.

Метод `notify()` «размораживает» одну случайную нить, метод `notifyAll()` – все «замороженные» нити данного монитора. 
Поток, который вызывает эти методы должен владеть монитором, иначе будет выдано исключение `java.lang.IllegalMonitorStateException`.

## Метод Thread.yield()

Статический метод `Thread.yield()` заставляет процессор переключиться на обработку других потоков системы. 
Метод может быть полезным, например, когда поток ожидает наступления какого-либо события и необходимо чтобы проверка его наступления происходила 
как можно чаще. В этом случае можно поместить проверку события и метод `Thread.yield()` в цикл. Переводит поток в состояние **ready-to-run**.

```java
//Ожидание поступления сообщения
while(!msgQueue.hasMessages()){	//Пока в очереди нет сообщений
	Thread.yield();		//Передать управление другим потокам
}
```

## Метод join()

В Java предусмотрен механизм, позволяющий одному потоку ждать завершения выполнения другого. Для этого используется метод `join()`. 
Например, чтобы главный поток подождал завершения побочного потока `myThready`, необходимо выполнить инструкцию `myThready.join()` в главном потоке. 
Как только поток `myThready` завершится, метод `join()` вернет управление, и главный поток сможет продолжить выполнение.

Метод `join()` имеет перегруженную версию, которая получает в качестве параметра время ожидания. В этом случае `join()` возвращает управление либо когда
завершится ожидаемый поток, либо когда закончится время ожидания. 
Подобно методу `Thread.sleep()` метод `join()` может ждать в течение миллисекунд и наносекунд – аргументы те же.

С помощью задания времени ожидания потока можно, например, выполнять обновление анимированной картинки пока главный 
(или любой другой) поток ждёт завершения побочного потока, выполняющего ресурсоёмкие операции.

```java
Thinker brain = new Thinker(); //Thinker - потомок класса Thread.
brain.start();		//Начать "обдумывание".
do {
	mThinkIndicator.refresh();//mThinkIndicator - анимация
	try{
		brain.join(250);	//Подождать окончания мысли 
	}catch(InterruptedException e){}
}
while(brain.isAlive());	//Пока brain думает...
//brain закончил думать (звучат овации).
```

В этом примере поток `brain` думает над чем-то, и предполагается, что это занимает у него длительное время. 
Главный поток ждет его четверть секунды и, в случае, если этого времени на раздумье не хватило, обновляет «индикатор раздумий» 
(некоторая анимированная картинка). 
В итоге, во время раздумий, пользователь наблюдает на экране индикатор мыслительного процесса, что дает ему знать, что электронные мозги чем-то заняты.

## Что такое contention?

Это ситуация, когда несколько сущностей одновременно пытаются владеть одним и тем же ресурсом, который предназначен для монопольного использования.

## Состояния потоков

1. **New**

Когда мы создаем новый объект класса `Thread`, используя оператор `new`, то поток находится в состоянии New. 
В этом состоянии поток еще не работает.

2. **Runnable**

Когда мы вызываем метод `start()` созданного объекта `Thread`, его состояние изменяется на Runnable и управление потоком передается планировщику потоков 
(Thread scheduler). Запустить ли эту нить мгновенно или сохранить его в работоспособный пул потоков перед запуском, это зависит от реализации ОС 
и планировщика потоков.

- **Running**

Когда поток будет запущен, его состояние изменится на Running. Планировщик потоков выбирает один поток из своего общего пула потоков 
и изменяет его состояниена Running. Сразу после этого процессор начинает выполнение этого потока. 
Во время выполнения состояние потока также может изменится на Runnable, Dead или Blocked.

- **Ready** 

Но и это еще не все. Не стоит забывать, что в каждый момент времени работает только одна нить. А видимая одновременная работа – 
это постоянное перескакивание процессора с нити на нить. Для времени, когда нить как бы работает, а на самом деле ждет своей очереди, 
тоже есть отдельное состояние. Оно называется **ready-to-run**. Нить во время работы постоянно меняет состояние с running на ready и потом 
снова на running, когда становится активной. Чтобы перевести в это состояние нужно вызвать метод `yield()`.

3. **Blocked**

Нить может быть заблокирована. Например, при входе в блок `synchronized`. Нить подошла к блоку кода, помеченному `synchronized`, а он занят другой нитью. 
Тогда наша нить получит состояние blocked и будет ждать освобождения объекта-мьютекса.

4. **Waiting**

Есть еще отдельное состояние, когда нить не blocked, но и не ready – это waiting. Например, при вызове методов `join()` у другой нити наша нить как-бы 
«присоединяется к ней», а на деле – просто ждет ее завершения. Кроме того, есть еще метод `wait()`, вызов которого тоже переводит нить в состояние waiting.
Поток может ждать другой поток для завершения своей работы, например, ждать освобождения ресурсов или ввода-вывода. В этом случае его состояние изменяется 
на Waiting. После того, как ожидание потока закончилось, его состояние изменяется на Runnable и он возвращается общий пул потоков.

5. **Timed Waiting**

Нить может спать, например, при вызове метода `sleep()`. Для этого тоже есть отдельное состояние «timed waiting». «timed waiting» значит, что нить чего-то ждет
ограниченное время. Если вызвать метод wait с параметром — `wait(timeout)`, `sleep(timeout)` или `join(timeout)`, то нить перейдет в состояние timed waiting.

6. **Terminated**

После того, как поток завершает выполнение, его состояние изменяется на terminated, то есть он отработал свое и уже не нужен.

![Screenshot](../../../resources/ThreadStates.jpeg)

## Приоритеты потоков

Каждый поток в системе имеет свой приоритет. Приоритет – это некоторое число в объекте потока, более высокое значение которого означает больший приоритет.
Система в первую очередь выполняет потоки с большим приоритетом, а потоки с меньшим приоритетом получают процессорное время только тогда, 
когда их более привилегированные собратья простаивают. Работать с приоритетами потока можно с помощью двух функций:
- `void setPriority(int priority)` – устанавливает приоритет потока. Возможные значения priority — `MIN_PRIORITY`, `NORM_PRIORITY` и `MAX_PRIORITY`.
- `int getPriority()` – получает приоритет потока.

## Полезные методы класса Thread

- `boolean isAlive()` — возвращает `true` если поток выполняется и `false` если поток еще не был запущен или был завершен.
- `setName(String threadName)` – Задает имя потока. Имя потока – ассоциированная с ним строка, которая в некоторых случаях помогает понять, 
какой поток выполняет некоторое действие. Иногда это бывает полезным.
- `String getName()` – Получает имя потока.
- `static Thread Thread.currentThread()` — статический метод, возвращающий объект потока, в котором он был вызван.
- `long getId()` – возвращает идентификатор потока.

## synchronized (Синхронизация)

Синхронизированный блок кода может быть выполнен только одним потоком одновременно.

Многопоточность может привести к тому, что два или более потока получат доступ к одному и тому же полю или объекту. 
Синхронизация это процесс, который позволяет выполнять все параллельные потоки в программе синхронно. 
Синхронизация позволяет избежать ошибок согласованности памяти, вызванные из-за непоследовательного доступа к общей памяти.

Когда метод объявлен как `synchronized` — нить держит монитор для объекта, метод которого исполняется. 
Если другой поток выполняет синхронизированный метод, ваш поток заблокируется до тех пор, пока другой поток не отпустит монитор.
Синхронизация достигается в Java использованием зарезервированного слова `synchronized`. 
Вы можете использовать его в своих классах определяя синхронизированные методы или блоки. 
Вы не сможете использовать `synchronized` в переменных или атрибутах в определении класса.

Во время написания многопоточной программы нужно уделять особое внимание работе с общими для потоков изменяемыми объектами. 
Давайте представим, что мы хотим увеличить такую переменную на единицу. Мы создаём поле `count` и метод `increment()`, который увеличивает `count` на единицу:

```java
int count = 0;

void increment() {
    count = count + 1;
}
```

Если мы будем вызывать этот метод одновременно из двух потоков, у нас возникнут серьёзные проблемы:

```java
ExecutorService executor = Executors.newFixedThreadPool(2);

IntStream.range(0, 10000)
    .forEach(i -> executor.submit(this::increment));

stop(executor);

System.out.println(count);  // 9965
```

Вместо ожидаемого постоянного результата 10000 мы будем каждый раз получать разные числа. 
Причина этого — использование изменяемой переменной несколькими потоками без синхронизации, что вызывает 
[race condition (состояние гонки)](#race-condition-состояние-гонки)

Почему каждый раз при запуске мы получаем разный результат описанно в разделе [атомарных типов](#что-такое-атомарные-типы)

К счастью, Java поддерживает синхронизацию потоков с самых ранних версий, используя для этого ключевое слово `synchronized`. 
Вот как следовало бы переписать наш код:

```java
synchronized void incrementSync() {
    count = count + 1;
}
```

Это ключевое слово можно применять не только к методам, но и к отдельным их блокам:

```java
void incrementSync() {
    synchronized (this) {
        count = count + 1;
    }
}
```

## Блокировки

Кроме использования блокировок неявно (с помощью ключевого слова `synchronized`), **Concrurrency API** предлагает много способов их явного использования,
определённых интерфейсом `Lock`. С помощью явных блокировок можно настроить работу программы гораздо тоньше и тем самым сделать её эффективнее.

Стандартный JDK предоставляет множество реализаций `Lock`, которые мы сейчас и рассмотрим.

#### ReentrantLock
Класс ReentrantLock реализует то же поведение, что и обычные неявные блокировки. 
Давайте попробуем переписать наш пример с увеличением на единицу с помощью него:

```java
ReentrantLock lock = new ReentrantLock();
int count = 0;

void increment() {
    lock.lock();
    try {
        count++;
    } finally {
        lock.unlock();
    }
}
```

Блокировка осуществляется с помощью метода `lock()`, а освобождаются ресурсы помощью метода `unlock()`. Очень важно оборачивать код в `try{}finally{}`, 
чтобы ресурсы освободились даже в случае выброса исключения. Код, представленный выше, так же потокобезопасен, как и его аналог с `synchronized`. 
Если один поток вызвал `lock()`, и другой поток пытается получить доступ к методу до вызова `unlock()`, то второй поток будет простаивать до тех пор, 
пока метод не освободится. Только один поток может удерживать блокировку в каждый момент времени.

Для большего контроля явные блокировки поддерживают множество специальных методов:

```java
ExecutorService executor = Executors.newFixedThreadPool(2);
ReentrantLock lock = new ReentrantLock();

executor.submit(() -> {
    lock.lock();
    try {
        sleep(1);
    } finally {
        lock.unlock();
    }
});

executor.submit(() -> {
    System.out.println("Locked: " + lock.isLocked());
    System.out.println("Held by me: " + lock.isHeldByCurrentThread());
    boolean locked = lock.tryLock();
    System.out.println("Lock acquired: " + locked);
});

stop(executor);
```

Пока первый поток удерживает блокировку, второй выведет следующую информацию:

```java
Locked: true
Held by me: false
Lock acquired: false
```

Метод `tryLock()`, в отличие от обычного `lock()` не останавливает текущий поток в случае, если ресурс уже занят. 
Он возвращает булевый результат, который стоит проверить перед тем, как пытаться производить какие-то действия с общими объектами 
(`true` обозначает, что контроль над ресурсами захватить удалось).

#### ReadWriteLock

Интерфейс `ReadWriteLock` предлагает другой тип блокировок — отдельную для чтения, и отдельную для записи. Этот интерфейс был добавлен из соображения, 
что считывать данные (любому количеству потоков) безопасно до тех пор, пока ни один из них не изменяет переменную. 
Таким образом, блокировку для чтения (`read-lock`) может удерживать любое количество потоков до тех пор, пока не удерживает блокировка для записи 
(`write-lock`). Такой подход может увеличить производительность в случае, когда чтение используется гораздо чаще, чем запись.

```java
ExecutorService executor = Executors.newFixedThreadPool(2);
Map<String, String> map = new HashMap<>();
ReadWriteLock lock = new ReentrantReadWriteLock();

executor.submit(() -> {
    lock.writeLock().lock();
    try {
        sleep(1);
        map.put("foo", "bar");
    } finally {
        lock.writeLock().unlock();
    }
});
```

В примере выше мы можем видеть, как поток блокирует ресурсы для записи, после чего ждёт одну секунду, записывает данные в `HashMap` и освобождает ресурсы.
Предположим, что в это же время были созданы ещё два потока, которые хотят получить из хэш-таблицы значение:

```java
Runnable readTask = () -> {
    lock.readLock().lock();
    try {
        System.out.println(map.get("foo"));
        sleep(1);
    } finally {
        lock.readLock().unlock();
    }
};

executor.submit(readTask);
executor.submit(readTask);

stop(executor);
```

Если вы попробуете запустить этот пример, то заметите, что оба потока, созданные для чтения, будут простаивать секунду, ожидая завершения работы потока для
записи. После снятия блокировки они выполнятся параллельно, и одновременно запишут результат в консоль. Им не нужно ждать завершения работы друг друга, 
потому что выполнять одновременное чтение вполне безопасно (до тех пор, пока ни один поток не работает параллельно на запись).

## Семафоры

Семафоры — отличный способ ограничить количество потоков, которые одновременно работают над одним и тем же ресурсом:

```java
ExecutorService executor = Executors.newFixedThreadPool(10);

Semaphore semaphore = new Semaphore(5);

Runnable longRunningTask = () -> {
    boolean permit = false;
    try {
        permit = semaphore.tryAcquire(1, TimeUnit.SECONDS);
        if (permit) {
            System.out.println("Semaphore acquired");
            sleep(5);
        } else {
            System.out.println("Could not acquire semaphore");
        }
    } catch (InterruptedException e) {
        throw new IllegalStateException(e);
    } finally {
        if (permit) {
            semaphore.release();
        }
    }
}

IntStream.range(0, 10)
    .forEach(i -> executor.submit(longRunningTask));

stop(executor);
```

В этом примере `executor` может потенциально запустить все 10 вызываемых потоков, однако мы создали семафор, который ограничивает количество одновременно
выполняемых потоков до пяти. Снова напомню, что важно освобождать ресурсы именно в блоке `finally{}` на случай выброса исключений. 
Для приведённого выше кода вывод будет следующим:

```java
Semaphore acquired
Semaphore acquired
Semaphore acquired
Semaphore acquired
Semaphore acquired
Could not acquire semaphore
Could not acquire semaphore
Could not acquire semaphore
Could not acquire semaphore
Could not acquire semaphore
```

## Блокировка на уровне объекта (блокировка экземпляра)

Это механизм синхронизации **не статического** метода или не статического блока кода, такой, что только один поток сможет выполнить данный блок или метод на
данном экземпляре класса. Это нужно делать всегда, когда необходимо сделать **данные на уровне экземпляра потокобезопасными**. 

```java
public class DemoClass{
    public synchronized void demoMethod(){}
}

// Реализация 1
public class DemoClass{
    public void demoMethod(){
        synchronized (this) {
            //other thread safe code
        }
    }
}

// Реализация 2
public class DemoClass{
    private final Object lock = new Object();
    public void demoMethod(){
        synchronized (lock) {
            //other thread safe code
        }
    }
}
```

## Блокировка на уровне класса (статическая блокировка)

Предотвращает возможность нескольким потокам войти в синхронизированный блок во время выполнения **в любом из доступных экземпляров класса**. 
Это означает, что если во время выполнения программы имеется 100 экземпляров класса `DemoClass`, то только один поток в это время сможет выполнить 
`demoMethod()` в любом из случаев, и все другие случаи будут заблокированы для других потоков. 
Это необходимо когда требуется сделать **статические данные потокобезопасными**.

```java
public class DemoClass{
    public synchronized static void demoMethod(){}
}

// Реализация 1
public class DemoClass{
    public void demoMethod(){
        synchronized (DemoClass.class) {
            //other thread safe code
        }
    }
}

// Реализация 2
public class DemoClass
{
    private final static Object lock = new Object();
    public void demoMethod(){
        synchronized (lock) {
            //other thread safe code
        }
    }
}
```

## Некоторые важные замечания

1. Синхронизация в Java гарантирует, что никакие два потока **не смогут выполнить синхронизированный метод одновременно или параллельно**.
2. `Synchronized` можно использовать только с методами и блоками кода. Эти методы или блоки могут быть статическими или нестатическими.
3. Когда какой либо поток входит в синхронизированный метод или блок он **приобретает блокировку** и всякий раз, когда поток выходит из синхронизированного 
метода или блока JVM снимает блокировку. Блокировка снимается, даже если нить оставляет синхронизированный метод после завершения из-за каких-либо ошибок 
или исключений.
4. `Synchronized` в Java 
[**реентабельна**](https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B5%D0%BD%D1%82%D0%B5%D1%80%D0%B0%D0%B1%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C) 
это означает, что если синхронизированный метод вызывает другой синхронизированный метод, который требует такой же замок, то текущий поток, 
который держит замок может войти в этот метод не приобретая замок.
5. Синхронизация в Java будет бросать `NullPointerException` если объект используемый в синхронизированном блоке `null`. 
Например, в вышеприведенном примере кода, если `lock` инициализируется как `null`, `synchronized(lock)` бросит`NullPointerException`.
6. Синхронизированные методы в Java вносят **дополнительные затраты на производительность** вашего приложения. Так что используйте синхронизацию, 
когда она абсолютно необходима. Кроме того, рассмотрите вопрос об использовании синхронизированных блоков кода для синхронизации только критических 
секций кода.
7. Вполне возможно, что и статический и не статический синхронизированные методы могут работать одновременно или параллельно, 
потому что они захватывают замок на разные объекты.
8. В соответствии со спецификацией языка вы не можете использовать `synchronized` в конструкторе это приведет к ошибке компиляции.
9. **Не синхронизируйте по не финальному (no final) полю**, потому что ссылка, на не финальное поле может измениться в любое время, 
а затем другой поток может получить синхронизацию на разных объектах и уже не будет никакой синхронизации вообще.
10. **Не используйте строковые литералы**, потому что на них могут ссылаться где-либо еще в приложении и может произойти **deadlock**. 
Строковые объекты, созданные через конструктор, можно безопасно использовать.

## Можно ли создать новый объект класса, если выполняется его static synchronized метод?

Можно. Статик методы классов создаются в единственном экземпляре во время загрузки класса класслоадером и принадлежат объекту `Class.MyClass`. 
Во время выполнения в потоке `static synchronized` метода захватывается блокировка именно этого объекта. 
Следовательно нам ни что не мешает создать новый экземпляр класса. 

## Что такое ThreadGroup и зачем он нужен?

ThreadGroup представляет собой **группу потоков**, которые также могут содержать в себе другие группы потоков. Группа нитей образует дерево, 
в котором каждая другая группа нитей имеет родителя (кроме исходной). 
Поток имеет право доступа к данным из своей группы нитей, но не имеет такого доступа к другим группам или к родительской группе потоков.

## Что такое ThreadPool и зачем он нужен?
Пулы потоков (нитей) представляют собой управляемую коллекцию потоков, которые доступны для выполнения различных задач. Пулы нитей, как правило, обеспечивают:
- **Повышение производительности** при выполнении большого количества задач в связи с сокращением накладных расходов на вызов каждой задачи.
- Является средством **ограничивающим расход ресурсов** при выполнении набора задач.
- Избавляют от необходимости управления жизненным циклом нитей.

## Что такое ThreadLocal переменные?

У каждого потока - т.е. экземпляра класса `Thread` - есть ассоциированная с ним таблица `ThreadLocal`-переменных. 
Ключами таблицы являются cсылки на объекты класса `ThreadLocal`, а значениями - ссылки на объекты, "захваченные" `ThreadLocal`-переменными.
Например, если мы объявим `ThreadLocal`-переменную:

```java
ThreadLocal<Object> locals = new ThreadLocal<Object>();
```

А затем, в потоке, сделаем `locals.set(myObject)`, то ключом таблицы будет ссылка на объект `locals`, а значением - ссылка на объект `myObject`. 
При этом для другого потока мы можем "положить" внутрь `locals` другое значение.

Следует обратить внимание, что `ThreadLocal` изолирует именно ссылки на объекты, а не сами объекты. 
Если изолированные внутри потоков ссылки ведут на один и тот же объект, то **возможны коллизии**.

**Важно!** Т.к. `ThreadLocal`-переменные изолированы в потоках, то инициализация такой переменной должна происходить в том же потоке, в котором она будет
использоваться. Ошибкой является инициализация такой переменной - вызов метода `set()` - в главном потоке приложения, т.к. в данном случае значение, 
переданное в методе `set()`, будет "захвачено" для главного потока, и при вызове метода `get()` в целевом потоке будет возвращен `null`.

## Что такое Executor?

Это функциональный интерфейс, который может выполнять потоки. 

## Что такое ExecutorService?

**Concurrency API** вводит понятие сервиса-исполнителя `ExecutorService` — высокоуровневую замену работе с потоками напрямую. 
Исполнители выполняют задачи **асинхронно и обычно используют пул потоков**, так что нам не надо создавать их вручную. 
Все потоки из пула будут использованы повторно после выполнения задачи, а значит, мы можем создать в приложении столько задач, сколько хотим, 
используя один исполнитель.

```java
ExecutorService executor = Executors.newSingleThreadExecutor();
executor.submit(() -> {
    String threadName = Thread.currentThread().getName();
    System.out.println("Hello " + threadName);
});

// => Hello pool-1-thread-1
```

Есть проблема - этот код никогда не остановится. **Работу исполнителей надо завершать явно**. Для этого в интерфейсе `ExecutorService` есть два метода: 
- `shutdown()`, который ждет завершения запущенных задач
- `shutdownNow()`, который останавливает исполнитель немедленно

Вот как можно остановить исполнитель:
```java
try {
    System.out.println("attempt to shutdown executor");
    executor.shutdown();
    executor.awaitTermination(5, TimeUnit.SECONDS);
}
catch (InterruptedException e) {
    System.err.println("tasks interrupted");
}
finally {
    if (!executor.isTerminated()) {
        System.err.println("cancel non-finished tasks");
    }
    executor.shutdownNow();
    System.out.println("shutdown finished");
}
```

Исполнитель пытается завершить работу, ожидая завершения запущенных задач в течение определенного времени (5 секунд). 
По истечении этого времени он останавливается, прерывая все незавершенные задачи.

#### Callable и Future в исполнителях

Давайте напишем задачу, которая возвращает целое число после секундной паузы

```java
Callable task = () -> {
    try {
        TimeUnit.SECONDS.sleep(1);
        return 123;
    }
    catch (InterruptedException e) {
        throw new IllegalStateException("task interrupted", e);
    }
};
```

`Callable`-задачи также могут быть переданы исполнителям. Но как тогда получить результат, который они возвращают? 
Поскольку метод `submit()` не ждет завершения задачи, исполнитель не может вернуть результат задачи напрямую. 
Вместо этого исполнитель возвращает специальный объект `Future`, у которого мы сможем запросить результат задачи.

```java
ExecutorService executor = Executors.newFixedThreadPool(1);
Future<Integer> future = executor.submit(task);

System.out.println("future done? " + future.isDone());

Integer result = future.get();

System.out.println("future done? " + future.isDone());
System.out.print("result: " + result);
```

Вызов метода `get()` **блокирует поток и ждет завершения задачи**, а затем возвращает результат ее выполнения. 
Поэтому второй `future.isDone()` вернет `true`, и мы увидим на консоли: `result: 123`.

Задачи жестко связаны с сервисом исполнителей, и, если вы его остановите, попытка получить результат задачи выбросит исключение.

#### Таймаут

Любой вызов метода `future.get()` блокирует поток до тех пор, пока задача не будет завершена. В наихудшем случае выполнение **задачи не завершится никогда**,
блокируя ваше приложение. Избежать этого можно, передав **таймаут**: `future.get(1, TimeUnit.SECONDS)`;

#### InvokeAll()
Исполнители могут принимать список задач на выполнение с помощью метода `invokeAll()`, который принимает коллекцию `Callable`-задач 
и возвращает список из `Future`.

```java
ExecutorService executor = Executors.newWorkStealingPool();

List<Callable<String>> callables = Arrays.asList(
        () -> "task1",
        () -> "task2",
        () -> "task3");

executor.invokeAll(callables)
    .stream()
    .map(future -> {
        try {
            return future.get();
        }
        catch (Exception e) {
            throw new IllegalStateException(e);
        }
    })
    .forEach(System.out::println);
```

#### InvokeAny()

Другой способ отдать на выполнение несколько задач — метод `invokeAny()`. Он работает немного по-другому: вместо возврата `Future` он блокирует поток до того,
как завершится хоть одна задача, и возвращает ее результат.

#### Executors.newWorkStealingPool()

Этот метод появился в Java 8 и ведет себя не так, как другие: вместо использования фиксированного количества потоков он создает `ForkJoinPool` с определенным
параллелизмом (`parallelism size`), по умолчанию равным количеству ядер машины.

#### Как обрабатывать исключения в исполнителе?

Каков результат выполнения следующего кода?

```java
executorService.submit(() -> {
    System.out.println(1 / 0);
});
```

Я был озадачен тем, как много раз он ничего не печатал. Никаких признаков `java.lang.ArithmeticException: / by zero`, ничего. 
**Пул потоков просто проглатывал исключение**, как будто оно никогда не выбрасывалось. Если бы это был поток, созданный «с нуля», без обертки в виде пула, 
мог бы сработать `UncaughtExceptionHandler`. Но с пулом потоков вы должны быть более осторожны. Если вы отправили на выполнение `Runnable` 
(без какого-либо результата, как выше), вы обязаны поместить все тело метода внутрь `try-catch`. Если вы помещаете в очередь `Callable`, удостоверьтесь, 
что вы всегда достаете его результат с помощью блокирующего `get()`, чтобы заново бросить исключение:

```java
final Future<Integer> division = executorService.submit(() -> 1 / 0);
//ниже будет выброшено ExecutionException, вызванное ArithmeticException
division.get();
```

Примечательно, что даже в **Spring framework допустили эту ошибку** в `@Async`, см.: [SPR-8995](https://jira.spring.io/browse/SPR-8995) и 
[SPR-12090](https://jira.spring.io/browse/SPR-12090).

## ScheduledExecutorService

Для того, чтобы **периодически запускать задачу**, мы можем использовать пул потоков с планировщиком. 
`ScheduledExecutorService` способен запускать задачи один или несколько раз с заданным интервалом. 
Этот пример показывает, как заставить исполнитель выполнить задачу через три секунды:

```java
ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);

Runnable task = () -> System.out.println("Scheduling: " + System.nanoTime());
ScheduledFuture<?> future = executor.schedule(task, 3, TimeUnit.SECONDS);

TimeUnit.MILLISECONDS.sleep(1337);

long remainingDelay = future.getDelay(TimeUnit.MILLISECONDS);
System.out.printf("Remaining Delay: %sms", remainingDelay);
```

Когда мы передаем задачу планировщику, он возвращает особый тип `Future` — `ScheduledFuture`, который предоставляет метод `getDelay()` 
для получения оставшегося до запуска времени. 

У исполнителя с планировщиком есть два метода для установки задач: `scheduleAtFixedRate()` и `scheduleWithFixedDelay()`. 
Первый устанавливает задачи с определенным интервалом, например, в одну секунду:

```java
ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);

Runnable task = () -> System.out.println("Scheduling: " + System.nanoTime());

int initialDelay = 0;
int period = 1;
executor.scheduleAtFixedRate(task, initialDelay, period, TimeUnit.SECONDS);
```

Кроме того, он принимает начальную задержку, которая определяет время до первого запуска. Обратите внимание, что метод `scheduleAtFixedRate()` 
не берет в расчет время выполнения задачи. Так, если вы поставите задачу, которая выполняется две секунды, с интервалом в одну, 
пул потоков рано или поздно переполнится. 
В этом случае необходимо использовать метод `scheduleWithFixedDelay()`. Он работает примерно так же, как и предыдущий, 
но указанный интервал будет отсчитываться от времени завершения предыдущей задачи.

```java
ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);

Runnable task = () -> {
    try {
        TimeUnit.SECONDS.sleep(2);
        System.out.println("Scheduling: " + System.nanoTime());
    }
    catch (InterruptedException e) {
        System.err.println("task interrupted");
    }
};

executor.scheduleWithFixedDelay(task, 0, 1, TimeUnit.SECONDS);
```

В этом примере мы ставим задачу с задержкой в одну секунду между окончанием выполнения задачи и началом следующей. 
Начальной задержки нет, и каждая задача выполняется две секунды. Так, задачи будут запускаться на 0, 3, 6, 9 и т. д. секунде. 
Как видите, метод `scheduleWithFixedDelay()` весьма полезен, если мы не можем заранее сказать, сколько будет выполняться задача.

## ForkJoinPool

`ForkJoinPool` - это реализация `ExecutorService`, которая управляет рабочими потоками и предоставляет нам инструменты для получения информации 
о состоянии и производительности пула потоков.

Рабочие потоки могут выполнять только одну задачу за раз, но `ForkJoinPool` не создает отдельный поток для каждой подзадачи. Вместо этого каждый поток 
в пуле имеет свою собственную двустороннюю очередь (или `deque`), в которой хранятся задачи.

Эта архитектура жизненно важна для балансировки нагрузки потока с помощью алгоритма **work-stealing**.

#### work-stealing алгоритм

Проще говоря, свободные потоки пытаются «**украсть**» работу у занятых потоков.

По умолчанию рабочий поток получает задачи из головы своей собственной двухсторонней очереди. Когда он пуст, поток берет задачу из хвоста 
двухсторонней очереди другого занятого потока или из глобальной очереди на вход, поскольку именно здесь, вероятно, 
будут находиться самые большие части работы.

Такой подход сводит к минимуму вероятность того, что потоки будут конкурировать за задачи. Это также уменьшает количество раз, 
когда поток должен будет искать работу, поскольку он сначала работает с самыми перегруженными очередями.

#### Как получить ForkJoinPool

В Java 8 наиболее удобный способ получить доступ к экземпляру `ForkJoinPool` - использовать его статический метод `commonPool()`. 
Как следует из названия, этот метод предоставит ссылку на общий пул, который является пулом потоков по умолчанию для каждой `ForkJoinTask`.

Согласно документации **Oracle**, использование предопределенного общего пула снижает потребление ресурсов, поскольку это препятствует 
созданию отдельного пула потоков для каждой задачи.

Сейчас получить `ForkJoinPool` еще проще: 

```java
ForkJoinPool forkJoinPool = PoolUtil.forkJoinPool;
```

С помощью конструкторов `ForkJoinPool` можно создать собственный пул потоков с определенным уровнем параллелизма, фабрикой потоков и обработчиком исключений.
В приведенном выше примере пул имеет **уровень параллелизма 2**. Это означает, что пул будет использовать 2 ядра процессора.

#### ForkJoinTask<V>

`ForkJoinTask` - это базовый тип для задач, выполняемых внутри `ForkJoinPool`. На практике следует расширить один из двух его подклассов: 
`RecursiveAction` для `void` задач и `RecursiveTask<V>` для задач, возвращающих определенный тип. 
У них обоих есть абстрактный метод `compute()`, в котором определяется логика задачи.

#### RecursiveAction пример

В приведенном ниже примере строка просто меняет регистр на верхний. Чтобы продемонстрировать разветвленное поведение платформы, пример разделяет задачу, 
если `workload.length()` больше заданного порога, с помощью метода `createSubtask()`.
Строка рекурсивно делится на подстроки, создавая экземпляры `CustomRecursiveTask`, основанные на этих подстроках. В результате метод возвращает
`List<CustomRecursiveAction>`. Список передается в `ForkJoinPool` с помощью метода `invokeAll()`:

```java
public class CustomRecursiveAction extends RecursiveAction {
 
    private String workload = "";
    private static final int THRESHOLD = 4;
 
    private static Logger logger = 
      Logger.getAnonymousLogger();
 
    public CustomRecursiveAction(String workload) {
        this.workload = workload;
    }
 
    @Override
    protected void compute() {
        if (workload.length() > THRESHOLD) {
            ForkJoinTask.invokeAll(createSubtasks());
        } else {
           processing(workload);
        }
    }
 
    private List<CustomRecursiveAction> createSubtasks() {
        List<CustomRecursiveAction> subtasks = new ArrayList<>();
 
        String partOne = workload.substring(0, workload.length() / 2);
        String partTwo = workload.substring(workload.length() / 2, workload.length());
 
        subtasks.add(new CustomRecursiveAction(partOne));
        subtasks.add(new CustomRecursiveAction(partTwo));
 
        return subtasks;
    }
 
    private void processing(String work) {
        String result = work.toUpperCase();
        logger.info("This result - (" + result + ") - was processed by " 
          + Thread.currentThread().getName());
    }
}
```

Этот шаблон можно использовать для разработки ваших собственных классов `RecursiveAction`. Для этого создайте объект, который представляет общий объем работы,
выберите подходящий порог, определите метод разделения работы и определите метод выполнения работы.

#### RecursiveTask<V> пример
	
Для задач, возвращающих значение, здесь используется аналогичная логика, за исключением того, что результат для каждой подзадачи объединяется 
в один результат:

```java
public class CustomRecursiveTask extends RecursiveTask<Integer> {
    private int[] arr;
 
    private static final int THRESHOLD = 20;
 
    public CustomRecursiveTask(int[] arr) {
        this.arr = arr;
    }
 
    @Override
    protected Integer compute() {
        if (arr.length > THRESHOLD) {
            return ForkJoinTask.invokeAll(createSubtasks())
              .stream()
              .mapToInt(ForkJoinTask::join)
              .sum();
        } else {
            return processing(arr);
        }
    }
 
    private Collection<CustomRecursiveTask> createSubtasks() {
        List<CustomRecursiveTask> dividedTasks = new ArrayList<>();
        dividedTasks.add(new CustomRecursiveTask(
          Arrays.copyOfRange(arr, 0, arr.length / 2)));
        dividedTasks.add(new CustomRecursiveTask(
          Arrays.copyOfRange(arr, arr.length / 2, arr.length)));
        return dividedTasks;
    }
 
    private Integer processing(int[] arr) {
        return Arrays.stream(arr)
          .filter(a -> a > 10 && a < 27)
          .map(a -> a * 10)
          .sum();
    }
}
```

В этом примере работа представлена массивом, хранящимся в поле `arr` класса `CustomRecursiveTask`. Метод `createSubtasks()` рекурсивно разделяет задачу 
на более мелкие части работы, пока каждая часть не станет меньше порогового значения. Затем метод `invokeAll()` отправляет подзадачи в общий пул и 
возвращает список Future.

Для запуска выполнения для каждой подзадачи вызывается метод `join()`.

#### Отправка задач в ForkJoinPool

Для отправки задач в пул потоков можно использовать несколько подходов.

Метод `submit()` или `execute()` (их варианты использования одинаковы):

```java
forkJoinPool.execute(customRecursiveTask);
int result = customRecursiveTask.join();
```

Метод `invoke()` разветвляет (**fork**) задачу и ожидает результата и не требует вызова `join()`:

```java
int result = forkJoinPool.invoke(customRecursiveTask);
```

Метод `invokeAll()` - это наиболее удобный способ передать последовательность `ForkJoinTasks` в `ForkJoinPool`. 
Он принимает задачи как параметры (two tasks, `var args` или коллекцию), затем `fork()` возвращает коллекцию объектов `Future` в том порядке, 
в котором они были созданы.

В качестве альтернативы вы можете использовать отдельные методы `fork()` и `join()`. Метод `fork()` отправляет задачу в пул, но не запускает ее выполнение.
Для этого необходимо использовать метод `join()`. В случае `RecursiveAction` функция `join()` не возвращает ничего, кроме `null`; для `RecursiveTask<V>`
возвращает результат выполнения задачи:

```java
customRecursiveTaskFirst.fork();
result = customRecursiveTaskLast.join();
```

В нашем примере `RecursiveTask<V>` мы использовали метод `invokeAll()` для отправки последовательности подзадач в пул. 
Ту же работу можно выполнить с помощью `fork()` и `join()`, хотя это имеет последствия для упорядочения результатов.

Чтобы избежать путаницы, обычно рекомендуется использовать метод `invokeAll()` для отправки более одной задачи в `ForkJoinPool`.

## CompletableFuture

`CompletableFuture` используется для асинхронного программирования в Java. Асинхронное программирование — это средство написания неблокирующего кода путём 
выполнения задачи в отдельном, отличном от главного, потоке, а также уведомление главного потока о ходе выполнения, завершении или сбое.
Таким образом, основной поток не блокируется и не ждёт завершения задачи, а значит может параллельно выполнять и другие задания.
Наличие такого рода параллелизма значительно повышает производительность программ.

## Future VS CompletableFuture

**Недостатки Future:**
- Его нельзя завершить вручную.
- Нельзя выполнять дальнейшие действия над результатом `Future` без блокирования.
- Невозможно выполнить множество `Future` один за другим.
- Невозможно объединить несколько `Future`.
- Нет обработки исключений.
 
Поэтому у нас и появился `CompletableFuture`. С его помощью можно достичь всего вышеперечисленного.
`CompletableFuture` реализует интерфейсы `Future` и `CompletionStage` и предоставляет огромный набор удобных методов для создания 
и объединения нескольких `Future`. Он также имеет полноценную поддержку обработки исключений.

[Руководство по CompletableFuture с примерами](https://annimon.com/article/3462)

## Что такое атомарные типы?

Атомарность операции чаще всего принято обозначать через ее признак неделимости: **операция может либо примениться полностью, либо не примениться вообще**.

Операция называется атомарной, если её можно безопасно выполнять при параллельных вычислениях в нескольких потоках, не используя при этом ни блокировок, 
ни синхронизацию `synchronized`.

С точки зрения программиста операции инкремента (`i++`, `++i`) и декремента (`i--`, `--i`) выглядят наглядно и компактно. Но, с точки зрения JVM данные
операции **не являются атомарными**, поскольку требуют выполнения нескольких действительно атомарных операции: 
1. Чтение текущего значения
2. Выполнение инкремента/декремента
3. Запись полученного результата. 

При работе в многопоточной среде операции инкремента и декремента могут стать источником ошибок. Т.е. в многопоточной среде простые с виду операции 
инкремента и декремента требуют использование синхронизации и блокировки. Но блокировки содержат массу недостатков, и для простейших операций 
инкремента/декремента являются тяжеловесными. Выполнение блокировки связано со средствами операционной системы и несёт в себе опасность приостановки 
с невозможностью дальнейшего возобновления потока, а также опасность взаимоблокировки или инверсии приоритетов (priority inversion). 
Кроме этого, появляются дополнительные расходы на переключение потоков.

Блокировка подразумевает **пессимистический подход**, разрешая только одному потоку выполнять определенный код, связанный с изменением значения некоторой
«общей» переменной. Таким образом, никакой другой поток не имеет доступа к определенным переменным. Но можно использовать и **оптимистический подход**. 
В этом случае блокировки не происходит, и если поток обнаруживает, что значение переменной изменилось другим потоком, то он повторяет операцию снова, 
но уже с новым значением переменной. Так работают атомарные классы.

## Volatile

Если вы пометите любую переменную как volatile, эта переменная будет считываться из основной памяти, а не из кэша  центрального процессора, 
поэтому каждый поток будет иметь обновленное значение в переменной.

## Полезные ссылки

[Runnable vs Callable - Baeldung](https://www.baeldung.com/java-runnable-callable)

[DeadLock and LiveLock - Baeldung](https://www.baeldung.com/java-deadlock-livelock)

[wait() and notify() in Java - Baeldung](https://www.baeldung.com/java-wait-notify)

[Guide to the Fork/Join - Baeldung](https://www.baeldung.com/java-fork-join)

[Что такое deadlock - JavaRush](https://javarush.ru/groups/posts/296-chto-takoe-deadlock-)

[Deadlock на примерах из жизни - Quora](https://www.quora.com/What-are-some-real-life-examples-of-deadlock)

[Состояния объекта Thread - JavaRush](https://javarush.ru/quests/lectures/questmultithreading.level05.lecture03)

[Синхронизация потоков, блокировка объекта и блокировка класса - JavaRush](https://javarush.ru/groups/posts/1055-sinkhronizacija-potokov-blokirovka-obhhekta-i-blokirovka-klassa)

[Реентабедбность - Wiki](https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B5%D0%BD%D1%82%D0%B5%D1%80%D0%B0%D0%B1%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C)

[Что такое ThreadLocal - samolisov blogspot](http://samolisov.blogspot.com/2011/04/threadlocal.html)

[Отличная статья про многопоточность и Executors - tproger](https://tproger.ru/translations/java8-concurrency-tutorial-1/)

[Синхронизация доступа к изменяемым объектам - tproger](https://tproger.ru/translations/java8-concurrency-tutorial-2/)

[Атомарные переменные и конкурентные таблицы - tproger](https://tproger.ru/translations/java8-concurrency-tutorial-3/)

[Атомарные классы пакета util.concurrent - java online](http://java-online.ru/concurrent-atomic.xhtml)

[Описание и пример ExecutorService - java online](http://java-online.ru/concurrent-executor.xhtml)

[Многопоточность в Java: ExecutorService - habr](https://habr.com/en/post/116363/)

[10 советов по использованию ExecutorService - habr](https://habr.com/en/post/260953/)

[Руководство по CompletableFuture с примерами - annimon](https://annimon.com/article/3462)
