## Модуль

`Модуль` - это группа тесно связанных пакетов и ресурсов вместе с новым файлом дескриптора модуля.

Другими словами, это абстракция «пакета Java-пакетов», которая позволяет нам сделать наш код еще более пригодным для повторного использования.

#### Пакеты

Пакеты внутри модуля идентичны пакетам Java, которые мы использовали с момента создания Java.

Когда мы создаем модуль, мы организуем код внутри пакетов, как мы делали это раньше с любым другим проектом.

Помимо организации нашего кода, пакеты используются для определения того, какой код является общедоступным вне модуля.

#### Ресурсы

Каждый модуль отвечает за свои ресурсы, такие как медиа или файлы конфигурации.

Раньше мы помещали все ресурсы на корневой уровень нашего проекта и вручную управляли тем, какие ресурсы принадлежали разным частям приложения.

С помощью модулей мы можем отправлять необходимые изображения и файлы XML вместе с модулем, который в них нуждается, что значительно упрощает управление нашими 
проектами.

## Модуль дескриптор

Когда мы создаем модуль, мы включаем файл дескриптора, который определяет несколько аспектов нашего нового модуля:

- `Name` - название нашего модуля
- `Dependencies` - список других модулей, от которых зависит этот модуль
- `Public packages` - список всех пакетов, которые мы хотим получить доступными извне модуля.
- `Services offered` - мы можем предоставить реализации услуг, которые могут использоваться другими модулями.
- `Services consumed` - позволяет текущему модулю быть потребителем услуги.
- `Reflection permissions` - явно позволяет другим классам использовать отражение для доступа к закрытым членам пакета.

Правила именования модулей аналогичны тому, как мы называем пакеты (точки разрешены, тире - нет). Очень часто используются имена в `project-style` 
(`my.module`) или `reverse-DNS` (`com.baeldung.mymodule`).

Нам нужно перечислить все пакеты, которые мы хотим сделать общедоступными, потому что по умолчанию все пакеты являются частными модулями.

То же верно и для `reflection`. По умолчанию мы не можем использовать `reflection` для классов, которые мы импортируем из другого модуля.

## Типы модулей

В новой модульной системе есть четыре типа модулей:

- `System modules` - это модули, перечисленные при запуске команды `list-modules` выше. Они включают модули Java SE и JDK.
- `Application modules` - эти модули мы обычно хотим сбилдить, когда решаем использовать модули. Они названы и определены в скомпилированном файле 
`module-info.class`, включенном в собранный JAR.
- `Automatic modules` - мы можем включать неофициальные модули, добавляя существующие файлы JAR в путь к модулю. Имя модуля будет производным от имени JAR. 
Автоматические модули будут иметь полный доступ для чтения ко всем остальным модулям, загруженным по пути.
- `Unnamed module` - когда класс или JAR загружаются в `classpath`, но не в путь к модулю, он автоматически добавляется в безымянный модуль. 
Это универсальный модуль для обеспечения обратной совместимости с ранее написанным кодом Java.

## Распределение модулей

Модули можно распространять одним из двух способов: как файл `JAR` или как «`exploded`» скомпилированный проект. Это, конечно, то же самое, что и любой другой
проект Java, поэтому неудивительно.

Мы можем создавать многомодульные проекты, состоящие из «основного приложения» и нескольких библиотечных модулей.

Мы должны быть осторожны, потому что у нас может быть только один модуль на файл JAR.

Когда мы настраиваем наш файл сборки, нам нужно убедиться, что каждый модуль в нашем проекте объединен как отдельный jar.

## Дефолтные модули

Когда мы устанавливаем `Java 9`, мы видим, что `JDK` теперь имеет новую структуру.

Они взяли все исходные пакеты и переместили их в новую модульную систему.

Мы можем увидеть, что это за модули, набрав в командной строке:

```java
java --list-modules
```

Эти модули разделены на четыре основные группы: `java, javafx, jdk и Oracle`.

- Модули `java` - это классы реализации для базовой спецификации языка SE.
- Модули `javafx` - это библиотеки пользовательского интерфейса FX.
- Модули `jdk` - хранят все, что нужно самому JDK.
- Модули `oracle` - хранят все, что относится к Oracle.

## Определения модуля

Чтобы настроить модуль, нам нужно поместить специальный файл в корень наших пакетов с именем `module-info.java`.

Этот файл известен как `дескриптор модуля` и содержит все данные, необходимые для создания и использования нашего нового модуля.

Мы создаем модуль с объявлением, тело которого либо пусто, либо состоит из директив модуля:

```java
module myModuleName {
     // all directives are optional
}
```

Мы начинаем объявление модуля с ключевого слова `module`, а за ним следует `имя модуля`.

Модуль будет работать с этим объявлением, но обычно нам потребуется дополнительная информация.

Вот тут-то и пригодятся директивы модуля.

#### Requires

Наша первая директива - `requires`. Эта директива модуля позволяет нам объявлять зависимости модуля:

```java
module my.module {
     requires module.name;
}
```

Теперь `my.module` имеет зависимость как во время выполнения (`runtime`), так и во время компиляции (`compile-time`) от `module.name`.

И все открытые типы, экспортированные из зависимости, доступны нашему модулю, когда мы используем эту директиву.

#### Requires static

Иногда мы пишем код, который ссылается на другой модуль, но пользователи нашей библиотеки никогда не захотят его использовать.

Например, мы могли бы написать служебную функцию, которая красиво печатает наше внутреннее состояние, когда присутствует другой модуль логирования. 
Но не каждому потребителю нашей библиотеки нужна эта функциональность, и они не хотят включать дополнительную библиотеку логирования.

В этих случаях мы хотим использовать необязательную зависимость. Используя директиву `requires static`, мы создаем зависимость только во время компиляции 
(`compile-time`):

```java
module my.module {
     requires static module.name;
}
```

#### Requires transitive

Обычно мы работаем с библиотеками, чтобы облегчить себе жизнь.

Но мы должны убедиться, что любой модуль, который вводит наш код, также внесет эти дополнительные «транзитивные» зависимости, иначе они не будут работать.

К счастью, мы можем использовать директиву `requires transitive`, чтобы заставить всех нижестоящих потребителей также читать наши требуемые зависимости:

```java
module my.module {
     requires transitive module.name;
}
```

Теперь, когда разработчик `requires my.module`, ему также не нужно будет указывать `requires module.name`, чтобы наш модуль продолжал работать.

#### Exports

По умолчанию модуль не предоставляет какой-либо свой API другим модулям. Эта сильная инкапсуляция в первую очередь была одним из ключевых факторов, 
мотивирующих создание модульной системы.

Наш код значительно более безопасен, но теперь нам нужно явно открыть наш API для всего мира, если мы хотим, чтобы его можно было использовать.

Мы используем директиву exports, чтобы предоставить доступ ко всем публичным членам указанного пакета:

```kava
module my.module {
     exports com.my.package.name;
}
```

Теперь, когда кому-то требуется `my.module`, у них будет доступ к общедоступным типам в нашем пакете `com.my.package.name`, но не к любому другому пакету.

#### Exports … to

Мы можем использовать `exports … to`, чтобы открыть наши общедоступные классы миру.

Но что, если мы не хотим, чтобы весь мир имел доступ к нашему API?

Мы можем ограничить, какие модули имеют доступ к нашим API, используя директиву `exports … to`.

Подобно директиве экспорта, мы объявляем пакет экспортированным. Но мы также перечисляем, какие модули мы разрешаем импортировать этот пакет по мере 
необходимости. Посмотрим, как это выглядит:

```java
module my.module {
     exports com.my.package.name to com.specific.package;
}
```

#### Uses

Сервис - это реализация определенного интерфейса или абстрактного класса, который может использоваться другими классами.

Мы обозначаем сервисы, которые использует наш модуль, с помощью директивы `uses`.

Обратите внимание, что имя класса, которое мы используем, является **либо интерфейсом, либо абстрактным классом** сервиса, а не классом реализации:

```java
module my.module {
     uses class.name;
}
```

Здесь следует отметить различие между директивой `requires` и директивой `uses`.

Нам может потребоваться модуль, который предоставляет сервис, который мы хотим использовать, но этот сервис реализует интерфейс из одной из своих транзитивных
зависимостей.

Вместо того, чтобы заставлять наш модуль требовать все транзитивные зависимости на всякий случай, мы используем директиву `uses`, чтобы добавить требуемый
интерфейс в путь к модулю.

#### Provides … with

Модуль также может быть поставщиком услуг, который могут использовать другие модули.

Первая часть директивы - это ключевое слово `provides`. Здесь мы помещаем интерфейс или имя абстрактного класса.

Затем у нас есть директива `with`, в которой мы указываем имя класса реализации, который либо реализует интерфейс, либо расширяет абстрактный класс.

Вот как это выглядит вместе:

```java
module my.module {
     provides MyInterface with MyInterfaceImpl;
}
```

#### Open

Ранее мы упоминали, что инкапсуляция была движущим мотивом для разработки этой модульной системы.

До Java 9 можно было использовать `reflection` для проверки каждого типа и члена в пакете, даже приватных. Ничего не было по-настоящему инкапсулировано, 
что может создать всевозможные проблемы для разработчиков библиотек.

Поскольку Java 9 обеспечивает строгую инкапсуляцию, теперь мы должны явно предоставить разрешение другим модулям на `reflection` в наших классах.

Если мы хотим продолжать разрешать полное `reflection`, как это делали более старые версии Java, мы можем просто открыть весь модуль:

```java
open module my.module {
}
```

#### Opens

Если нам нужно разрешить `reflection` частных типов, но мы не хотим, чтобы весь наш код был открыт, мы можем использовать директиву `opens` для предоставления 
определенных пакетов.

Но помните, что это откроет пакет для всего мира, поэтому убедитесь, что это то, что вы хотите:

```java
module my.module {
   opens com.my.package;
}
```

#### Opens … to

Хорошо, иногда `reflection` - это здорово, но мы все же хотим максимальной безопасности, которую мы можем получить от инкапсуляции. 
Мы можем выборочно открывать наши пакеты для предварительно утвержденного списка модулей, в данном случае с помощью директивы `opens … to`:

```java
module my.module {
     opens com.my.package to moduleOne, moduleTwo;
}
```

## Управление через командную строку

К настоящему времени в `Maven` и `Gradle` добавлена поддержка модулей Java 9, поэтому вам не нужно будет много вручную билдить свои проекты. 
Однако по-прежнему важно знать, как использовать модульную систему из командной строки.

Мы будем использовать командную строку для нашего полного примера ниже, чтобы помочь нам понять, как вся система работает в нашем сознании.

- `module-path` - мы используем параметр `–module-path`, чтобы указать путь к модулю. Это список из одного или нескольких каталогов, содержащих ваши модули.
- `add-reads` - вместо того, чтобы полагаться на файл объявления модуля, мы можем использовать в командной строке эквивалент директивы `requires`;`–Add-reads`.
- `add-exports` - замена командной строки для директивы `exports`.
- `add-opens` - заменяет open в файле объявления модуля.
- `add-modules` - добавляет список модулей в набор модулей по умолчанию.
- `list-modules` - выводит список всех модулей и их строки версий.
- `patch-module` - Добавить или переопределить классы в модулях
- `illegal-access=permit|warn|deny `- ослабляет строгую инкапсуляцию, показывает одно глобальное предупреждение, отображает все предупреждения, 
либо падает с ошибками. По умолчанию это `permit`.

## Доступность

Нам следует немного поговорить о видимости нашего кода.

Многие библиотеки используют рефлексию для своего волшебства (на ум приходят `JUnit` и `Spring`).

По умолчанию в Java 9 у нас будет доступ только к `public` классам, методам и полям в наших экспортированных пакетах. Даже если мы используем рефлексию для
доступа к непубличным членам и вызовем `setAccessible(true)`, мы не сможем получить доступ к этим членам.

Мы можем использовать параметры `open`, `opens` и `opens… to`, чтобы предоставить доступ только во время выполнения для рефлексии. Обратите внимание, 
это только время выполнения!

Мы не сможем компилировать с закрытыми типами, да и никогда не должны этого делать.

Если у нас должен быть доступ к модулю для рефлексии, и мы не являемся владельцем этого модуля (т. Е. Мы не можем использовать директиву `opens … to`), то 
можно использовать параметр командной строки `–add-opens` чтобы разрешить рефлексию собственных модулей доступ к заблокированному модулю во время выполнения.

Единственное предостережение здесь в том, что вам необходимо иметь доступ к аргументам командной строки, которые используются для запуска модуля, чтобы это 
работало.

## Пример

Во-первых, нам нужно настроить структуру нашего проекта. Мы создадим несколько каталогов для организации наших файлов. Начнем с создания папки проекта:

```java
mkdir module-project
cd module-project
```

Это основа всего нашего проекта, поэтому добавьте сюда файлы, такие как файлы сборки Maven или Gradle, другие исходные каталоги и ресурсы. 
Мы также помещаем каталог для хранения всех модулей нашего проекта. Далее мы создаем каталог модуля:

```java
mkdir simple-modules
```

Вот как будет выглядеть структура нашего проекта:

```java
module-project
|- // src if we use the default package
|- // build files also go at this level
|- simple-modules
  |- hello.modules
    |- com
      |- baeldung
        |- modules
          |- hello
  |- main.app
    |- com
      |- baeldung
        |- modules
          |- main
```

#### Создание первого модуля

В каталоге простых модулей создайте новый каталог с именем `hello.modules`.

Мы можем назвать это как угодно, но следуем правилам именования пакетов (т. Е. Точками для разделения слов и т. Д.). Мы даже можем использовать имя нашего 
основного пакета в качестве имени модуля, если захотим, но обычно мы хотим придерживаться того же имени, которое мы использовали бы для создания JAR этого 
модуля.

В нашем новом модуле мы можем создавать пакеты, которые нам нужны. В нашем случае мы собираемся создать одну структуру пакета:

```java
com.baeldung.modules.hello
```

Затем создайте в этом пакете новый класс с именем `HelloModules.java`. Мы сделаем код простым:

```java
package com.baeldung.modules.hello;
 
public class HelloModules {
    public static void doSomething() {
        System.out.println("Hello, Modules!");
    }
}
```

И, наконец, в корневой каталог `hello.modules` добавьте дескриптор нашего модуля - `module-info.java`:

```java
module hello.modules {
    exports com.baeldung.modules.hello;
}
```

Чтобы упростить этот пример, все, что мы делаем, это экспортируем всех публичных членов пакета `com.baeldung.modules.hello`.

#### Второй модуль

Наш первый модуль хорош, но ничего не делает. Мы можем создать второй модуль, который использует его сейчас. В нашем каталоге простых модулей создайте 
еще один каталог модулей с именем `main.app`. На этот раз мы начнем с дескриптора модуля:

```java
module main.app {
    requires hello.modules;
}
```

Нам не нужно ничего открывать внешнему миру. Вместо этого все, что нам нужно сделать, это зависеть от нашего первого модуля, чтобы у нас был доступ к 
открытым классам, которые он экспортирует.

Теперь мы можем создать приложение, которое его использует.

Создайте новую структуру пакета: `com.baeldung.modules.main`.

Теперь создайте новый файл класса с именем `MainApp.java`.

```java
package com.baeldung.modules.main;
 
import com.baeldung.modules.hello.HelloModules;
 
public class MainApp {
    public static void main(String[] args) {
        HelloModules.doSomething();
    }
}
```

И это весь код, который нам нужен для демонстрации модулей. Наш следующий шаг - собрать и запустить этот код из командной строки.

#### Build модулей

Чтобы собрать наш проект, мы можем создать простой `bash` скрипт и поместить его в корень нашего проекта. Создайте файл с именем `compile-simple-modules.sh`:

```java
#!/usr/bin/env bash
javac -d outDir --module-source-path simple-modules $(find simple-modules -name "*.java")
```

Эта команда состоит из двух частей: `javac` и команды `find`.

Команда `find` просто выводит список всех файлов `.java` в нашем каталоге `simple-modules`. Затем мы можем передать этот список прямо в компилятор `Java`.

Единственное, что нам нужно сделать иначе, чем в более старых версиях Java, - это предоставить параметр `module-source-path`, чтобы сообщить компилятору, 
что он создает модули.

Как только мы запустим эту команду, у нас будет папка `outDir` с двумя скомпилированными модулями внутри.

#### Запуск кода

И теперь мы наконец можем запустить наш код, чтобы убедиться, что модули работают правильно. Создайте еще один файл в корне проекта: 
`run-simple-module-app.sh`.

```java
#!/usr/bin/env bash
java --module-path outDir -m main.app/com.baeldung.modules.main.MainApp
```

Чтобы запустить модуль, мы должны указать как минимум путь к модулю и основной класс. Если все работает, вы должны увидеть:

```java
>$ ./run-simple-module-app.sh 
Hello, Modules!
```

#### Добавление сервиса

Теперь, когда у нас есть базовое представление о том, как создать модуль, давайте немного усложним его.

Мы собираемся посмотреть, как использовать директивы `provide … with` и `uses`.

Начните с определения нового файла в модуле `hello.modules` с именем `HelloInterface.java`. Чтобы упростить задачу, мы собираемся реализовать этот интерфейс 
с помощью нашего существующего класса `HelloModules.java`:

```java
public interface HelloInterface {
    void sayHello();
}

public class HelloModules implements HelloInterface {
    public static void doSomething() {
        System.out.println("Hello, Modules!");
    }
 
    public void sayHello() {
        System.out.println("Hello!");
    }
}
```

Это все, что нам нужно сделать, чтобы создать сервис. Теперь нам нужно сообщить миру, что наш модуль предоставляет эту услугу. 
Добавьте в наш `module-info.java` следующее:

```java
provides com.baeldung.modules.hello.HelloInterface with com.baeldung.modules.hello.HelloModules;
```

Как видим, мы объявляем интерфейс и какой класс его реализует. Далее нам нужно использовать эту службу. В нашем модуле `main.app` добавим в наш 
`module-info.java` следующее:

```java
uses com.baeldung.modules.hello.HelloInterface;
```

Наконец, в нашем основном методе мы можем использовать этот сервис через `ServiceLoader`:

```java
Iterable<HelloInterface> services = ServiceLoader.load(HelloInterface.class);
HelloInterface service = services.iterator().next();
service.sayHello();
```

Скомпилим и запустим:

```java
#> ./run-simple-module-app.sh 
Hello, Modules!
Hello!
```

Мы используем эти директивы, чтобы более четко указать, как должен использоваться наш код. Мы могли бы поместить реализацию в `private` пакет, 
а интерфейс - в `public` пакете. Это делает наш код намного более безопасным с очень небольшими дополнительными расходами.

## Добавление модуля в Unnamed Modules

Концепция `Unnamed Module` аналогична `default package`. Поэтому он не считается реальным модулем, но может рассматриваться как модуль по умолчанию.

Если класс не является членом `named module`, он будет автоматически рассматриваться как часть этого `unnamed module`.

Иногда, чтобы обеспечить наличие определенных модулей платформы, библиотеки или поставщика услуг в графе модулей, нам нужно добавить модули в корневой набор 
по умолчанию. Например, когда мы пытаемся запускать программы Java 8 как есть с компилятором Java 9, нам может потребоваться добавить модули.

Как правило, опция добавления именованных модулей в набор корневых модулей по умолчанию: `–add-modules <module>(, <module>)*`, где `module` - имя модуля.

Например, чтобы предоставить доступ ко всем модулям java.xml.bind, синтаксис будет следующим:

```java
--add-modules java.xml.bind
```

Чтобы использовать это в Maven, мы можем встроить то же самое в `maven-compiler-plugin`:

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>3.8.0</version>
    <configuration>
        <source>9</source>
        <target>9</target>
        <compilerArgs>
            <arg>--add-modules</arg>
            <arg>java.xml.bind</arg>
        </compilerArgs>
    </configuration>
</plugin>
```

## Полезные ссылки

Данный документ является переводом статьи: [A Guide to Java 9 Modularity - Baeldung](https://www.baeldung.com/java-9-modularity)
