<!-- TOC -->
* [Graal - JIT (Just-in-time) compiler](#graal---jit-just-in-time-compiler)
  * [Graal](#graal)
  * [Что такое JIT-компилятор?](#что-такое-jit-компилятор)
  * [Полезные ссылки](#полезные-ссылки)
<!-- TOC -->

# Graal - JIT (Just-in-time) compiler

Это программа, которая помогает преобразовывать байт-код `Java` в инструкции, которые отправляются непосредственно процессору. По умолчанию в `Java` включен `JIT`
-компилятор, который активируется каждый раз при вызове метода `Java`. Затем `JIT`-компилятор компилирует байт-код вызванного метода в собственный машинный код, 
компилируя его «как раз вовремя» для выполнения. После компиляции метода `JVM` вызывает скомпилированный код этого метода напрямую, а не интерпретирует его. Вот 
почему он часто отвечает за оптимизацию производительности приложений `Java` во время выполнения.

## Graal

В этом выступлении я покажу некоторые механизмы работы используемого всеми вами языка — `Java`. Особенностью является то, что я буду использовать проект под 
названием `Graal`.

`Graal` является только одной из составляющих в работе `Java` — это `just-in-time` компилятор. Это та часть `JVM`, которая преобразует байткод `Java` в машинный код 
в ходе работы программы, и является одним из факторов обеспечивающих высокую производительность платформы. Также это, как мне кажется, то, что большинство людей 
считают одной из наиболее сложных и туманных частей `JVM`, которая находится вне рамок их понимания. Изменить это мнение является целью данного выступления.

Если вы знаете, что такое `JVM`; в целом понимаете, что означают термины байткод и машинный код; и способны читать код написанный на `Java`, то, я надеюсь, этого 
будет достаточно, чтобы понять излагаемый материал.

Я начну с обсуждения того почему мы можем хотеть новый `JIT`-компилятор для `JVM` написанный на `Java`, а после покажу, что в этом нет чего-то сверх особенного, как 
вы могли бы думать, разбив задачу на сборку компилятора, использование, и демонстрацию того, что его код является таким же как и в любом другом приложении.

Я совсем немного затрону теорию, и потом покажу как она применяется в ходе всего процесса компиляции от байткода до машинного кода. Еще я покажу некоторые детали, и 
в конце мы поговорим о пользе данной возможности помимо реализации Java на Java ради её самой.

## Что такое JIT-компилятор?

Когда вы запускаете команду `javac` или `compile-on-save` в `IDE`, ваша программа на `Java` компилируется из `Java-кода` в `байткод JVM`, который является бинарным 
представлением программы. Он более компактен и прост, чем исходный `Java-код`. Однако, обычный процессор вашего ноутбука или сервера не может просто так выполнить 
`байткод JVM`.

Для работы вашей программы `JVM` интерпретирует этот байткод. Интерпретаторы, обычно, значительно медленнее, чем машинный код запускаемый на процессоре. По этой 
причине `JVM`, во время работы программы, может запустить еще один компилятор, который преобразует ваш байткод в машинный код, выполнить который процессор уже в 
состоянии.

Этот компилятор, обычно, намного более изощрённый, чем `javac`, выполняет сложные оптимизации чтобы в результате выдать высококачественный машинный код.

## Полезные ссылки

[Как работает Graal — JIT-компилятор JVM на Java - habr](https://habr.com/ru/post/419637/)
