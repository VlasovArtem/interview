<!-- TOC -->
* [Интересные вопросы](#интересные-вопросы)
  * [Какие преобразования называются нисходящими и восходящими?](#какие-преобразования-называются-нисходящими-и-восходящими)
  * [Зачем нужны и какие бывают блоки инициализации?](#зачем-нужны-и-какие-бывают-блоки-инициализации)
  * [Можно ли перегрузить static метод?](#можно-ли-перегрузить-static-метод)
  * [Можно ли переопределить static метод?](#можно-ли-переопределить-static-метод)
  * [Какие модификаторы по умолчанию имеют поля и методы интерфейсов?](#какие-модификаторы-по-умолчанию-имеют-поля-и-методы-интерфейсов)
  * [default методы в интерфейсе](#default-методы-в-интерфейсе)
  * [Static методы в интерфейсе](#static-методы-в-интерфейсе)
  * [Equals & hashCode](#equals--hashcode)
  * [Интерфейсы маркеры](#интерфейсы-маркеры)
  * [Клонирование объектов](#клонирование-объектов)
  * [Отличие абстрактного класса и интерфейса](#отличие-абстрактного-класса-и-интерфейса)
  * [Можно ли применить final к конструктору?](#можно-ли-применить-final-к-конструктору)
  * [Что такое finalize?](#что-такое-finalize)
  * [Как в Java передаются объекты?](#как-в-java-передаются-объекты)
  * [Преобразование типов](#преобразование-типов)
  * [Жизненный цикл объектов Java](#жизненный-цикл-объектов-java)
  * [JRE, JVM, JDK](#jre-jvm-jdk)
  * [Модификаторы доступа](#модификаторы-доступа)
  * [String, StringBuffer, StringBuilder](#string-stringbuffer-stringbuilder)
  * [Пул строк](#пул-строк)
  * [Что делает метод String.intern()?](#что-делает-метод-stringintern)
  * [Почему String immutable и final?](#почему-string-immutable-и-final)
  * [Как сделать класс immutable?](#как-сделать-класс-immutable)
  * [Какая разница между && и &?](#какая-разница-между--и-)
  * [Что такое ClassPath?](#что-такое-classpath)
  * [Java 8 - что нового?](#java-8---что-нового)
  * [Что будет если прибавить 1 к Integer.MAX_VALUE](#что-будет-если-прибавить-1-к-integermax_value)
  * [Как получилось, что 0,1 + 0,2 = 0,30000000000000004?](#как-получилось-что-01--02--030000000000000004)
<!-- TOC -->

# Интересные вопросы

## Какие преобразования называются нисходящими и восходящими?
    
Преобразование от потомка к предку называется восходящим, от предка к потомку — нисходящим. 
Нисходящее преобразование должно указываться явно с помощью указания нового типа в скобках.
    
## Зачем нужны и какие бывают блоки инициализации?

Инициализируют поля до того, как будет вызван конструктор. Бывают статические и нестатические блоки инициализации. 
Выполняются в порядке объявления. Могут быть созданы в анонимных классах. 
Первыми выполняются статические блоки инициализации. 
Сначала выполняются блоки родительского класса, затем его конструктор. 
Затем в том же порядке для классов наследников.

## Можно ли перегрузить static метод?

Перегрузить можно

## Можно ли переопределить static метод?

Нет, но при этом не будет никакой ошибки. Статический метод можно **"скрыть"**.
Переопределение метода происходит динамически (во время выполнения), это означает, что определение того, 
какая версия метода будет использоваться происходит во время выполнения в соответствии с объектом, 
используемым для вызова, в то время как статические методы ищутся статически (во время компиляции).

```java
class Display {
    public static void hello() {
        System.out.println("Hello");
    }
}

class DisplayMessage extends Display {
    public static void hello() {
        System.out.println("Hello from everyone");    
    }
}

public class App {
    public static void main(String[] args){
        Display.hello();        // Hello
        DisplayMessage.hello(); // Hello from everyone
        
        Display d = new Display();
        d.hello();              // Hello
        d = new DisplayMessage();
        d.hello();              // Hello 
        DisplayMessage dm = new DisplayMessage();
        dm.hello();             // Hello from everyone
    }
}
```

Согласно правилам переопределения методов, вызов метода разрешается во время выполнения по типу object. 
Таким образом, в нашем примере выше d.hello(), во втором вызове, должен вызывать метод hello() класса DisplayMessage, 
поскольку ссылочная переменная класса Display ссылается на объект DisplayMessage, но вызывает hello() 
самого класса Display. Это происходит потому, что выполнение статического метода разрешается во время компиляции.

Таким образом, если статический метод у производного класса имеет ту же сигнатуру, 
что и статический метод базового класса, это будет называться сокрытием метода, а не переопределением метода.

## Какие модификаторы по умолчанию имеют поля и методы интерфейсов?

Интерфейс может содержать поля, но они автоматически являются статическими (static) и неизменными (final) - константами. 
Все методы и переменные неявно объявляются как public.

## default методы в интерфейсе

С 8 версии Java можно создать default & static методы в интерфейсе.

Дефолтные методы, в отличие от обычных, объявлены с ключевым словом default в начале сигнатуры метода и 
обеспечивают реализацию.
Они позволяют нам добавлять новые методы в интерфейс, которые автоматически доступны в реализациях.

```java

public interface Vehicle {

    String getBrand();

    String speedUp();
    
    String slowDown();
    
    default String turnAlarmOn() {
        return "Turning the vehicle alarm on.";
    }
    
    default String turnAlarmOff() {
        return "Turning the vehicle alarm off.";
    }

}

public class Car implements Vehicle {
 
    private String brand;
    
    // constructors/getters
    
    @Override
    public String speedUp() {
        return "The car is speeding up.";
    }
    
    @Override
    public String slowDown() {
        return "The car is slowing down.";
    }

}

class App {
    public static void main(String[] args) { 
        Vehicle car = new Car("BMW");
        System.out.println(car.getBrand());
        System.out.println(car.speedUp());
        System.out.println(car.slowDown());
        System.out.println(car.turnAlarmOn());
        System.out.println(car.turnAlarmOff());
    }
}
```

Кроме того, они могут использоваться для предоставления дополнительных функций существующему абстрактному методу.

```java
public interface Vehicle {
    
    // additional interface methods 
    
    double getSpeed();
    
    default double getSpeedInKMH(double speed) {
       // conversion      
    }
}
```

Важно знать, что происходит, когда класс реализует несколько интерфейсов, определяющих одни и те же методы по умолчанию.

```java
public interface Alarm {
 
    default String turnAlarmOn() {
        return "Turning the alarm on.";
    }
    
    default String turnAlarmOff() {
        return "Turning the alarm off.";
    }
}

public class Car implements Vehicle, Alarm {
    // ...
}
```

В этом случае код просто не будет компилироваться, так как возникает конфликт, вызванный множественным наследованием 
интерфейсов (также известный как проблема Diamond). 
Класс Car унаследует оба набора методов по умолчанию. Какие тогда вызывать?

Чтобы решить эту двусмысленность, мы должны явно предоставить реализацию для методов:

```java

public class Car implements Vehicle, Alarm {
    @Override
    public String turnAlarmOn() {
        // custom implementation
        String alarm = "Custom alarm"; 
        // or call one of default implementations:
        alarm = Vehicle.super.turnAlarmOn();
        alarm = Alarm.super.turnAlarmOn();
        // or combine both implementations:
        alarm = Vehicle.super.turnAlarmOn() + Alarm.super.turnAlarmOn();
        return alarm;
    }
     
    @Override
    public String turnAlarmOff() {
        return Vehicle.super.turnAlarmOff();
    }
}
```

[Static and Default Methods in Interfaces in Java - Baeldung](https://www.baeldung.com/java-static-default-methods)

## Static методы в интерфейсе
    
Поскольку статические методы не принадлежат конкретному объекту, они не являются частью API классов, реализующих 
интерфейс, и их необходимо вызывать с использованием имени интерфейса, предшествующего имени метода.

```java
public interface Vehicle {
    
    // regular / default interface methods
    
    static int getHorsePower(int rpm, int torque) {
        return (rpm * torque) / 5252;
    }
}

class App {
    public static void main(String[] args){
        int power = Vehicle.getHorsePower(2500, 480);
    }
}
```

Определение статического метода в интерфейсе идентично его определению в классе. 
Более того, статический метод может быть вызван в рамках других статических методов и методов по умолчанию.

Идея методов статического интерфейса состоит в том, чтобы предоставить простой механизм, который позволяет нам 
повысить степень согласованности дизайна путем объединения общих методов в одном месте без необходимости создания объекта.

Практически то же самое можно сделать с абстрактными классами. Основное отличие заключается в том, 
что абстрактные классы могут иметь конструкторы, состояние и поведение.

## Equals & hashCode

Эквивалентным называется отношение, которое является симметричным, транзитивным и рефлексивным.
- **Рефлексивность**: для любого ненулевого x, x.equals(x) вернет true;
- **Транзитивность**: для любого ненулевого x, y и z, если x.equals(y) и y.equals(z) вернет true, 
тогда и x.equals(z) вернет true;
- **Симметричность**: для любого ненулевого x и y, x.equals(y) должно вернуть true, тогда и только тогда, 
когда y.equals(x) вернет true.

Также для любого ненулевого x, x.equals(null) должно вернуть false
	
Если хеш-коды разные, то и входные объекты гарантированно разные.
Если хеш-коды равны, то входные объекты не всегда равны.

Ситуация, когда у разных объектов одинаковые хеш-коды называется — **коллизией**. Вероятность возникновения коллизии 
зависит от используемого алгоритма генерации хеш-кода.
**Хеширование** - преобразование входного массива данных произвольной длины в выходную битовую строку фиксированной длины.

Общий совет: выбирать поля, которые с большой долью вероятности будут различаться.
 
**Порядок объявления**:
1. Проверка ссылок объектов
2. Проверка на null / проверка instanceof
3. Сравнить super.equals() если нужно
4. Привести объект к типу
5. Сравнить поля

**Распространенные ошибки**:
1. Часто метод перегружают, вместо переопределения. В Object метод определен как equals(Object o), 
по ошибке делают так equals(Person p).
2. Не проверяют переменные на null
3. Не переопределяют hashcode

## Интерфейсы маркеры

Иногда полезно определить пустой интерфейс. Класс может реализовать этот интерфейс, указав его в секции implements. 
При этом нет необходимости реализовывать методы. Любой экземпляр класса становится экземпляром интерфейса. 
С помощью оператора instanceof Java код может проверить, является ли объект экземпляром интерфейса. 
Таким образом, эта техника полезна для предоставления дополнительной информации об объекте. 

Интерфейс `java.lang.Cloneable` является примером интерфейса-маркера (marker interface). 
Он не определяет методов, но идентифицирует класс, внутреннее состояние которого можно клонировать методом `clone()` 
класса Object.

Пусть дан произвольный объект. Наличие у него работающего метода clone() можно определить с помощью следующего кода:

```java
class App {
    public static void main(String[] args){
        int[] aint = new int[10];
        int[] bint;
        if (aint instanceof Cloneable) bint = aint.clone();
        else bint = null;
    }
}
```

Еще одним примером интерфейса-маркера является интерфейс `java.io.Serializable`.

## Клонирование объектов

Чтобы объект можно было клонировать, он должен реализовать интерфейс-маркер **Cloneable**. 
Использование этого интерфейса влияет на поведение метода `clone()` класс Object. 
Таким образом `myObj.clone()` создаст нам клон нашего объекта, но этот клон будет поверхностный. 
Что значит **поверхностное клонирование**? Это значит что клонируется только примитивные поля класса, ссылочные поля не клонируются! 

Чтобы произвести **глубокое клонирование**, необходимо в клонируемом классе **переопределить метод clone()**, 
и в нем произвести клонирование изменяемых полей объекта.
Если класс имеет только члены примитивных типов, то будет создана совершенно новая копия объекта 
и возвращена ссылка на этот объект. Если класс содержит не только члены примитивных типов, а и любого другого типа 
класса, тогда копируются ссылки на объекты этих классов. Следовательно, оба объекта будут иметь одинаковые ссылки.

**Глубокое клонирование** требует выполнения следующих правил:
- Нет необходимости копировать отдельно примитивные данные;
- Все классы-члены в оригинальном классе должны поддерживать клонирование. Для каждого члена класса должен 
вызываться super.clone() при переопределении метода clone().
- Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый 
экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному. 

## Отличие абстрактного класса и интерфейса

Интерфейс описывает только поведение (методы) объекта, а вот состояний (полей) у него нет (кроме public static final), 
в то время как у абстрактного класса они могут быть.

Абстрактный класс наследуется (extends), а интерфейс — реализуется (implements). 
Мы можем наследовать только один класс, а реализовать интерфейсов — сколько угодно. 
Интерфейс может наследовать (extends) другой интерфейс/интерфейсы.

Абстрактные классы используются, когда есть отношение "is-a", то есть класс-наследник расширяет базовый абстрактный 
класс, а интерфейсы могут быть реализованы разными классами, вовсе не связанными друг с другом.

Абстрактный метод – это метод без тела.

## Можно ли применить final к конструктору?

Final метод не может быть переопределен какими-либо подклассами. Модификатор final предотвращает изменение метода в подклассе.
Основное намерение сделать метод final - не допустить изменения его содержимого посторонними лицами.

Другими словами, конструкторы не могут быть унаследованы в Java, поэтому нет необходимости писать final 
перед конструкторами. Следовательно, java не позволяет использовать ключевое слово final перед конструктором. 
Если вы попробуете, будет сгенерирована ошибка времени компиляции, как в следующем примере.

```java
public class Sample {
   public static void main(String args[]){
      int num;
      final public Sample(){
         num = 30;
      }
   }
}


Exception in thread "main" java.lang.Error: Unresolved compilation problems:
   Syntax error, insert "enum Identifier" to complete EnumHeaderName
   Syntax error, insert "EnumBody" to complete BlockStatement
   Syntax error, insert ";" to complete Statement
   at newJavaExamples.Sample.main(Sample.java:6)
```

## Что такое finalize?

Finalize метод называется финализатором (finalizer).

Финализаторы вызываются, когда JVM выясняет, что этот конкретный экземпляр должен быть обработан сборщиком мусора. 
Такой финализатор может выполнять любые операции, в том числе возвращать объект к жизни.

Однако основная цель финализатора - освободить ресурсы, используемые объектами, до того, как они будут удалены из памяти. 
Финализатор может работать как основной механизм для операций очистки.

Вызов `finalize()` не гарантируется, т.к. приложение может быть завершено до того, как будет запущена ещё одна сборка 
мусора. 

```java
public class Finalizable {
    private BufferedReader reader;
 
    public Finalizable() {
        InputStream input = this.getClass()
          .getClassLoader()
          .getResourceAsStream("file.txt");
        this.reader = new BufferedReader(new InputStreamReader(input));
    }
 
    public String readFirstLine() throws IOException {
        String firstLine = reader.readLine();
        return firstLine;
    }

     @Override
     public void finalize() {
         try {
             reader.close();
             System.out.println("Closed BufferedReader in the finalizer");
         } catch (IOException e) {
             // ...
         }
     }
}
```

Класс `Finalizable` cодержит поле reader, которое ссылается на закрываемый ресурс. 
Когда объект создается из этого класса, он создает новый экземпляр BufferedReader, читающий из файла.

Такой экземпляр используется в методе readFirstLine для извлечения первой строки в данном файле. 
Обратите внимание, что `reader` закрывается как раз в методе finalize в данном коде.

На самом деле время, в которое сборщик мусора вызывает финализаторы, зависит от реализации JVM и условий системы, 
которые находятся вне нашего контроля.

Несколько причин, почему стоит **избегать использование финализаторов**:
- Мы не можем контролировать когда они будут вызваны. Тем самым у нас могут закончиться ресурсы еще до того, 
как вызовется финализатор.
- Финализаторы также влияют на переносимость программы. Поскольку алгоритм сборки мусора зависит от реализации JVM, 
программа может очень хорошо работать в одной системе, а в другой - по-разному.
- Еще одна важная проблема, связанная с финализаторами, - это стоимость производительности. В частности, 
JVM должна выполнять гораздо больше операций при создании и уничтожении объектов, содержащих непустой финализатор.
- Последняя проблема, о которой мы будем говорить, - это отсутствие обработки исключений во время финализации. 
Если финализатор генерирует исключение, процесс завершения отменяется, а исключение игнорируется, 
оставляя объект в поврежденном состоянии без какого-либо уведомления.

[Подробнее о финализаторах](https://www.baeldung.com/java-finalize)

## Как в Java передаются объекты?

**Java всегда передаёт объекты ПО ЗНАЧЕНИЮ**

Примитивы передаются по значению. 

Когда вы передаете ссылку на объект в метод, вы передаете **копию ссылки**. 
Клон пульта дистанционного управления. Объект все еще сидит в куче где был создан, ожидая кого-то, чтобы использовали 
пульт. Объект не волнует сколько пультов "запрограммированы", чтобы контролировать его. 
Это волнует только сборщика мусора и вас, программиста.

Передается всё то же значение, просто **значением является указатель на область памяти**.

[Передача параметров в Java](https://javarush.ru/groups/posts/857-peredacha-parametrov-v-java)

## Преобразование типов

При повышении типа byte>short; short>int; int>long; float>double; char>int информация не потеряется. 

При сужении возможна потеря информации (см. пример выше byte = (byte) int).

## Жизненный цикл объектов Java

1. JVM выделяет необходимый объем памяти для создания объекта.
2. JVM создает на него ссылку, в нашем случае — cat, чтобы иметь возможность его отслеживать. 
3. После этого происходит инициализация всех переменных, вызов конструктора и вот — наш свежий объект уже живет своей жизнью.
Если говорить точно, объект является “живым” пока на него есть ссылки. Как только ссылок не остается — объект “умирает”.
Ссылку при этом не обязательно обнулять. Можно перенаправить ее на другой объект. 
4. После этого в работу вступает garbage collector.
В момент, когда сборщик мусора добрался до объекта, перед самым его уничтожением, у объекта вызывается специальный 
метод — finalize(). Но вызывается он не всегда. JVM сама определяет, вызывать метод finalize() в каждом конкретном 
случае или нет. Не стоит полагаться на метод finalize() в случае с освобождением каких-то критически важных ресурсов.

## JRE, JVM, JDK

**JDK** - бесплатно распространяемый компанией Oracle комплект разработчика приложений на языке Java, 
включающий в себя компилятор Java (javac), стандартные библиотеки классов Java, примеры, документацию, 
различные утилиты и исполнительную систему Java (JRE).

**JRE** - минимальная реализация виртуальной машины, необходимая для исполнения Java-приложений, без компилятора 
и других средств разработки. Состоит из виртуальной машины - Java Virtual Machine и библиотеки Java-классов.

**JVM** - виртуальная машина Java - основная часть исполняющей системы Java, так называемой Java Runtime Environment (JRE). 
Виртуальная машина Java интерпретирует Байт-код Java, предварительно созданный из исходного текста Java-программы 
компилятором Java (javac). JVM может также использоваться для выполнения программ, написанных на других ЯП. 


```
                     JDK
                      |
        --------------|--------------
        |             |             |
        |             |             |
        |             |             |
       JRE          javac        library examples
        |                        docs
    ----|----                    utilities  
    |       |       
   JVM   library
```

## Модификаторы доступа

| Modifier   | Class | Package | Subclass | Global |
|------------|-------|---------|----------|--------|
| public     |   ✅   |    ✅    |    ✅    |   ✅   |
| protected  |   ✅   |    ✅    |    ✅    |   ❌   |
| default    |   ✅   |    ✅    |    ❌    |   ❌   |
| private    |   ✅   |    ❌    |    ❌    |   ❌   |

## String, StringBuffer, StringBuilder

String - immutable. Каждый раз при изменении строки создается новый объект.

StringBuffer - mutable, синхронизированный. StringBuffer является потокобезопасным. Два потока одновременно не могут вызвать методы StringBuffer. 
Из-за этого он менее эффективен, чем StringBuilder.

StringBuilder - mutable, не синхронизированный. StringBuilder не является потокобезопасным, поэтому два потока могут одновременно вызывать методы StringBuilder. Он более эффективен.

## Пул строк

**Пул строк** — область для хранения всех строковых значений, которые ты создаешь в своей программе. 
Каждый раз, когда ты пишешь `String s = “........”`, программа проверяет, есть ли строка с таким текстом в пуле строк. 
Если есть — новая создана не будет. И новая ссылка будет указывать на тот же адрес в пуле строк, где эта строка хранится.

Оператор `new` при создании объекта принудительно выделяет для него новую область в памяти. 
И строка, созданная с помощью new, не попадает в String Pool: она становится отдельным объектом, даже если ее текст полностью совпадает с такой же строкой 
из String Pool’a.

## Что делает метод String.intern()?

Метод `String.intern()` напрямую работает со String Pool’ом. Его стоит использовать в том случае, если приходится сравнивать много строк.

Когда метод `intern()` вызван, если пул строк уже содержит строку, эквивалентную к нашему объекту, что подтверждается методом `equals(Object)`, тогда 
возвращается ссылка на строку из пула. В противном случае объект строки добавляется в пул и ссылка на этот объект возвращается.

Этот метод всегда возвращает строку, которая имеет то же значение, что что и текущая строка, но гарантирует что это будет строка из пула уникальных строк.

Ниже приведен пример работы метода intern():

```java
public class StringPool {
    public static void main(String[] args) {
        String a = "string a";
        String b = new String("string a");
        String c = b.intern();

        System.out.println(a == b);
        System.out.println(b == c);
        System.out.println(a == c);
    }
}
Программа выведет следующее:
false
false
true
```

## Почему String immutable и final?

**Строковый пул** возможен только потому, что строка неизменна в Java, таким образом виртуальная машина сохраняет много места в памяти (heap space), 
поскольку разные строковые переменные указывают на одну переменную в пуле. Если бы строка не была неизменной, тогда бы интернирование строк не было бы
возможным, потому что если какая-либо переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку.

Если строка будет изменяемой, тогда это станет серьезной угрозой **безопасности** приложения. Например, имя пользователя базы данных и пароль 
передаются строкой для получения соединения с базой данных и в программировании сокетов реквизиты хоста и порта передаются строкой. 
Так как строка неизменяемая, её значение не может быть изменено, в противном случае любой хакер может изменить значение ссылки 
и вызвать проблемы в безопасности приложения.

**Строки используются в Java classloader** и неизменность обеспечивает правильность загрузки класса при помощи Classloader. 
К примеру, задумайтесь об экземпляре класса, когда вы пытаетесь загрузить java.sql.Connection класс, но значение ссылки изменено на myhacked.Connection класс,
который может осуществить нежелательные вещи с вашей базой данных.

Поскольку строка неизменная, её **hashcode кэшируется в момент создания** и нет необходимости рассчитывать его снова. 
Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. 
Это причина, почему строка наиболее часто используемый объект, используемый в качестве ключа HashMap.

## Как сделать класс immutable?

Неизменяемый класс очень прост для понимания, он **имеет только одно состояние**. Неизменяемые классы являются потокобезопасными. 
Это самое большое преимущество неизменяемого класса, потому что, - вам **не нужно применять синхронизацию** для неизменяемых объектов. 
Также, неизменяемый класс может быть полезен при помещении объекта неизменяемого класса в HashMap или может использоваться для целей кэширования,
поскольку его значение не изменится. Неизменяемые объекты **по умолчанию являются потокобезопасными**.

**Шаги для создания неизменяемого класса**:
1. Финализируйте свой класс:
Если вы финализируете свой класс - ни один класс не сможет его расширить, следовательно, не сможет переопределить методы этого класса.
2. Пометьте все переменные класса модификаторами доступа private и final:
Если вы сделаете переменную экземпляра private - ни один внешний класс не сможет получить доступ к переменным экземпляра, 
и, если вы сделаете их final - вы не сможете их изменить.
3. Скажите «нет» методам-мутаторам:
Не создавайте метод set для некоторых переменных класса, тогда не будет возможности явно изменить состояние переменных экземпляра.
4. Выполните клонирование изменяемых объектов при возврате из метода получения:
Если вы вернете клон объекта из метода get, то вернется объект. При этом, ваш оригинальный объект останется без изменений.

## Какая разница между && и &?

& - побитово оценивает обе стороны операции. 

&& - логически оценивает левую сторону операции. Если она true тогда оценит и правую сторону.

## Что такое ClassPath?

По существу classpath указывает компилятору или виртуальной машине где искать классы необходимые для сборки проекта или же его запуска.
Есть два основных способа установки classpath: в переменной окружения ОС CLASSPATH, и в аргументе командной строки -cp (синоним -classpath). 
Второй способ предпочтительнее, потому что позволяет устанавливать разные значения для разных приложений. Значение по умолчанию – текущая директория.

[Подробное и отличное объяснение](https://coderoad.ru/2396493/Что-такое-classpath#2396759)

## Java 8 - что нового?

Date API, Stream API, Functional interfaces, default and static methods in interfaces, method reference, optional, lambda expressions

[Java 8 теория и примеры](https://vertex-academy.com/tutorials/ru/java-8-uchebnik/)

## Что будет если прибавить 1 к Integer.MAX_VALUE

Ответ - `Integer.MIN_VALUE`. Потому что целое число переполняется. Когда он переполняется, следующее значение - `Integer.MIN_VALUE`

## Как получилось, что 0,1 + 0,2 = 0,30000000000000004?

Дело в том, что `double` - это число `64` битов, и возможно точно определить только 2^64 разные числа. Поэтому, будут много чисел, без точной репрезентации в
`double`.

Более того, число `0.3 (и 0.1 и 0.2)` нельзя писать в двойчной системой счисления, будет бесконечно.

Самое близкое `double` от `0.1` - это `0.100000000000000005551115123126`

Самое близкое `double` от `0.2` - это `0.200000000000000011102230246252`

И вместе получится `0.300000000000000016653345369378`

Самое близкое `double` от этого: `0.300000000000000044408920985006`

Потом `System.out.println` покажет `0.30000000000000004`.

[Неточное значение у double - Stackoverflow](https://ru.stackoverflow.com/questions/436249/%D0%9D%D0%B5%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D0%B5-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D1%83-double)

[Более подробное разъяснение - medium](https://medium.com/better-programming/why-is-0-1-0-2-not-equal-to-0-3-in-most-programming-languages-99432310d476)
