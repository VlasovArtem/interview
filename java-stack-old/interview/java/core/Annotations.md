<!-- TOC -->
* [Аннотации](#аннотации)
  * [Описание](#описание)
  * [Зачем нужны](#зачем-нужны)
  * [@Override](#override)
  * [Пример создания аннотации](#пример-создания-аннотации)
  * [Парсинг аннотаций](#парсинг-аннотаций)
  * [Дополнительные сведения](#дополнительные-сведения)
  * [Полезные ссылки](#полезные-ссылки)
<!-- TOC -->

# Аннотации

## Описание

Аннотации в Java, являются своего рода метками в коде, описывающими метаданные для поля/метода/класса/пакета. 
С помощью них программист указывает компилятору Java и средствам разработки, что делать с участками кода помимо исполнения программы.

Аннотации могут быть просто маркерами, а также могут хранить данные, которые потом будут использоваться

## Зачем нужны

Аннотации позволяют:
- автоматически создавать конфигурационные XML-файлы и дополнительный Java-код на основе исходного аннотированного кода;
- документировать приложения и базы данных параллельно с их разработкой;
- проектировать классы без применения маркерных интерфейсов;
- быстрее подключать зависимости к программным компонентам;
- выявлять ошибки, незаметные компилятору;
- решать другие задачи по усмотрению программиста.

## @Override

@Override - аннотация-маркер. Если в имени метода в классе наследнике будет опечатка, компилятор учтет @Override и выдаст ошибку. 
Без аннотации он не заметил бы подвоха и безропотно создал бы новый метод в дополнение к method из SomeClass. 
Обратите внимание, сама аннотация никак не влияет на переопределение метода, но **позволяет контролировать успешность переопределения при компиляции или сборке**.
Мы защитили участок кода от неприметной ошибки, на поиск которой в большой программе ушли бы часы. Это лишь одно из многих применений аннотаций.

## Пример создания аннотации

```java
@Retention(RetentionPolicy.RUNTIME) //Указывает, что наша Аннотация может быть использована во время выполнения через Reflection (нам как раз это нужно).
@Target(ElementType.METHOD) //Указывает, что целью нашей Аннотации является метод (не класс, не переменная, не поле, а именно метод).
public @interface Command //Описание. Заметим, что перед interface стоит @;
{
    String name(); //Команда за которую будет отвечать функция (например "привет");

    String args(); //Аргументы команды, использоваться будут для вывода списка команд

    int minArgs() default 0; //Минимальное количество аргументов, сразу присвоили 0 (логично)

    String desc(); //Описание, тоже для списка

    int maxArgs() default Integer.MAX_VALUE; //Максимальное число аргументов. В целом не обязательно, но тоже можно использовать

    boolean showInHelp() default true; //Показывать ли команду в списке (вовсе необязательная строка, но мало ли, пригодится!)

    String[] aliases(); //Какие команды будут считаться эквивалентными нашей (Например для "привет", это может быть "Здаров", "Прив" и т.д., под каждый случай заводить функцию - не рационально

}
```

**Важно!** Каждый параметр описывается как функция (с круглыми скобками). В качестве параметров могут быть использованы только примитивы, String, Enum. 
Нельзя написать List<String> args(); - ошибка.
  
## Парсинг аннотаций

Парсинг аннотаций происходит циклически. Компилятор ищет их в пользовательском коде и выбирает подходящие обработчики. 
Если вызванный обработчик на основе аннотации создаёт новые файлы с кодом, начинается следующий этап, где исходным материалом становится сгенерированный код.
Так продолжается до тех пор, пока не будут созданы все необходимые файлы.

## Дополнительные сведения

На основе аннотаций компилятор может с помощью специальных обработчиков генерировать новый код и файлы конфигурации.
Жизненный цикл аннотаций для **@Retention**: SOURCE, CLASS, RUNTIME

## Полезные ссылки

[Аннотации в Java – зачем они нужны](https://geekbrains.ru/posts/java_annotations)

[Что такое аннотации и как ими пользоваться?](https://javarush.ru/groups/posts/1896-java-annotacii-chto-ehto-i-kak-ehtim-poljhzovatjhsja)
