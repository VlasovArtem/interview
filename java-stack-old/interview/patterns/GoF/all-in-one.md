<!-- TOC -->
* [Patterns: GoF](#patterns-gof)
  * [Behavioral patterns](#behavioral-patterns)
    * [`Chain of responsibility (Цепочка обязанностей)`](#chain-of-responsibility-цепочка-обязанностей)
      * [`Проблема`](#проблема)
      * [`Решение`](#решение)
      * [`Структура`](#структура)
      * [`Применимость`](#применимость)
      * [`Источники`](#источники)
    * [`Command (Команда)`](#command-команда)
      * [`Проблема`](#проблема-1)
      * [`Решение`](#решение-1)
      * [`Структура`](#структура-1)
      * [`Применимость`](#применимость-1)
      * [`Источники`](#источники-1)
    * [`Iterator (Итератор)`](#iterator-итератор)
      * [`Проблема`](#проблема-2)
      * [`Решение`](#решение-2)
      * [`Структура`](#структура-2)
      * [`Применимость`](#применимость-2)
      * [`Источники`](#источники-2)
    * [`Mediator (Посредник)`](#mediator-посредник)
      * [`Проблема`](#проблема-3)
      * [`Решение`](#решение-3)
      * [`Структура`](#структура-3)
      * [`Применимость`](#применимость-3)
      * [`Источники`](#источники-3)
  * [Creational patterns](#creational-patterns)
    * [`Abstract factory / Factory (Абстрактная фабрика / фабрика)`](#abstract-factory--factory-абстрактная-фабрика--фабрика)
      * [`Проблема`](#проблема-4)
      * [`Решение`](#решение-4)
      * [`Структура`](#структура-4)
      * [`Применимость`](#применимость-4)
      * [`Источники`](#источники-4)
    * [`Builder (Строитель)`](#builder-строитель)
      * [`Проблема`](#проблема-5)
      * [`Решение`](#решение-5)
      * [`Структура`](#структура-5)
      * [`Применимость`](#применимость-5)
      * [`Источники`](#источники-5)
    * [`Factory method (Фабричный метод)`](#factory-method-фабричный-метод)
      * [`Проблема`](#проблема-6)
      * [`Решение`](#решение-6)
      * [`Структура`](#структура-6)
      * [`Применимость`](#применимость-6)
      * [`Источники`](#источники-6)
    * [`Prototype (Прототип)`](#prototype-прототип)
      * [`Проблема`](#проблема-7)
      * [`Решение`](#решение-7)
      * [`Реализация`](#реализация)
      * [`Структура`](#структура-7)
      * [`Применимость`](#применимость-7)
      * [`Источники`](#источники-7)
    * [`Singleton (Одиночка)`](#singleton-одиночка)
      * [`Проблема`](#проблема-8)
      * [`Решение`](#решение-8)
      * [`Структура`](#структура-8)
      * [`Применимость`](#применимость-8)
      * [`Источники`](#источники-8)
  * [Structural patterns](#structural-patterns)
    * [`Adapter (Адаптер)`](#adapter-адаптер)
      * [`Проблема`](#проблема-9)
      * [`Решение`](#решение-9)
      * [`Пример`](#пример)
      * [`Структура`](#структура-9)
      * [`Применимость`](#применимость-9)
      * [`Источники`](#источники-9)
    * [`Bridge (Мост)`](#bridge-мост)
      * [`Проблема`](#проблема-10)
      * [`Решение`](#решение-10)
      * [`Пример`](#пример-1)
      * [`Структура`](#структура-10)
      * [`Применимость`](#применимость-10)
      * [`Источники`](#источники-10)
    * [`Компоновщик (Composite)`](#компоновщик-composite)
      * [`Проблема`](#проблема-11)
      * [`Решение`](#решение-11)
      * [`Структура`](#структура-11)
      * [`Применимость`](#применимость-11)
      * [`Источники`](#источники-11)
    * [`Декоратор / Обёртка (Decorator / Wrapper)`](#декоратор--обёртка-decorator--wrapper)
      * [`Проблема`](#проблема-12)
      * [`Решение`](#решение-12)
      * [`Структура`](#структура-12)
      * [`Признаки`](#признаки)
      * [`Применимость`](#применимость-12)
      * [`Источники`](#источники-12)
    * [`Facade (Фасад)`](#facade-фасад)
      * [`Проблема`](#проблема-13)
      * [`Решение`](#решение-13)
      * [`Структура`](#структура-13)
      * [`Применимость`](#применимость-13)
      * [`Источники`](#источники-13)
    * [`Flyweight (Легковес)`](#flyweight-легковес)
      * [`Проблема`](#проблема-14)
      * [`Решение`](#решение-14)
      * [`Структура`](#структура-14)
      * [`Применимость`](#применимость-14)
      * [`Источники`](#источники-14)
    * [`Proxy (Прокси / Заместитель)`](#proxy-прокси--заместитель)
      * [`Проблема`](#проблема-15)
      * [`Решение`](#решение-15)
      * [`Структура`](#структура-15)
      * [`Применимость`](#применимость-15)
      * [`Источники`](#источники-15)
<!-- TOC -->

# Patterns: GoF

## Behavioral patterns
### `Chain of responsibility (Цепочка обязанностей)`

Цепочка обязанностей — это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно
по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать
запрос дальше по цепи.

#### `Проблема`

Представьте, что вы делаете систему приёма онлайн-заказов. Вы хотите ограничить к ней доступ так, чтобы только
авторизованные пользователи могли создавать заказы. Кроме того, определённые пользователи, владеющие правами
администратора, должны иметь полный доступ к заказам.

Вы быстро сообразили, что эти проверки нужно выполнять последовательно. Ведь пользователя можно попытаться
«залогинить» в систему, если его запрос содержит логин и пароль. Но если такая попытка не удалась,
то проверять расширенные права доступа попросту не имеет смысла.

Затем мы решили сделать еще несколько проверок
- неплохо бы проверять данные, передаваемые в запросе перед тем, как вносить их в систему —
  вдруг запрос содержит данные о покупке несуществующих продуктов.
- блокировать массовые отправки формы с одним и тем же логином, чтобы предотвратить подбор паролей ботами.
- форму заказа неплохо бы доставать из кеша, если она уже была однажды показана.

С каждой новой «фичей» код проверок, выглядящий как большой клубок условных операторов, всё больше и больше раздувался.
При изменении одного правила приходилось трогать код всех проверок.
А для того, чтобы применить проверки к другим ресурсам, пришлось продублировать их код в других классах.

#### `Решение`

Цепочка обязанностей базируется на том, чтобы превратить отдельные поведения в объекты.
Данные запроса, над которым происходит проверка, будут передаваться в метод как аргументы.

Паттерн предлагает `связать объекты обработчиков в одну цепь`. Каждый из них будет иметь ссылку на следующий обработчик
в цепи. Таким образом, при получении запроса обработчик сможет не только сам что-то с ним сделать,
но и передать обработку следующему объекту в цепочке.

Обработчик не обязательно должен передавать запрос дальше, причём эта особенность может быть использована по-разному.
В примере с фильтрацией доступа обработчики прерывают дальнейшие проверки, если текущая проверка не прошла.
Ведь нет смысла тратить попусту ресурсы, если и так понятно, что с запросом что-то не так.

![Alt text](https://refactoring.guru/images/patterns/diagrams/chain-of-responsibility/solution1-ru-2x.png)

`Но есть и другой подход`, при котором обработчики прерывают цепь только когда они могут обработать запрос.
В этом случае запрос движется по цепи, пока не найдётся обработчик, который может его обработать.
Очень часто такой подход используется для передачи событий, создаваемых классами графического интерфейса в
результате взаимодействия с пользователем.

Например, когда пользователь кликает по кнопке, программа выстраивает цепочку из объекта этой кнопки,
всех её родительских элементов и общего окна приложения на конце. Событие клика передаётся по этой цепи до тех пор,
пока не найдётся объект, способный его обработать. Этот пример примечателен ещё и тем, что цепочку всегда можно выделить
из древовидной структуры объектов, в которую обычно и свёрнуты элементы пользовательского интерфейса.

![Alt text](https://refactoring.guru/images/patterns/diagrams/chain-of-responsibility/solution2-ru-2x.png)

#### `Структура`

![Alt text](https://refactoring.guru/images/patterns/diagrams/chain-of-responsibility/example-ru-2x.png)

#### `Применимость`

- Когда программа должна обрабатывать разнообразные запросы несколькими способами, но заранее неизвестно,
  какие конкретно запросы будут приходить и какие обработчики для них понадобятся.
- Когда важно, чтобы обработчики выполнялись один за другим в строгом порядке.
- Когда набор объектов, способных обработать запрос, должен задаваться динамически.

#### `Источники`

- [Подробнее о паттерне на refactoring.guru](https://refactoring.guru/ru/design-patterns/chain-of-responsibility)

- [Реализация на Java](https://refactoring.guru/ru/design-patterns/chain-of-responsibility/java/example)

### `Command (Команда)`

Команда — это поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя
передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также
поддерживать отмену операций.

#### `Проблема`

Представьте, что вы работаете над программой текстового редактора.
Вы создали класс красивых Кнопок и хотите использовать его для всех кнопок приложения, начиная от панели управления,
заканчивая простыми кнопками в диалогах. Все эти кнопки, хоть и выглядят схоже, но делают разные вещи.
Поэтому возникает вопрос: куда поместить код обработчиков кликов по этим кнопкам

Самым простым решением было бы создать подклассы для каждой кнопки и переопределить в них метод действия под разные задачи.

Но скоро стало понятно, что такой подход никуда не годится. Во-первых, получается очень много подклассов

Но самое обидное ещё впереди. Ведь некоторые операции, например, «сохранить», можно вызывать из нескольких мест:
нажав кнопку на панели управления, вызвав контекстное меню или просто нажав клавиши Ctrl+S.
Когда в программе были только кнопки, код сохранения имелся только в подклассе SaveButton.
Но теперь его придётся продублировать ещё в два класса.

#### `Решение`

Паттерн Команда предлагает не отправлять вызовы напрямую на хендлер каждой из кнопок. А вызывать некую команду, которая
может выполнить нужное действие.

Вместо этого каждый вызов, отличающийся от других, следует завернуть в собственный класс с единственным методом,
который и будет осуществлять вызов. Такие объекты называют командами.

#### `Структура`

![Alt text](https://refactoring.guru/images/patterns/diagrams/command/example-2x.png)

#### `Применимость`

- Когда вы хотите параметризовать объекты выполняемым действием.
- Когда вы хотите ставить операции в очередь, выполнять их по расписанию или передавать по сети.
- Когда вам нужна операция отмены.

#### `Источники`

- [Подробнее о паттерне на refactoring.guru](https://refactoring.guru/ru/design-patterns/command)

- [Реализация на Java](https://refactoring.guru/ru/design-patterns/command/java/example)

### `Iterator (Итератор)`

Итератор — это поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы
составных объектов, не раскрывая их внутреннего представления.

#### `Проблема`

Большинство коллекций выглядят как обычный список элементов. Но есть и экзотические коллекции, построенные на основе
деревьев, графов и других сложных структур данных.

Но каким способом следует перемещаться по сложной структуре данных? Например, сегодня может быть достаточным обход
дерева в глубину, но завтра потребуется возможность перемещаться по дереву в ширину. А на следующей неделе и
того хуже — понадобится обход коллекции в случайном порядке.

#### `Решение`

Идея паттерна Итератор состоит в том, чтобы вынести поведение обхода коллекции из самой коллекции в отдельный класс.

![Alt text](https://refactoring.guru/images/patterns/diagrams/iterator/solution1-2x.png)

Объект-итератор будет отслеживать состояние обхода, текущую позицию в коллекции и сколько элементов ещё осталось обойти.
Одну и ту же коллекцию смогут одновременно обходить различные итераторы, а сама коллекция не будет даже знать об этом.

#### `Структура`

![Alt text](https://refactoring.guru/images/patterns/diagrams/iterator/example-2x.png)

#### `Применимость`

- Когда у вас есть сложная структура данных, и вы хотите скрыть от клиента детали её реализации
  (из-за сложности или вопросов безопасности).
- Когда вам нужно иметь несколько вариантов обхода одной и той же структуры данных.
- Когда вам хочется иметь единый интерфейс обхода различных структур данных.

#### `Источники`

- [Подробнее о паттерне на refactoring.guru](https://refactoring.guru/ru/design-patterns/iterator)

- [Реализация на Java](https://refactoring.guru/ru/design-patterns/iterator/java/example)

### `Mediator (Посредник)`

Посредник — это поведенческий паттерн проектирования, который позволяет уменьшить связанность множества классов
между собой, благодаря перемещению этих связей в один класс-посредник.

#### `Проблема`

Предположим, что у вас есть диалог создания профиля пользователя. Он состоит из всевозможных элементов управления
— текстовых полей, чекбоксов, кнопок.

Отдельные элементы диалога должны взаимодействовать друг с другом. Так, например, чекбокс «у меня есть собака»
открывает скрытое поле для ввода имени домашнего любимца, а клик по кнопке отправки запускает проверку значений
всех полей формы.

Прописав эту логику прямо в коде элементов управления, вы поставите крест на их повторном использовании
в других местах приложения. Они станут слишком тесно связанными с элементами диалога редактирования профиля,
которые не нужны в других контекстах. Поэтому вы сможете использовать либо все элементы сразу, либо ни одного.

#### `Решение`

Паттерн Посредник заставляет объекты общаться не напрямую друг с другом, а через отдельный объект-посредник,
который знает, кому нужно перенаправить тот или иной запрос. Благодаря этому, компоненты системы будут зависеть
только от посредника, а не от десятков других компонентов.

В нашем примере посредником мог бы стать диалог. Скорее всего, класс диалога и так знает, из каких элементов состоит,
поэтому никаких новых связей добавлять в него не придётся.

![Alt text](https://refactoring.guru/images/patterns/diagrams/mediator/solution1-en-2x.png)

#### `Структура`

В этом примере Посредник помогает избавиться от зависимостей между классами различных элементов пользовательского
интерфейса: кнопками, чекбоксами и надписями.

![Alt text](https://refactoring.guru/images/patterns/diagrams/mediator/example-2x.png)

#### `Применимость`

- Когда вам сложно менять некоторые классы из-за того, что они имеют множество хаотичных связей с другими классами.
- Когда вы не можете повторно использовать класс, поскольку он зависит от уймы других классов.
- Когда вам приходится создавать множество подклассов компонентов,
  чтобы использовать одни и те же компоненты в разных контекстах.

#### `Источники`

- [Подробнее о паттерне на refactoring.guru](https://refactoring.guru/ru/design-patterns/mediator)

- [Реализация на Java](https://refactoring.guru/ru/design-patterns/mediator/java/example)

## Creational patterns
### `Abstract factory / Factory (Абстрактная фабрика / фабрика)`

Абстрактная фабрика — это порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов,
не привязываясь к конкретным классам создаваемых объектов

#### `Проблема`

Нужно производить множество продуктов разных типов или с разной конфигурацией.

![Alt text](https://refactoring.guru/images/patterns/diagrams/abstract-factory/problem-ru-2x.png)

Вам нужен такой способ создавать объекты продуктов, чтобы они сочетались с другими продуктами того же семейства.
Это важно, так как клиенты расстраиваются, если получают не сочетающуюся мебель.

#### `Решение`

Для начала паттерн Абстрактная фабрика предлагает выделить общие интерфейсы для отдельных продуктов, составляющих семейства.
Так, все вариации кресел получат общий интерфейс `Кресло`, все диваны реализуют интерфейс `Диван` и так далее.

Далее вы создаете абстрактную фабрику — общий интерфейс, который содержит методы создания всех продуктов семейства
(например, `создатьКресло`, `создатьДиван` и `создатьСтолик`). Эти операции должны возвращать `абстрактные` типы продуктов,
представленные интерфейсами, которые мы выделили ранее — Кресла, Диваны и Столики.

![Alt text](https://refactoring.guru/images/patterns/diagrams/abstract-factory/solution2-2x.png)

Как насчёт вариаций продуктов? Для каждой вариации семейства продуктов мы должны создать свою собственную фабрику,
реализовав абстрактный интерфейс.
Фабрики создают продукты одной вариации. Например, `ФабрикаМодерн` будет возвращать только `КреслаМодерн`, `ДиваныМодерн` и `СтоликиМодерн`.

#### `Структура`

Пример с GUI Factory

![Alt text](https://refactoring.guru/images/patterns/diagrams/abstract-factory/example-2x.png)

#### `Применимость`

- Когда бизнес-логика программы должна работать с разными видами связанных друг с другом продуктов, не завися от конкретных классов продуктов.
- Когда в программе уже используется Фабричный метод, но очередные изменения предполагают введение новых типов продуктов.

#### `Источники`

- [Подробнее о паттерне на refactoring.guru](https://refactoring.guru/ru/design-patterns/abstract-factory)

- [Реализация на Java](https://refactoring.guru/ru/design-patterns/abstract-factory/java/example)

### `Builder (Строитель)`

Строитель - это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово.
Строитель дает возможность использовать один и тот же код строительства для получения разных представлений объектов.

#### `Проблема`

Представьте сложный объект, требующий кропотливой пошаговой инициализации множества полей и вложенных объектов.
Код инициализации таких объектов обычно спрятан внутри монструозного конструктора с десятком параметров.
Либо ещё хуже — распылен по всему клиентскому коду.

#### `Решение`

Паттерн предлагает разбить процесс конструирования объекта на отдельные шаги (например, `построитьСтены`, `вставитьДвери` и другие).
Чтобы создать объект, вам нужно поочередно вызывать методы строителя.
Причем не нужно запускать все шаги, а только те, что нужны для производства объекта определенной конфигурации.

Зачастую один и тот же шаг строительства может отличаться для разных вариаций производимых объектов.
Например, деревянный дом потребует строительства стен из дерева, а каменный — из камня.

В этом случае вы можете создать несколько классов строителей, выполняющих одни и те же шаги по-разному.
Используя этих строителей в одном и том же строительном процессе, вы сможете получать на выходе различные объекты.

#### `Структура`

![Alt text](https://refactoring.guru/images/patterns/diagrams/builder/example-ru-2x.png)

Автомобиль — это сложный объект, который может быть сконфигурирован сотней разных способов.
Вместо того, чтобы настраивать автомобиль через конструктор, мы вынесем его сборку в отдельный класс-строитель,
предусмотрев методы для конфигурации всех частей автомобиля.

Клиент может собирать автомобили, работая со строителем напрямую. Но, с другой стороны, он может поручить это дело директору.
Это объект, который знает, какие шаги строителя нужно вызвать, чтобы получить несколько самых популярных конфигураций автомобилей.

#### `Применимость`

- Когда вы хотите избавиться от «телескопического конструктора».
- Когда ваш код должен создавать разные представления какого-то объекта. Например, деревянные и железобетонные дома.
- Когда вам нужно собирать сложные составные объекты, например, деревья Компоновщика.

#### `Источники`

- [Подробнее о паттерне на refactoring.guru](https://refactoring.guru/ru/design-patterns/builder)

- [Реализация на Java](https://refactoring.guru/ru/design-patterns/builder/java/example)
### `Factory method (Фабричный метод)`

Фабричный метод — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе,
позволяя подклассам изменять тип создаваемых объектов.

#### `Проблема`

Представьте, что вы создаете программу управления грузовыми перевозками. Сначала вы рассчитываете перевозить товары только на автомобилях.
Поэтому весь ваш код работает с объектами класса `Грузовик`. Большая часть существующего кода жёстко привязана к классам `Грузовиков`.
Чтобы добавить в программу классы морских `Судов`, понадобится перелопатить всю программу. Более того, если вы потом решите
добавить в программу еще один вид транспорта, то всю эту работу придется повторить.

В итоге вы получите ужасающий код, наполненный условными операторами, которые выполняют то или иное действие, в зависимости от класса транспорта.

#### `Решение`

Паттерн Фабричный метод предлагает создавать объекты не напрямую, используя оператор `new`, а через вызов особого фабричного метода.

![Alt text](https://refactoring.guru/images/patterns/diagrams/factory-method/solution1-2x.png)

#### `Структура`

Чтобы эта система заработала, все возвращаемые объекты должны иметь общий интерфейс. Подклассы смогут производить объекты
различных классов, следующих одному и тому же интерфейсу.

![Alt text](https://refactoring.guru/images/patterns/diagrams/factory-method/solution2-ru-2x.png)

Для клиента фабричного метода нет разницы между этими объектами, так как он будет трактовать их как некий абстрактный Транспорт.
Для него будет важно, чтобы объект имел метод доставить, а как конкретно он работает — не важно.

Пример c диалоговыми окнами:

![Alt text](https://refactoring.guru/images/patterns/diagrams/factory-method/example-2x.png)

#### `Применимость`

- Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код.
- Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки.
- Когда вы хотите сэкономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых.


#### `Источники`

- [Подробнее о паттерне на refactoring.guru](https://refactoring.guru/ru/design-patterns/factory-method)

- [Реализация на Java](https://refactoring.guru/ru/design-patterns/factory-method/java/example)

### `Prototype (Прототип)`

Прототип — это порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их реализации.

Прототип — позволяет создавать новые объекты путем клонирования уже существующих. По сути данный паттерн предлагает технику клонирования объектов.

#### `Проблема`

У вас есть объект, который нужно скопировать. Как это сделать? Нужно создать пустой объект такого же класса,
а затем поочерёдно скопировать значения всех полей из старого объекта в новый.

Прекрасно! Но есть нюанс. Не каждый объект удастся скопировать таким образом, ведь часть его состояния может быть приватной,
а значит — недоступной для остального кода программы.

![Alt text](https://refactoring.guru/images/patterns/content/prototype/prototype-comic-1-ru-2x.png)

#### `Решение`

Паттерн Прототип поручает создание копий самим копируемым объектам. Он вводит общий интерфейс для всех объектов, поддерживающих клонирование.
Это позволяет копировать объекты, не привязываясь к их конкретным классам. Обычно такой интерфейс имеет всего один метод `clone`.

#### `Реализация`

Реализация этого метода в разных классах очень схожа. Метод создаёт новый объект текущего класса и копирует в него значения всех полей собственного объекта.

Объект, который копируют, называется **прототипом** (откуда и название паттерна).
Когда объекты программы содержат сотни полей и тысячи возможных конфигураций, прототипы могут служить своеобразной альтернативой созданию подклассов.

В этом случае все возможные прототипы заготавливаются и настраиваются на этапе инициализации программы.
Потом, когда программе нужен новый объект, она создаёт копию из приготовленного прототипа.

#### `Структура`

![Alt text](https://refactoring.guru/images/patterns/diagrams/prototype/example-2x.png)

#### `Применимость`

- Когда ваш код не должен зависеть от классов копируемых объектов.
- Когда вы имеете уйму подклассов, которые отличаются начальными значениями полей. Кто-то мог создать все эти классы,
  чтобы иметь возможность легко порождать объекты с определённой конфигурацией.

#### `Источники`

- [Подробнее о паттерне на refactoring.guru](https://refactoring.guru/ru/design-patterns/prototype)

- [Реализация на Java](https://refactoring.guru/ru/design-patterns/prototype/java/example)

### `Singleton (Одиночка)`

Одиночка — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр,
и предоставляет к нему глобальную точку доступа.

#### `Проблема`

Практически в любом приложении возникает необходимость в глобальных переменных или объектах с ограниченным числом экземпляров.
Самый простой способ решить эту задачу — создать глобальный объект, который будет доступен из любой точки приложения.

#### `Решение`

Все реализации одиночки сводятся к тому, чтобы скрыть конструктор по умолчанию и создать публичный статический метод,
который и будет контролировать жизненный цикл объекта-одиночки.

Если у вас есть доступ к классу одиночки, значит, будет доступ и к этому статическому методу.
Из какой точки кода вы бы его ни вызвали, он всегда будет отдавать один и тот же объект.

#### `Структура`

![Alt text](https://refactoring.guru/images/patterns/diagrams/singleton/structure-ru-2x.png)

#### `Применимость`

- Когда в программе должен быть единственный экземпляр какого-то класса, доступный всем клиентам
  (например, общий доступ к базе данных из разных частей программы).
- Когда вам хочется иметь больше контроля над глобальными переменными.

#### `Источники`

- [Подробнее о паттерне на refactoring.guru](https://refactoring.guru/ru/design-patterns/singleton)

- [Реализация на Java](https://refactoring.guru/ru/design-patterns/singleton/java/example)

- [Паттерн Singleton](https://bool.dev/blog/detail/pattern-singleton)

## Structural patterns
### `Adapter (Адаптер)`

Адаптер — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.

![Alt text](https://refactoring.guru/images/patterns/content/adapter/adapter-en-2x.png)

#### `Проблема`

Представьте, что вы делаете приложение для торговли на бирже. Ваше приложение скачивает биржевые котировки из нескольких
источников в XML, а затем рисует красивые графики.

В какой-то момент вы решаете улучшить приложение, применив стороннюю библиотеку аналитики. Но вот беда — библиотека
поддерживает только формат данных JSON, несовместимый с вашим приложением.

#### `Решение`

Вы можете создать адаптер. Это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид,
чтобы он стал понятен другому объекту.

При этом адаптер оборачивает один из объектов, так что другой объект даже не знает о наличии первого. Например,
вы можете обернуть объект, работающий в метрах, адаптером, который бы конвертировал данные в футы.

Таким образом, в приложении биржевых котировок вы могли бы создать класс XML_To_JSON_Adapter, который бы оборачивал
объект того или иного класса библиотеки аналитики. Ваш код посылал бы адаптеру запросы в формате XML, а адаптер сначала
транслировал входящие данные в формат JSON, а затем передавал бы их методам обёрнутого объекта аналитики.

#### `Пример`

Когда вы в первый раз летите за границу, вас может ждать сюрприз при попытке зарядить ноутбук.
Стандарты розеток в разных странах отличаются.
Ваша европейская зарядка будет бесполезна в США без специального адаптера, позволяющего подключиться к розетке другого типа.

#### `Структура`

Пример адаптации квадратных колышков и круглых отверстий.

![Alt text](https://refactoring.guru/images/patterns/diagrams/adapter/example-2x.png)

#### `Применимость`

- Когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения.
- Когда вам нужно использовать несколько существующих подклассов, но в них не хватает какой-то общей функциональности,
  причём расширить суперкласс вы не можете.

#### `Источники`

- [Подробнее о паттерне на refactoring.guru](https://refactoring.guru/ru/design-patterns/adapter)

- [Реализация на Java](https://refactoring.guru/ru/design-patterns/adapter/java/example)

### `Bridge (Мост)`

Мост — это структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные иерархии —
абстракцию и реализацию, позволяя изменять их независимо друг от друга.

#### `Проблема`

**Описание 1**: У вас есть класс геометрических `Фигур`, который имеет подклассы `Круг` и `Квадрат`. Вы хотите расширить иерархию фигур по цвету,
то есть иметь `Красные` и `Синие` фигуры.
Но чтобы всё это объединить, вам придётся создать 4 комбинации подклассов, вроде `СиниеКруги` и `КрасныеКвадраты`.

![Alt text](https://refactoring.guru/images/patterns/diagrams/bridge/problem-ru-2x.png)

Корень проблемы заключается в том, что мы пытаемся расширить классы фигур сразу в двух независимых плоскостях — по виду и по цвету.
Именно это приводит к разрастанию дерева классов.

**Описание 2**: Требуется отделить абстракцию от реализации так, чтобы и то и другое можно было изменять независимо.
При использовании наследования реализация жестко привязывается к абстракции, что затрудняет независимую модификацию.

#### `Решение`

**Решение 1**: Паттерн Мост предлагает `заменить наследование агрегацией или композицией`.

Мы можем сделать Цвет отдельным классом с подклассами `Красный` и `Синий`. Класс `Фигур` получит ссылку на объект `Цвета`
и сможет делегировать ему работу, если потребуется.
Такая связь и станет `мостом` между `Фигурами` и `Цветом`.
При добавлении новых классов цветов не потребуется трогать классы фигур и наоборот.

**Решение 2**: Поместить абстракцию и реализацию в отдельные иерархии классов.

#### `Пример`

Пример с отчетами. Есть абстрактный `Report`. У него есть наследники `YearlyReport`, `WeeklyReport` ...
Каждый из них нужно напечатать в трех форматах: `doc`, `xml`, `pdf`.

Мы же не будем делать все эти отчеты в разных форматах в виде разных классов: `YealyReportXml`, `YearlyReportDoc` ...
Будет правильным вынести отдельный класс `Format`. С наследниками: `DocFormat`, `XmlFormat`, `PdfFormat`.
И затем в классе `Report` появится ссылка на класс `Format`.

#### `Структура`

Пример разделения двух иерархий классов — приборов и пультов управления.

![Alt text](https://refactoring.guru/images/patterns/diagrams/bridge/example-ru-2x.png)

#### `Применимость`

- Когда вы хотите разделить монолитный класс, который содержит несколько различных реализаций какой-то функциональности
  (например, если класс может работать с разными поставщиками похожего API: cloud-сервисы, социальные сети, базы данных)
- Когда класс нужно расширять в двух независимых плоскостях.
- Когда вы хотите, чтобы реализацию можно было бы изменять во время выполнения программы.

#### `Источники`

- [Подробнее о паттерне на refactoring.guru](https://refactoring.guru/ru/design-patterns/bridge)

- [Реализация на Java](https://refactoring.guru/ru/design-patterns/bridge/java/example)

- [Паттерн Bridge](https://bool.dev/blog/detail/strukturnye-patterny-most-csharp)

- [Сергей Немчинский о паттерне Bridge](https://youtu.be/oDM-lKXuQ1g?t=969) (Видео)
### `Компоновщик (Composite)`

Компоновщик — это структурный паттерн проектирования, который позволяет сгруппировать множество объектов в древовидную
структуру, а затем работать с ней так, как будто это единичный объект.

#### `Проблема`

Паттерн Компоновщик имеет смысл только тогда, когда основная модель вашей программы может быть структурирована в виде дерева.

Например, есть два объекта: `Продукт` и `Коробка`. `Коробка` может содержать несколько `Продуктов` и других `Коробок` поменьше.
Те, в свою очередь, тоже содержат либо `Продукты`, либо `Коробки` и так далее.

Теперь предположим, ваши `Продукты` и `Коробки` могут быть частью заказов.
Каждый заказ может содержать как простые `Продукты` без упаковки, так и составные `Коробки`.
Ваша задача состоит в том, чтобы узнать цену всего заказа.

![Alt text](https://refactoring.guru/images/patterns/diagrams/composite/problem-ru-2x.png)

#### `Решение`

Компоновщик предлагает рассматривать `Продукт` и `Коробку` через единый интерфейс с общим методом получения стоимости.

`Продукт` просто вернёт свою цену. `Коробка` спросит цену каждого предмета внутри себя и вернёт сумму результатов.

#### `Структура`

![Alt text](https://refactoring.guru/images/patterns/diagrams/composite/example-2x.png)

#### `Применимость`

- Когда вам нужно представить древовидную структуру объектов.
- Когда клиенты должны единообразно трактовать простые и составные объекты.

#### `Источники`

- [Подробнее о паттерне на refactoring.guru](https://refactoring.guru/ru/design-patterns/composite)

- [Реализация на Java](https://refactoring.guru/ru/design-patterns/composite/java/example)
### `Декоратор / Обёртка (Decorator / Wrapper)`

Декоратор — это структурный паттерн проектирования, который позволяет динамически добавлять объектам
новую функциональность, оборачивая их в полезные «обёртки»

#### `Проблема`

Основой библиотеки является класс `Notifier` с методом `send`, который принимает на вход строку-сообщение и
высылает её всем администраторам по электронной почте.

В какой-то момент стало понятно, что одних email-оповещений пользователям мало. Некоторые из них хотели бы получать
извещения о критических проблемах через `SMS`. Другие хотели бы получать их в виде сообщений `Facebook`.
Корпоративные пользователи хотели бы видеть сообщения в `Slack`. Поэтому мы унаследовались от базового класса `Notifier`
и создали `FacebookNotifier`, `SmsNotifier` и `SlackNotifier`.

Но затем кто-то резонно спросил, почему нельзя выбрать несколько типов оповещений сразу?

Вы попытались реализовать все возможные комбинации подклассов оповещений. Но после того как вы добавили первый десяток
классов, стало ясно, что такой подход невероятно раздувает код программы.

#### `Решение`

Одним из способов обойти эти проблемы является замена наследования агрегацией либо композицией.
Это когда один объект содержит ссылку на другой и делегирует ему работу, вместо того чтобы самому наследовать его поведение.

Декоратор имеет альтернативное название — обёртка. Оно более точно описывает суть паттерна:
вы помещаете целевой объект в другой объект-обёртку, который запускает базовое поведение объекта,
а затем добавляет к результату что-то своё.

Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы,
с каким объектом работать — чистым или обёрнутым.

#### `Структура`

Приложение оборачивает класс данных в шифрующую и сжимающую обёртки, которые при чтении выдают оригинальные данные,
а при записи — зашифрованные и сжатые.

Декораторы, как и сам класс данных, имеют общий интерфейс.
Поэтому клиентскому коду не важно, с чем работать — c «чистым» объектом данных или с «обёрнутым».

![Alt text](https://refactoring.guru/images/patterns/diagrams/decorator/example-2x.png)

#### `Признаки`

Признаки применения паттерна: Декоратор можно распознать по создающим методам,
которые принимают в параметрах объекты того же абстрактного типа или интерфейса, что и текущий класс.

#### `Применимость`

- Когда вам нужно добавлять обязанности объектам на лету, незаметно для кода, который их использует.
- Когда нельзя расширить обязанности объекта с помощью наследования.

#### `Источники`

- [Подробнее о паттерне на refactoring.guru](https://refactoring.guru/ru/design-patterns/decorator)

- [Реализация на Java](https://refactoring.guru/ru/design-patterns/decorator/java/example)

### `Facade (Фасад)`

Фасад — это структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов,
библиотеке или фреймворку.

#### `Проблема`

Вашему коду приходится работать с большим количеством объектов некой сложной библиотеки или фреймворка.
Вы должны самостоятельно инициализировать эти объекты, следить за правильным порядком зависимостей и так далее.

В результате бизнес-логика ваших классов тесно переплетается с деталями реализации сторонних классов.
Такой код довольно сложно понимать и поддерживать.

#### `Решение`

Фасад — это простой интерфейс для работы со сложной подсистемой, содержащей множество классов.
Фасад может иметь урезанный интерфейс, не имеющий 100% функциональности, которой можно достичь, используя сложную
подсистему напрямую. Но он предоставляет именно те фичи, которые нужны клиенту, и скрывает все остальные.

#### `Структура`

![Alt text](https://refactoring.guru/images/patterns/diagrams/facade/example-2x.png)

#### `Применимость`

- Когда вам нужно представить простой или урезанный интерфейс к сложной подсистеме.
- Когда вы хотите разложить подсистему на отдельные слои.

#### `Источники`

- [Подробнее о паттерне на refactoring.guru](https://refactoring.guru/ru/design-patterns/composite)

- [Реализация на Java](https://refactoring.guru/ru/design-patterns/composite/java/example)

### `Flyweight (Легковес)`

Легковес — это структурный паттерн проектирования, который позволяет вместить бóльшее количество объектов
в отведённую оперативную память. Легковес экономит память, разделяя общее состояние объектов между собой,
вместо хранения одинаковых данных в каждом объекте.

#### `Проблема`

Мы решили создать игру, с огромным количеством игровых объектов. На слабых компьютерах в активных игровых моментах
создается очень много объектов, которые не помещаются в оперативную память. Игра вылетает.

#### `Решение`

Паттерн Легковес предлагает не хранить в классе внешнее состояние, а передавать его в те или иные методы через параметры.
Таким образом, одни и те же объекты можно будет повторно использовать в различных контекстах.
Но главное — понадобится гораздо меньше объектов, ведь теперь они будут отличаться только внутренним состоянием,
а оно имеет не так много вариаций.



#### `Структура`

![Alt text](https://refactoring.guru/images/patterns/diagrams/flyweight/example-2x.png)

#### `Применимость`

- в приложении используется большое число объектов, из-за этого высоки расходы оперативной памяти;
- большую часть состояния объектов можно вынести за пределы их классов;
- большие группы объектов можно заменить относительно небольшим количеством разделяемых объектов,
  поскольку внешнее состояние вынесено.

#### `Источники`

- [Подробнее о паттерне на refactoring.guru](https://refactoring.guru/ru/design-patterns/composite)

- [Реализация на Java](https://refactoring.guru/ru/design-patterns/composite/java/example)

### `Proxy (Прокси / Заместитель)`

Заместитель — это структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов
специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до
или после передачи вызова оригиналу.

#### `Проблема`

Рассмотрим такой пример: у вас есть внешний ресурсоёмкий объект, который нужен не все время, а изредка.
Мы могли бы создавать этот объект не в самом начале программы, а только тогда, когда он кому-то реально понадобится.
Каждый клиент объекта получил бы некий код отложенной инициализации.
Но, вероятно, это привело бы к множественному дублированию кода.

В идеале, этот код хотелось бы поместить прямо в служебный класс, но это не всегда возможно.
Например, код класса может находиться в закрытой сторонней библиотеке

#### `Решение`

Паттерн Заместитель предлагает создать новый класс-дублёр, имеющий тот же интерфейс, что и оригинальный служебный объект.
При получении запроса от клиента объект-заместитель сам бы создавал экземпляр служебного объекта
и переадресовывал бы ему всю реальную работу.

Благодаря одинаковому интерфейсу, объект-заместитель можно передать в любой код, ожидающий сервисный объект.

#### `Структура`

В этом примере Заместитель помогает добавить в программу механизм ленивой инициализации и кеширования
результатов работы библиотеки интеграции с YouTube.

![Alt text](https://refactoring.guru/images/patterns/diagrams/proxy/example-2x.png)

Оригинальный объект начинал загрузку по сети, даже если пользователь запрашивал одно и то же видео.
Заместитель же загружает видео только один раз, используя для этого служебный объект, но в остальных случаях
возвращает закешированный файл.

#### `Применимость`

- Ленивая инициализация (виртуальный прокси). Когда у вас есть тяжёлый объект, грузящий данные из файловой системы или базы данных.
- Защита доступа (защищающий прокси). Когда в программе есть разные типы пользователей,
  и вам хочется защищать объект от неавторизованного доступа.
  Например, если ваши объекты — это важная часть операционной системы,
  а пользователи — сторонние программы (хорошие или вредоносные).
- Локальный запуск сервиса (удалённый прокси). Когда настоящий сервисный объект находится на удалённом сервере.
- Логирование запросов (логирующий прокси). Когда требуется хранить историю обращений к сервисному объекту.
- Кеширование объектов («умная» ссылка). Когда нужно кешировать результаты запросов клиентов и управлять их жизненным циклом.

#### `Источники`

- [Подробнее о паттерне на refactoring.guru](https://refactoring.guru/ru/design-patterns/proxy)

- [Реализация на Java](https://refactoring.guru/ru/design-patterns/proxy/java/example)