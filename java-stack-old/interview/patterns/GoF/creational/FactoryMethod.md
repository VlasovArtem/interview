<!-- TOC -->
  * [`Factory method (Фабричный метод)`](#factory-method-фабричный-метод)
    * [`Проблема`](#проблема)
    * [`Решение`](#решение)
    * [`Структура`](#структура)
    * [`Применимость`](#применимость)
    * [`Источники`](#источники)
<!-- TOC -->

## `Factory method (Фабричный метод)`

Фабричный метод — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, 
позволяя подклассам изменять тип создаваемых объектов.

### `Проблема`

Представьте, что вы создаете программу управления грузовыми перевозками. Сначала вы рассчитываете перевозить товары только на автомобилях. 
Поэтому весь ваш код работает с объектами класса `Грузовик`. Большая часть существующего кода жёстко привязана к классам `Грузовиков`. 
Чтобы добавить в программу классы морских `Судов`, понадобится перелопатить всю программу. Более того, если вы потом решите 
добавить в программу еще один вид транспорта, то всю эту работу придется повторить.

В итоге вы получите ужасающий код, наполненный условными операторами, которые выполняют то или иное действие, в зависимости от класса транспорта.

### `Решение`

Паттерн Фабричный метод предлагает создавать объекты не напрямую, используя оператор `new`, а через вызов особого фабричного метода. 

![Alt text](https://refactoring.guru/images/patterns/diagrams/factory-method/solution1-2x.png)

### `Структура`

Чтобы эта система заработала, все возвращаемые объекты должны иметь общий интерфейс. Подклассы смогут производить объекты 
различных классов, следующих одному и тому же интерфейсу.

![Alt text](https://refactoring.guru/images/patterns/diagrams/factory-method/solution2-ru-2x.png)

Для клиента фабричного метода нет разницы между этими объектами, так как он будет трактовать их как некий абстрактный Транспорт. 
Для него будет важно, чтобы объект имел метод доставить, а как конкретно он работает — не важно.

Пример c диалоговыми окнами:

![Alt text](https://refactoring.guru/images/patterns/diagrams/factory-method/example-2x.png)

### `Применимость`
 
- Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код.
- Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки.
- Когда вы хотите сэкономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых.


### `Источники`

- [Подробнее о паттерне на refactoring.guru](https://refactoring.guru/ru/design-patterns/factory-method)

- [Реализация на Java](https://refactoring.guru/ru/design-patterns/factory-method/java/example)