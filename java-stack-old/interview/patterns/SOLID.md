<!-- TOC -->
* [SOLID](#solid)
  * [SRP - Single responsibility principle](#srp---single-responsibility-principle)
  * [OCP - Open closed principle](#ocp---open-closed-principle)
  * [LSP - Liskov substitution principle](#lsp---liskov-substitution-principle)
  * [ISP - Interface segregation principle](#isp---interface-segregation-principle)
  * [DIP - Dependency inversion principle](#dip---dependency-inversion-principle)
* [Три ключевых принципа ПО, которые вы должны понимать](#три-ключевых-принципа-по-которые-вы-должны-понимать)
  * [DRY - Don’t repeat yourself](#dry---dont-repeat-yourself)
  * [KISS - Keep it simple, stupid](#kiss---keep-it-simple-stupid)
  * [YAGNI - You aren’t gonna need it](#yagni---you-arent-gonna-need-it)
* [Полезные ссылки](#полезные-ссылки)
<!-- TOC -->

# SOLID

* **S - Single responsibility principle**
* **O - Open closed principle**
* **L - Liskov substitution principle**
* **I - Interface segregation principle**
* **D - Dependency inversion principle**

## SRP - Single responsibility principle

Каждый объект должен иметь только одну обязанность. И эта обязанность должна быть полностью инкапсулирована в класс.

Если у класса больше одной ответственности может возникнуть следующая проблема: к примеру есть класс `DateAndTemperatureInfoHolder`. Он содержит инфу о дате и 
о температуре. Когда кому-то другому понадобится наш код который относится только к дате или температуре, он может создать новый класс вырезав из нашего только 
то, что нужно - `DateInfoHolder` или `TemperatureInfoHolder`. В таком случае, если в нашем исходном `DateAndTemperatureInfoHolder` обнаружится баг, то этот баг 
будет и в коде, который скопирован в другой класс. Таким образом будет очень сложно поддерживать обновление этого кода и фикс багов в нём. По `SRP` нужно было 
изначально создать `DateInfoHolder` и `TemperatureInfoHolder` в виде отдельных реализаций.

## OCP - Open closed principle

Программные сущности (классы, функции, модули) должны быть открыты для расширения, но закрыты для изменения.

Если одно изменение в программе влечет за собой каскад изменений в зависимых модулях, то в программе проявляются нежелательные признаки «плохого» дизайна.
Бертран Мейер говорил: “необходимо проектировать модули, которые никогда не меняются. Когда требования меняются, нужно расширять поведение таких модулей путем 
добавления нового кода, а не изменением старого, уже работающего кода”.

Модули, отвечающие принципу открытости-закрытости, имеют два главных признака:
- Открыты для расширения. Это означает, что поведение модуля может быть расширено. То есть мы можем добавить модулю новое поведение в соответствии с 
изменившимися требованиями к приложению или для удовлетворения нужд новых приложений.
- Закрыты для изменений. Исходный код такого модуля неприкасаем. Никто не вправе вносить в него изменения.

**Ключ к решению - Абстракции**

Это абстрактные базовые классы, а неограниченный набор возможных поведений представлен всеми возможными классами-наследниками. Модуль может манипулировать 
абстракцией. Такой модуль закрыт для изменений, так как он зависит от фиксированной абстракции. Также поведение модуля может быть расширено созданием новых 
наследников абстракции.

**Пример с ошибкой**

```
enum ShapeType {circle, square}

struct Shape { ShapeType itsType; };
struct Circle{
    ShapeType itsType;
    double itsRadius;
    Point itsCenter;
};

struct Square {
    ShapeType itsType;
    double itsSide;
    Point itsTopLeft;
};

//
// реализованы в другом месте
//
void DrawSquare(struct Square*)
void DrawCircle(struct Circle*);
typedef struct Shape *ShapePointer;

void DrawAllShapes(ShapePointer list[], int n) {
    int i;
    for (i=0; i<n; i++) {
        struct Shape* s = list[i];
        switch (s->itsType) {
            case square:
            DrawSquare((struct Square*)s);
            break;
            case circle:
            DrawCircle((struct Circle*)s);
            break;
        }
    }
}
```

**Правильный пример**
```
class Shape {
public:
    virtual void Draw() const = 0;
};
class Square : public Shape {
public:
    virtual void Draw() const;
};
class Circle : public Shape {
public:
    virtual void Draw() const;
};

void DrawAllShapes(Set<Shape*>& list){
    for (Iterator<Shape*>i(list); i; i++)
        (*i)->Draw();
}
```

Клиентский код должен зависеть от интерфейса, который неизменный. Это делается для того, чтобы не пришлось переписывать клиентский код.

## LSP - Liskov substitution principle

Если функция принимает класс `A` (или часть кода работает с классом `А`), то передав в эту функцию наследника класса `А` всё должно работать как и прежде. То 
есть не должно быть вообще никаких проблем при работе с наследниками.

## ISP - Interface segregation principle

Клиенты не должны зависеть от методов, которые они не используют. 

Есть интерфейс `IFacade` с 10 методами и класс `Facade`, который его реализует. Также есть несколько клиентов, которые работают с фасадом. Например, первому 
клиенту нужны только 1, 2 и 3 методы фасада. Второму клиенту оставшиеся 7 методов. В итоге получается, что у клиента есть доступ к функционалу, который он не 
должен иметь. 

Также есть проблема в том, что если меняется сигнатура одного из методов, то нам нужно перекомпилировать все клиенты, вместо того, чтобы перекомпилировать 
только тот, который использует этот метод. Принцип помогает снизить сложность поддержки кода. 

## DIP - Dependency inversion principle

Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Главная идея принципа - использовать все классы через интерфейсы.

Пример: Клиент - Сервер. Когда используем сервер напрямую и хотим добавить в него новый функционал (к примеру авторизация) или расширить сигнатуру методов, то 
это всё влияет на взаимодействие с клиентом. Если бы мы работали через интерфейс, мы могли бы сделать условный прокси, который бы и реализовывал блок 
авторизации нашего примера. При этом интерфейс бы не поменялся.

# Три ключевых принципа ПО, которые вы должны понимать

## DRY - Don’t repeat yourself


## KISS - Keep it simple, stupid

Как-то я принимал участие в проекте, где клиент хотел импортировать `Excel` таблицы в свою программу по управлению персоналом. Хороший пример. `Excel` является 
проприетарным приложением, со сложным форматом. Формат документов сложен, т.к. реализует богатый функционал – к примеру, в него можно добавлять графики и 
другие фишки, которые по сути, не нужны были клиенту. Ему нужны были просто числа из таблицы. Таким образом, внедряя импорт из `Excel`, пришлось бы потратить 
много времени на ненужный функционал. В добавок, существует несколько версий `Excel`, которых с каждым годом все больше и больше. Т.е. всем этим было бы сложно 
управлять, и были риски дополнительных затрат в будущем.

И мы решили внедрить импорт из формата `CSV`. Решение заняло несколько строк кода, не было перегружено данными (если сравнивать форматы `CSV` и `Excel`), легко 
управлялось и поддерживалось. `Excel` запросто может экспортировать данные в формате `CSV` (как и многие другие программы, которыми клиент мог воспользоваться 
в будущем). И, учитывая минимальные затраты на реализацию этого требования, данное решение является отличным примером `KISS`.

Мораль – старайтесь рассмотреть вещи с простой стороны, если они выглядят сложными. Если клиент вам рассказывает свои требования, реализация которых вам 
кажется сложной, вы правы в любом случае. Даже учитывая, что некоторые вещи действительно сложны в реализации, мы нередко сталкиваемся с решениями, которые 
перегружены необоснованно. Это случается, т.к. в процесс разработки вовлечены некоторые люди, не имеющие технического опыта для правильного расчета затраты/
выгода. И они просто не видят всей проблемы. Поэтому всегда дважды проверяйте требования клиента, и убедитесь, что это именно то, что ему нужно. Обсудите 
критические моменты, объясните ему, почему другие решения могут подойти лучше.

## YAGNI - You aren’t gonna need it

Вам это не понадобится. К примеру, достаточно часто доступ к `БД` осуществляется через абстракцию, которая может иметь реализацию для разных драйверов – 
`MySQL`, `PostgreSQL`, `Oracle`. Если вы работаете над сайтом, который размещается на `LAMP` стеке – какова вероятность того, что клиент сменит `БД`? Не 
забывайте, что концепт всегда пишется под бюджет – верно?

Если в бюджете не предусмотрена абстракция для `БД` – этой абстракции не должно быть в системе. Если вдруг клиенту понадобится переехать на другую `БД`, 
довольно очевидно, что это повлечет затраты на изменение системы.

# Полезные ссылки

* [SOLID принципы: SRP (Принцип единственной ответственности, Single Responsibility Principle) - Youtube Немчинский](https://www.youtube.com/watch?v=O4uhPCEDzSo&ab_channel=SergeyNemchinskiy)
* [Принцип открытости-закрытости / Блог компании Tinkoff - habr](https://habr.com/ru/company/tinkoff/blog/472186/)
* [SOLID принципы: OCP (Открытости/закрытости (Open Closed Principle) - Youtube Немчинский](https://www.youtube.com/watch?v=x5OtQiKOG-Q&ab_channel=SergeyNemchinskiy)
* [SOLID: Принцип подстановки Барбары Лисков/ LSP (The Liskov Substitution Principle) - Youtube Немчинский](https://www.youtube.com/watch?v=NqvwYcjrwdw)
* [SOLID принципы: ISP (Принцип Разделения Интерфейса (The Interface Segregation Principle) - Youtube Немчинский](https://www.youtube.com/watch?v=d9RJqf2o_Sw)
* [SOLID принципы: DIP (Принцип инверсии зависимостей (The Dependency Inversion Principle) - Youtube Немчинский](https://www.youtube.com/watch?v=Bw6RvCSsETI&ab_channel=SergeyNemchinskiy)
* [Три ключевых принципа ПО, которые вы должны понимать - habr](https://habr.com/ru/post/144611/)
