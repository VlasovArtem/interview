<!-- TOC -->
* [@Transactional](#transactional)
  * [Параметры](#параметры)
    * [propagation](#propagation)
    * [isolation](#isolation)
    * [rollbackFor](#rollbackfor)
    * [noRollbackFor](#norollbackfor)
    * [readOnly](#readonly)
<!-- TOC -->

# @Transactional

Аннотация `@Transactional` в Spring Framework используется для указания того, что метод должен быть выполнен в транзакции базы данных. 

Это означает, что если метод выполняется успешно, все изменения, внесенные в базу данных в рамках этого метода, будут зафиксированы (commit). 

Если возникает исключение, все изменения откатываются (rollback).

Пример использования:

```java
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class MyService {

    @Transactional
    public void myTransactionalMethod() {
        // Ваш код здесь
    }
}
```

Основные преимущества использования `@Transactional`:

1. **Управление транзакциями**: Spring Framework автоматически управляет транзакциями, что позволяет разработчику сосредоточиться на бизнес-логике, а не на управлении транзакциями.

2. **Автоматический откат (rollback)**: Если во время выполнения метода происходит исключение, Spring откатывает все изменения базы данных, внесенные в рамках этого метода.

3. **Поддержка различных источников данных**: `@Transactional` работает с различными источниками данных, такими как JDBC, JPA, JMS, Hibernate и другими.

4. **Конфигурирование транзакций**: `@Transactional` позволяет настраивать параметры транзакции, такие как уровень изоляции, тайм-ауты транзакций и другие.

Примечание: `@Transactional` должна быть применена к методу, который вызывает операции базы данных. Если вы хотите, чтобы все публичные методы класса были транзакционными, можно аннотировать весь класс `@Transactional`.

## Параметры

### propagation

```java
@Transactional(propagation=Propagation.REQUIRED)
```

Если `propagation` не указан, то стратегия распространения по дефолту это `REQUIRED`.

- `REQUIRED`- Означает что целевой метод не может быть запущен без активной транзакции. Если транзакция уже стартовала до вызова этого метода, тогда методы 
выполнится в ней или иначе при вызове метода новая транзакция будет создана.
- `REQUIRES_NEW` - Означает что новая транзакция должна начинаться всякий раз, как целевой метод будет вызываться. Если уже есть начатая транзакция, то она будет 
приостановлена, до начала новой.
- `MANDATORY` - Означает что целевой метод требует активной транзакции для старта. Если ее нет, то выполнение не будет произведено, и выбросится исключение.
- `SUPPORTS` - Означает что целевой метод может быть исполнен вне транзакции. Если есть начатая транзакция, то метод запустится в ней. Если нет запущенной 
транзакции, то метод выполнится все равно, только не в транзакционом контексте. Методы, которые выполняют выборку данных наилучшие кандидаты для этой опции.
- `NOT_SUPPORTED` - Означает что целевой метод не требует транзакционного контекста для выполнения. Если есть начатая транзакция, то она будет приостановлена.
- `NEVER` - Означает что целевой метод выбросит исключение, если выполнится в транзакционном процессе. Не советую использовать эту опцию.

### isolation
Я уже писал про побочные эффекты, вызываемые параллельным исполнением запросов. Уровни изоляции транзакций можно рассматривать как механизм, позволяющий решать проблему параллельного доступа к данным и изменения данных без явных ручных блокировок.

Существует четыре уровня изоляции транзакций, в которых подобные побочные эффекты могут происходить, а могут и не происходить:

- `DEFAULT` - используется по умолчанию и представляет собой дефолтный уровень изоляции для используемой БД
- `SERIALIZABLE` - транзакции полностью изолируются друг от друга и ни одна транзакция ни коим образом не влияет на другие. Самая низкая степень параллельности транзакций.
- `REPEATABLE_READ` - изменения данных, которые были прочитаны в транзакции ранее в транзакцию не попадают, другие транзакции не могут изменять данные, прочитанные этой транзакцией. Возможен эффект фантомного чтения, степерь параллельности транзакций выше, чем у Serializable.
- `READ_COMMITTED` - транзакции получают изменения в данных от других транзакций, которые были успешно подтверждены. Возможны эффекты фантомного чтения и неповторяемого чтения. Этот уровень изоляции обычно используется по умолчанию в базах данных и обеспечивает хорошую степень параллельности транзакций.
- `READ_UNCOMMITTED` - самый низший уровень изоляции транзакций, который гарантирует только, что изменения, внёсённые одной транзакцией, не будут перезаписаные другой транзакцией. Подвержден всем эффектам влияния транзакций друг на друга. Обеспечивает наивысшую степерь параллельности транзакций.

В Spring эти уровни представлены в виде enum `Isolation`, члены которого передаются в аннотацию `@Transactional`:

```java
@Transactional(isolation = Isolation.SERIALIZABLE)
```

### rollbackFor

```java
@Transactional(rollbackFor=Exception.class)
```

По умолчанию откат происходит при `rollbackFor=RunTimeException.class`

В спринге, все `API` классы выбрасывают `RuntimeException`, что означает что если любой метод упал, то контейнер всегда произведет откат текущей транзакции.
Проблема только с `checked exceptions`. Так что данная опция может использоваться для декларативного отката транзакции если выбросится `Checked Exception`.

### noRollbackFor

```java
@Transactional(noRollbackFor=IllegalStateException.class)
```

Означает что откат не должен происходить если целевой метод выбросил это исключение.

### readOnly

```java
@Transactional(readOnly = true)
```

Логический флаг, которому может быть присвоено значение `true`, если транзакция фактически доступна только для чтения, что позволяет проводить соответствующие оптимизации во время выполнения. По умолчанию `false`.

Это просто подсказка для реальной подсистемы транзакцийи совсем не обязательно приведет к сбою попыток доступа для записи. 

Менеджер транзакций, который не может интерпретировать подсказку `readOnly`, не будет генерировать исключение при запросе транзакции только для чтения, а скорее просто проигнорирует её.