# Software Architecture Patterns
1. **Layered Architecture**: This is a traditional architecture style that organizes the system into a series of layers, each with a specific role and responsibility. Each layer provides services to the layer above it and acts as a client to the layer below. Common layers include presentation, business logic, and data access layers. This architecture is easy to understand and can simplify development and maintenance, but it can also introduce performance overhead and limit flexibility due to its strict layering rules.

2. **Event-Driven Architecture**: This architecture style is based on events, which are discrete pieces of information that describe a state change in the system. Components in an event-driven architecture communicate by producing and consuming events, which are handled asynchronously. This architecture can provide high scalability and loose coupling between components, but it can also be complex to design and manage due to the asynchronous and distributed nature of events.

3. **Microkernel Architecture**: This architecture style separates a minimal functional core (the microkernel) from extended functionality and customer-specific parts. The microkernel contains the minimal functionality required to run the system, while other features are implemented as plugins that interact with the microkernel. This architecture can provide high flexibility and adaptability, but it can also be complex to design due to the need to define a clear and minimal microkernel.

4. **Space-Based Architecture**: This architecture style is designed to avoid any single point of failure or contention, allowing the system to scale linearly and handle large, fluctuating loads. It's often used in high-volume, distributed systems and involves partitioning the data and processing across multiple nodes, with each node operating independently and in parallel with the others. This architecture can provide high scalability and performance, but it can also be complex to design and manage due to its distributed nature.
# Questions
1. What is layered architecture and its usecases and properties (in terms of testability, easy of deployment, performance, scalability and easy of development)?
2. What is event-driven architecture and its usecases?
3. What is mediator topology (in the event-drive architecture)? Analyze it in terms of testability, easy of deployment, performance, scalability and easy of development.
4. What is broker topology (in the event-drive architecture)? Analyze it in terms of testability, easy of deployment, performance, scalability and easy of development.
5. What is microkernel architecture and its usecases and properties (in terms of testability, easy of deployment, performance, scalability and easy of development)?
6. What is space-based architecture and its usecases and properties (in terms of testability, easy of deployment, performance, scalability and easy of development)?
# Answers
1. Layered Architecture: This is a traditional architecture style that organizes the system into a series of layers, each with a specific role and responsibility. Each layer provides services to the layer above it and acts as a client to the layer below. Common layers include presentation, business logic, and data access layers. This architecture is easy to understand and can simplify development and maintenance. However, it can also introduce performance overhead due to the need for each request to pass through multiple layers. It can be scalable if each layer is deployed on separate servers. Testability can be achieved by testing each layer independently. Deployment is also straightforward as each layer can be deployed separately.

2. Event-Driven Architecture: This architecture style is based on events, which are discrete pieces of information that describe a state change in the system. Components in an event-driven architecture communicate by producing and consuming events, which are handled asynchronously. This architecture can provide high scalability and loose coupling between components, but it can also be complex to design and manage due to the asynchronous and distributed nature of events.

3. Mediator Topology in Event-Driven Architecture: In a mediator topology, all communication goes through a central mediator component. This mediator handles routing, orchestration, and possibly event transformation. This topology simplifies the components but puts more responsibility on the mediator. It can be easier to test and deploy as the mediator encapsulates the routing logic. However, the performance and scalability are limited by the capabilities of the mediator.

4. Broker Topology in Event-Driven Architecture: In a broker topology, the events are sent to a common message broker that other components subscribe to. The broker ensures that each event is delivered to all interested subscribers. This topology allows for greater scalability as the broker can distribute events across multiple subscribers. However, it can be more complex to test and deploy as the routing logic is distributed across the subscribers. Performance depends on the capabilities of the broker.

5. Microkernel Architecture: This architecture style separates a minimal functional core (the microkernel) from extended functionality and customer-specific parts. The microkernel contains the minimal functionality required to run the system, while other features are implemented as plugins that interact with the microkernel. This architecture can provide high flexibility and adaptability, but it can also be complex to design due to the need to define a clear and minimal microkernel. Testability, deployment, performance, and scalability all depend on how well the microkernel and plugins are designed and implemented.

6. Space-Based Architecture: This architecture style is designed to avoid any single point of failure or contention, allowing the system to scale linearly and handle large, fluctuating loads. It's often used in high-volume, distributed systems and involves partitioning the data and processing across multiple nodes, with each node operating independently and in parallel with the others. This architecture can provide high scalability and performance, but it can also be complex to design and manage due to its distributed nature. Testability and deployment can be challenging due to the distributed and parallel nature of the architecture.