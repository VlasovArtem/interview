<!-- TOC -->
* [GC](#gc)
  * [Оптимизация GC](#оптимизация-gc)
  * [Лучшие практики](#лучшие-практики)
  * [Пример](#пример)
  * [Заключение](#заключение)
<!-- TOC -->

# GC

Подход GoLang к сборке мусора разработан для простоты и эффективности, балансируя производительность и удобство для разработчика.

**Автоматическое управление памятью**: Runtime Go автоматически обрабатывает выделение и освобождение памяти. Это означает, что разработчикам не нужно вручную освобождать память, что снижает риск утечек памяти и сбоев сегментации.

**Конкурентный сборщик мусора** - Go использует конкурентный, трехцветный алгоритм mark-and-sweep. Это означает, что сборщик выполняет большинство своих задач без остановки программы, сокращая время пауз.

**Трехцветный алгоритм mark-and-sweep**: Современный Go использует форму трехцветного алгоритма mark-and-sweep для сборки мусора. Этот алгоритм работает в три фазы: маркировка, очистка и, по желанию, компактация.

- **Маркировка**: Определяет, какие объекты все еще доступны (используются).
- **Очистка**: Освобождает память, занятую недоступными объектами.
- **Компактация** (опционально): Компактирует память для устранения проблем с фрагментацией.

**Конкурентность и производительность**: GC в Go спроектирован так, чтобы быть конкурентным; он работает параллельно с другими горутинами. Эта конкурентность минимизирует время пауз, улучшая общую производительность приложения.

**Настройка GC**: Хотя GC в Go автоматический, его можно настроить для конкретных рабочих нагрузок с использованием переменных окружения (например, `GOGC`) для контроля агрессивности сборщика.

**Выделение памяти** - Сборщик мусора в Go оптимизирует выделение памяти с помощью техники, известной как escape-анализ. Он определяет, можно ли безопасно выделить переменную на стеке или она должна быть выделена в куче.

**Регулировка скорости работы GC** - Runtime регулирует скорость работы сборщика мусора в зависимости от объема выделенной памяти и времени, затраченного на предыдущий сбор, стремясь поддерживать низкую задержку и высокую пропускную способность.

## Оптимизация GC

**Конкурентная маркировка и очистка**

Современные версии Go используют конкурентный алгоритм mark-and-sweep, позволяя сборщику мусора работать одновременно с программой, сокращая время пауз.

**Записи барьеров**

Записи барьеров используются во время фазы маркировки. Они позволяют программе продолжать работу, отслеживая изменения, которые могут повлиять на набор живых объектов.

**Регулировка скорости сбора мусора**

Runtime Go динамически регулирует скорость работы сборщика мусора в зависимости от объема выделенной памяти и времени, затраченного на предыдущие циклы сбора.

**Компактация кучи**

Хотя сборщик мусора в Go не полностью компактизирует кучу, в последних версиях имеются оптимизации для снижения фрагментации, что улучшает эффективность использования памяти.

Эти аспекты среды выполнения Go, включая горутины, escape-анализ, механизмы кэширования и оптимизации сборки мусора, являются неотъемлемыми характеристиками производительности языка и предназначены для повышения эффективности и снижения ошибок при конкурентном программировании.

## Лучшие практики

- **Минимизируйте выделение на куче**: Где возможно, предпочтите выделение на стеке, ограничивая область и время жизни переменных.
- **Повторное использование объектов**: Повторное использование объектов может снизить нагрузку на сборщик мусора.
- **Избегайте финализаторов**: Финализаторы могут усложнить сборку мусора и лучше избегать их, если это не абсолютно необходимо.
- **Профилируйте ваше приложение**: Используйте встроенные инструменты профилирования Go, чтобы понять использование памяти и поведение сборки мусора в вашем приложении.

## Пример

```go
package main

import (
    "fmt"
    "runtime"
)

func main() {
    printMemStats("Изначально")

    for i := 0; i < 10; i++ {
        _ = make([]byte, 1<<20) // Выделение 1 МиБ
    }

    printMemStats("После выделения")

    runtime.GC() // Принудительная сборка мусора
    printMemStats("После GC")
}

func printMemStats(msg string) {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    fmt.Printf("%s: Alloc = %v MiB", msg, m.Alloc / 1024 / 1024)
    fmt.Printf("\tTotalAlloc = %v MiB", m.TotalAlloc / 1024 / 1024)
    fmt.Printf("\tSys = %v MiB", m.Sys / 1024 / 1024)
    fmt.Printf("\tNumGC = %v\n", m.NumGC)
}
```

В этом примере показано выделение памяти до и после сборки мусора, иллюстрируя, как Go управляет памятью.

## Заключение

Сборщик мусора Go является ключевой частью его привлекательности, предлагая автоматическое управление памятью, позволяющее разработчикам больше сосредотачиваться на логике приложения и меньше на ручном управлении памятью. Однако понимание того, как работает GC и как он влияет на производительность приложения, крайне важно. Хорошие практики вокруг выделения памяти и повторного использования объектов могут значительно улучшить производительность и снизить нагрузку на GC в приложениях на Go.