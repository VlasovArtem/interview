<!-- TOC -->
  * [1. Что такое горутина и каковы её случаи использования?](#1-что-такое-горутина-и-каковы-её-случаи-использования)
  * [2. Как запустить горутину?](#2-как-запустить-горутину)
  * [3. Что такое канал и каковы его случаи использования?](#3-что-такое-канал-и-каковы-его-случаи-использования)
  * [4. Что такое буферизованный канал?](#4-что-такое-буферизованный-канал)
  * [5. Что произойдет при чтении/записи открытого/закрытого/nil канала?](#5-что-произойдет-при-чтениизаписи-открытогозакрытогоnil-канала)
  * [6. Какие синхронизирующие примитивы (из sync/xsync) вы знаете? Можете привести примеры использования?](#6-какие-синхронизирующие-примитивы-из-syncxsync-вы-знаете-можете-привести-примеры-использования)
  * [7. Случаи использования оператора select-case?](#7-случаи-использования-оператора-select-case)
  * [8. Объясните разницу между процессом, потоком и горутиной?](#8-объясните-разницу-между-процессом-потоком-и-горутиной)
  * [9. Что такое гонка, гонка данных и взаимоблокировка?](#9-что-такое-гонка-гонка-данных-и-взаимоблокировка)
  * [10. Как можно подождать завершения группы горутин?](#10-как-можно-подождать-завершения-группы-горутин)
  * [11. Какова цель пакета atomic?](#11-какова-цель-пакета-atomic)
  * [12. Как определить, что буферизованный канал полон? Как можно обрабатывать запись в полный канал?](#12-как-определить-что-буферизованный-канал-полон-как-можно-обрабатывать-запись-в-полный-канал)
  * [13. В чем разница между параллелизмом и конкурентностью?](#13-в-чем-разница-между-параллелизмом-и-конкурентностью)
  * [14. Какие шаблоны конкурентности вы знаете? Объясните случаи использования.](#14-какие-шаблоны-конкурентности-вы-знаете-объясните-случаи-использования)
  * [15. Объясните, как работает планировщик Golang под капотом?](#15-объясните-как-работает-планировщик-golang-под-капотом)
  * [16. Какие проблемы конкурентности может обнаружить детектор гонок? (гонка данных/ гонка/ взаимоблокировка)](#16-какие-проблемы-конкурентности-может-обнаружить-детектор-гонок-гонка-данных-гонка-взаимоблокировка)
<!-- TOC -->

## 1. Что такое горутина и каковы её случаи использования?

**Вопрос:**  
Что такое горутина и каковы её случаи использования?

**Ответ:**  
Горутина — это легковесный поток выполнения, управляемый средой выполнения Go. Горутины позволяют выполнять функции асинхронно, что позволяет эффективно использовать многопоточность и повышает производительность программы.

Случаи использования:
- Параллельное выполнение независимых задач.
- Обработка I/O операций без блокировки основного потока.
- Построение конкурентных систем, таких как веб-серверы или обработчики событий.

## 2. Как запустить горутину?

**Вопрос:**  
Как запустить горутину?

**Ответ:**  
Запуск горутины осуществляется с использованием ключевого слова `go` перед вызовом функции.

```go
go functionName()
```

Пример:
```go
go func() {
    fmt.Println("Hello from goroutine")
}()
```

## 3. Что такое канал и каковы его случаи использования?

**Вопрос:**  
Что такое канал и каковы его случаи использования?

**Ответ:**  
Канал — это средство общения между горутинами в Go. Каналы позволяют горутинам безопасно обмениваться данными и синхронизировать выполнение.

Случаи использования:
- Передача данных между горутинами.
- Синхронизация выполнения горутин.
- Построение паттернов производственного и потребительского (producer-consumer).

## 4. Что такое буферизованный канал?

**Вопрос:**  
Что такое буферизованный канал?

**Ответ:**  
Буферизованный канал — это канал, который может содержать ограниченное количество элементов. Он позволяет отправителю не блокироваться до тех пор, пока буфер не заполнится.

Создание буферизованного канала:
```go
ch := make(chan int, 3)
```

## 5. Что произойдет при чтении/записи открытого/закрытого/nil канала?

**Вопрос:**  
Что произойдет при чтении/записи открытого/закрытого/nil канала?

**Ответ:**
- **Открытый канал:** данные могут быть записаны и прочитаны без блокировки, пока есть место для записи или данные для чтения.
- **Закрытый канал:** запись в закрытый канал вызовет панику, чтение из закрытого канала вернет нулевое значение типа канала.
- **Nil канал:** чтение или запись вызовет блокировку горутины навсегда.

## 6. Какие синхронизирующие примитивы (из sync/xsync) вы знаете? Можете привести примеры использования?

**Вопрос:**  
Какие синхронизирующие примитивы (из sync/xsync) вы знаете? Можете привести примеры использования?

**Ответ:**  
Примеры синхронизирующих примитивов:
- `sync.Mutex`: используется для блокировки доступа к критической секции.
  ```go
  var mu sync.Mutex
  mu.Lock()
  // критическая секция
  mu.Unlock()
  ```
- `sync.WaitGroup`: используется для ожидания завершения группы горутин.
  ```go
  var wg sync.WaitGroup
  wg.Add(1)
  go func() {
      defer wg.Done()
      // выполнение горутины
  }()
  wg.Wait()
  ```
- `sync.Cond`: используется для сигнализации между горутинами.
  ```go
  var cond = sync.NewCond(&sync.Mutex{})
  cond.L.Lock()
  cond.Wait() // ожидание сигнала
  cond.Signal() // отправка сигнала
  cond.L.Unlock()
  ```

## 7. Случаи использования оператора select-case?

**Вопрос:**  
Случаи использования оператора select-case?

**Ответ:**  
Оператор `select` позволяет горутине ждать нескольких операций с каналами одновременно. Он выбирает один из доступных каналов, готовых для операции.

Случаи использования:
- Мультиплексирование каналов.
- Тайм-ауты и временные ограничения.
- Обработка событий от нескольких источников.

Пример:
```go
select {
case msg := <-ch1:
    fmt.Println("Received from ch1:", msg)
case msg := <-ch2:
    fmt.Println("Received from ch2:", msg)
case <-time.After(time.Second):
    fmt.Println("Timeout")
}
```

## 8. Объясните разницу между процессом, потоком и горутиной?

**Вопрос:**  
Объясните разницу между процессом, потоком и горутиной?

**Ответ:**
- **Процесс:** независимая программа с собственным адресным пространством. Процессы изолированы друг от друга.
- **Поток:** легковесный процесс, который делит адресное пространство с другими потоками внутри того же процесса. Потоки могут обмениваться данными быстрее, но сложнее управлять синхронизацией.
- **Горутина:** еще более легковесный поток выполнения, управляемый средой выполнения Go. Горутины дешевле в плане ресурсов и проще в использовании благодаря встроенным средствам синхронизации.

## 9. Что такое гонка, гонка данных и взаимоблокировка?

**Вопрос:**  
Что такое гонка, гонка данных и взаимоблокировка?

**Ответ:**
- **Гонка:** ситуация, когда две или более горутины конкурируют за доступ к одному и тому же ресурсу без должной синхронизации, что приводит к непредсказуемому поведению.
- **Гонка данных:** специфический тип гонки, где несколько горутин одновременно читают и записывают общие данные без должной синхронизации, что приводит к непредсказуемым результатам.
- **Взаимоблокировка (deadlock):** состояние, когда две или более горутины навсегда заблокированы, ожидая друг друга для освобождения ресурсов.

## 10. Как можно подождать завершения группы горутин?

**Вопрос:**  
Как можно подождать завершения группы горутин?

**Ответ:**  
Для ожидания завершения группы горутин можно использовать `sync.WaitGroup`.

Пример:
```go
var wg sync.WaitGroup

wg.Add(3)
for i := 0; i < 3; i++ {
    go func(i int) {
        defer wg.Done()
        fmt.Printf("Goroutine %d finished\n", i)
    }(i)
}

wg.Wait()
fmt.Println("All goroutines finished")
```

## 11. Какова цель пакета atomic?

**Вопрос:**  
Какова цель пакета atomic?

**Ответ:**  
Пакет `sync/atomic` предоставляет низкоуровневые примитивы для атомарных операций над переменными. Это необходимо для безопасного доступа и изменения данных из нескольких горутин без использования мьютексов.

Пример использования:
```go
import "sync/atomic"

var counter int64

atomic.AddInt64(&counter, 1)
value := atomic.LoadInt64(&counter)
atomic.StoreInt64(&counter, 10)
```

## 12. Как определить, что буферизованный канал полон? Как можно обрабатывать запись в полный канал?

**Вопрос:**  
Как определить, что буферизованный канал полон? Как можно обрабатывать запись в полный канал?

**Ответ:**  
Определить, что буферизованный канал полон, можно проверкой длины канала и его емкости.

Пример:
```go
if len(ch) == cap(ch) {
    fmt.Println("Channel is full")
}
```

Обработка записи в полный канал:
- Использовать оператор `select` для немедленной проверки и обработки случая полного канала.
- Увеличить емкость канала или использовать другой механизм для временного хранения

данных.

Пример с `select`:
```go
select {
case ch <- data:
    // данные записаны
default:
    fmt.Println("Channel is full, handle accordingly")
}
```

## 13. В чем разница между параллелизмом и конкурентностью?

**Вопрос:**  
В чем разница между параллелизмом и конкурентностью?

**Ответ:**
- **Конкурентность:** выполнение нескольких задач, чередующихся во времени. Цель — эффективное использование ресурсов путем разделения времени выполнения между задачами.
- **Параллелизм:** одновременное выполнение нескольких задач на разных процессорах или ядрах. Параллелизм требует наличия аппаратных возможностей для одновременного выполнения.

## 14. Какие шаблоны конкурентности вы знаете? Объясните случаи использования.

**Вопрос:**  
Какие шаблоны конкурентности вы знаете? Объясните случаи использования.

**Ответ:**
- **Worker Pool (пул рабочих):** распределение задач между фиксированным числом рабочих горутин.
  Использование: серверы, обрабатывающие множество запросов.
- **Fan-out/Fan-in:** разделение работы между несколькими горутинами (fan-out) и объединение результатов (fan-in).
  Использование: параллельная обработка данных.
- **Pipeline (конвейер):** данные проходят через несколько этапов обработки в разных горутинах.
  Использование: обработка данных поэтапно.

## 15. Объясните, как работает планировщик Golang под капотом?

**Вопрос:**  
Объясните, как работает планировщик Golang под капотом?

**Ответ:**  
Планировщик Golang управляет выполнением горутин, распределяя их между системными потоками. Он использует модель M:N, где M — количество горутин, а N — количество потоков. Планировщик работает по принципу кооперативного многозадачности и обеспечивает справедливое распределение процессорного времени.

Основные компоненты:
- **G (goroutine):** сама горутина.
- **M (machine):** операционный системный поток.
- **P (processor):** логический процессор, управляет выполнением горутин.

## 16. Какие проблемы конкурентности может обнаружить детектор гонок? (гонка данных/ гонка/ взаимоблокировка)

**Вопрос:**  
Какие проблемы конкурентности может обнаружить детектор гонок? (гонка данных/ гонка/ взаимоблокировка)

**Ответ:**  
Детектор гонок в Go (`go run -race`) может обнаружить:
- **Гонку данных:** незащищенный доступ к общим данным.
- **Гонку:** конкуренцию за ресурсы.
- **Взаимоблокировку:** не обнаруживает напрямую, но может помочь выявить проблемы синхронизации, приводящие к взаимоблокировке.