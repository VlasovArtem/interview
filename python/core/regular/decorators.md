<!-- TOC -->
* [Введение](#введение)
* [Что такое декораторы?](#что-такое-декораторы)
* [Создание простого декоратора](#создание-простого-декоратора)
* [Применение декораторов](#применение-декораторов)
* [Декораторы с аргументами](#декораторы-с-аргументами)
* [Вложенные декораторы](#вложенные-декораторы)
* [Класс-декоратор](#класс-декоратор)
* [Использование нескольких декораторов](#использование-нескольких-декораторов)
* [Практическое применение декораторов](#практическое-применение-декораторов)
* [Заключение](#заключение)
<!-- TOC -->

# Введение
Декораторы в Python - это мощный инструмент для изменения поведения функций или методов. Они позволяют оборачивать одну функцию в другую, добавляя дополнительный функционал или изменяя существующий.

# Что такое декораторы?
Декораторы - это функции, которые принимают другую функцию в качестве аргумента и возвращают новую функцию с добавленным или измененным поведением.

Пример простого декоратора:

```python
def simple_decorator(func):
    def wrapper():
        print("До вызова функции")
        func()
        print("После вызова функции")
    return wrapper

@simple_decorator
def say_hello():
    print("Hello!")

say_hello()
```

# Создание простого декоратора
Для создания простого декоратора, нужно определить функцию-декоратор, которая будет принимать функцию в качестве аргумента и возвращать новую функцию.

Пример:

```python
def my_decorator(func):
    def wrapper():
        print("Что-то происходит перед вызовом функции")
        func()
        print("Что-то происходит после вызова функции")
    return wrapper

@my_decorator
def my_function():
    print("Это моя функция")

my_function()
```

# Применение декораторов
Декораторы применяются с помощью символа `@`, за которым следует имя декоратора, перед определением функции.

Пример:

```python
@my_decorator
def another_function():
    print("Это еще одна функция")

another_function()
```

# Декораторы с аргументами
Декораторы могут принимать аргументы, если обертка внутри декоратора определена для принятия этих аргументов.

Пример:

```python
def decorator_with_args(func):
    def wrapper(*args, **kwargs):
        print(f"Аргументы функции: {args}, {kwargs}")
        return func(*args, **kwargs)
    return wrapper

@decorator_with_args
def function_with_args(x, y):
    return x + y

print(function_with_args(3, 4))
```

# Вложенные декораторы
Можно использовать несколько декораторов для одной функции, они будут применяться в порядке сверху вниз.

Пример:

```python
def decorator_one(func):
    def wrapper():
        print("Первый декоратор")
        func()
    return wrapper

def decorator_two(func):
    def wrapper():
        print("Второй декоратор")
        func()
    return wrapper

@decorator_one
@decorator_two
def my_function():
    print("Оригинальная функция")

my_function()
```

# Класс-декоратор
Декораторы могут быть реализованы с использованием классов. Это позволяет использовать состояния между вызовами функции.

Пример:

```python
class MyDecorator:
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        print("Что-то происходит перед вызовом функции")
        result = self.func(*args, **kwargs)
        print("Что-то происходит после вызова функции")
        return result

@MyDecorator
def my_function():
    print("Это моя функция")

my_function()
```

# Использование нескольких декораторов
Можно комбинировать несколько декораторов, оборачивая функцию в несколько слоев.

Пример:

```python
def decorator_a(func):
    def wrapper():
        print("Декоратор A")
        func()
    return wrapper

def decorator_b(func):
    def wrapper():
        print("Декоратор B")
        func()
    return wrapper

@decorator_a
@decorator_b
def my_function():
    print("Оригинальная функция")

my_function()
```

# Практическое применение декораторов
Декораторы полезны в различных сценариях, таких как логирование, контроль доступа, кэширование и валидация данных.

Пример логирования:

```python
def log_decorator(func):
    def wrapper(*args, **kwargs):
        print(f"Вызов функции {func.__name__} с аргументами {args} и {kwargs}")
        result = func(*args, **kwargs)
        print(f"Функция {func.__name__} вернула {result}")
        return result
    return wrapper

@log_decorator
def add(a, b):
    return a + b

print(add(2, 3))
```

# Заключение
Декораторы - это мощный инструмент Python, который позволяет изменять поведение функций и методов. Они полезны в различных сценариях и позволяют писать более чистый и модульный код.