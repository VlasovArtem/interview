<!-- TOC -->
* [Введение](#введение)
* [Создание генераторов](#создание-генераторов)
  * [Использование ключевого слова `yield`](#использование-ключевого-слова-yield)
* [Работа с генераторами](#работа-с-генераторами)
  * [Функции генератора](#функции-генератора)
  * [Методы генератора](#методы-генератора)
* [Преимущества генераторов](#преимущества-генераторов)
  * [Ленивые вычисления](#ленивые-вычисления)
  * [Экономия памяти](#экономия-памяти)
* [Сравнение с итераторами](#сравнение-с-итераторами)
* [Практические примеры](#практические-примеры)
  * [Простой генератор чисел Фибоначчи](#простой-генератор-чисел-фибоначчи)
  * [Генераторы с использованием выражений-генераторов](#генераторы-с-использованием-выражений-генераторов)
* [Обработка исключений в генераторах](#обработка-исключений-в-генераторах)
* [Заключение](#заключение)
<!-- TOC -->

# Введение

Генераторы в Python — это мощный инструмент для создания итераторов. Они позволяют создавать последовательности значений на лету, что делает их идеальными для работы с большими объемами данных и потоками данных.

# Создание генераторов

## Использование ключевого слова `yield`

Генераторы создаются с помощью ключевого слова `yield`. В отличие от обычных функций, которые используют `return` для возврата значения и завершения работы, генераторы используют `yield` для возврата значения и сохранения состояния выполнения функции.

Пример:

```python
def simple_generator():
    yield 1
    yield 2
    yield 3

gen = simple_generator()
print(next(gen))  # 1
print(next(gen))  # 2
print(next(gen))  # 3
```

# Работа с генераторами

## Функции генератора

Генераторные функции возвращают генераторы, которые можно итерировать с помощью функций `next()`, `for`-циклов или других методов, поддерживающих итераторы.

## Методы генератора

Генераторы имеют несколько встроенных методов, таких как `send()`, `throw()` и `close()`.

Пример:

```python
def generator():
    try:
        yield 'Hello'
        yield 'World'
    except GeneratorExit:
        print('Generator closed')

gen = generator()
print(next(gen))  # 'Hello'
gen.close()
```

# Преимущества генераторов

## Ленивые вычисления

Генераторы вычисляют значения по мере необходимости, что позволяет экономить ресурсы.

Пример:

```python
def count_up_to(max):
    count = 1
    while count <= max:
        yield count
        count += 1

counter = count_up_to(5)
print(next(counter))  # 1
print(next(counter))  # 2
```

## Экономия памяти

Генераторы позволяют работать с последовательностями, не загружая все элементы в память сразу.

Пример:

```python
def large_range():
    for i in range(1000000):
        yield i

for number in large_range():
    if number == 10:
        break
print("Done")
```

# Сравнение с итераторами

Генераторы проще и лаконичнее в использовании по сравнению с классами, реализующими итераторы.

Пример итератора:

```python
class Counter:
    def __init__(self, max):
        self.max = max
        self.current = 1

    def __iter__(self):
        return self

    def __next__(self):
        if self.current <= self.max:
            self.current += 1
            return self.current - 1
        else:
            raise StopIteration

counter = Counter(5)
for num in counter:
    print(num)  # 1, 2, 3, 4, 5
```

# Практические примеры

## Простой генератор чисел Фибоначчи

Пример генератора для последовательности чисел Фибоначчи:

```python
def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

fib = fibonacci()
for _ in range(10):
    print(next(fib))
```

## Генераторы с использованием выражений-генераторов

Выражения-генераторы позволяют создавать генераторы в виде компактных выражений, аналогичных списковым включениям.

Пример:

```python
gen = (x * x for x in range(10))
for num in gen:
    print(num)  # 0, 1, 4, 9, ..., 81
```

# Обработка исключений в генераторах

Генераторы могут обрабатывать исключения с помощью блока `try/except`.

Пример:

```python
def safe_generator():
    try:
        yield 'Start'
        yield 'Continue'
    except Exception as e:
        yield f'Error: {e}'
    finally:
        yield 'End'

gen = safe_generator()
print(next(gen))  # 'Start'
print(gen.throw(Exception, 'Something went wrong'))  # 'Error: Something went wrong'
print(next(gen))  # 'End'
```

# Заключение

Генераторы являются мощным инструментом в Python, предоставляя простой способ создания итераторов с ленивыми вычислениями и экономией памяти. Они особенно полезны для работы с большими объемами данных и потоками данных, где важно минимизировать использование ресурсов.