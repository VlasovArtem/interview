<!-- TOC -->
* [Basic](#basic)
  * [1. Какие встроенные типы данных есть в Python](#1-какие-встроенные-типы-данных-есть-в-python)
  * [2. Как обрабатывать ошибки в Python](#2-как-обрабатывать-ошибки-в-python)
  * [3. Какие типы импорта вы знаете и чем они различаются](#3-какие-типы-импорта-вы-знаете-и-чем-они-различаются)
  * [4. В чем разница между модулем и пакетом](#4-в-чем-разница-между-модулем-и-пакетом)
  * [5. Что такое области видимости и как они работают в Python](#5-что-такое-области-видимости-и-как-они-работают-в-python)
* [Regular](#regular)
  * [6. Как Python "знает", где искать модули и пакеты](#6-как-python-знает-где-искать-модули-и-пакеты)
  * [7. Как справиться с циклическими импортами?](#7-как-справиться-с-циклическими-импортами)
    * [1. Переместить импорт внутрь функции или метода](#1-переместить-импорт-внутрь-функции-или-метода)
    * [2. Рефакторить код, чтобы устранить взаимные зависимости](#2-рефакторить-код-чтобы-устранить-взаимные-зависимости)
    * [3. Использовать импорт в конце модуля для разбития циклических ссылок](#3-использовать-импорт-в-конце-модуля-для-разбития-циклических-ссылок)
    * [4. Использование ленивого импорта через `importlib`](#4-использование-ленивого-импорта-через-importlib)
    * [5. Использование интерфейсов или абстракций](#5-использование-интерфейсов-или-абстракций)
  * [8. В чем разница между итератором и генератором](#8-в-чем-разница-между-итератором-и-генератором)
  * [9. Какие проблемы решает менеджер контекста?](#9-какие-проблемы-решает-менеджер-контекста)
  * [10. Какие проблемы решают декораторы?](#10-какие-проблемы-решают-декораторы)
  * [11. Какие проблемы решают аннотации типов?](#11-какие-проблемы-решают-аннотации-типов)
* [Advanced](#advanced)
  * [12. Что такое "утиная типизация" и как Python ее поддерживает?](#12-что-такое-утиная-типизация-и-как-python-ее-поддерживает)
  * [13. Как мы можем управлять доступом к данным экземпляра класса (с дескрипторами)?](#13-как-мы-можем-управлять-доступом-к-данным-экземпляра-класса-с-дескрипторами)
  * [14. Как Python проверяет тип значения объекта перед присваиванием?](#14-как-python-проверяет-тип-значения-объекта-перед-присваиванием)
  * [15. Что такое метакласс и какие у него случаи использования? Когда не следует их использовать?](#15-что-такое-метакласс-и-какие-у-него-случаи-использования-когда-не-следует-их-использовать)
<!-- TOC -->

# Basic

## 1. Какие встроенные типы данных есть в Python

**Вопрос:**  
Какие встроенные типы данных есть в Python?

**Ответ:**  
В Python существуют следующие встроенные типы данных:
- **Числовые типы данных**: `int`, `float`, `complex`
- **Последовательности**: `list`, `tuple`, `range`
- **Строки**: `str`
- **Множества**: `set`, `frozenset`
- **Отображения**: `dict`
- **Булевы значения**: `bool`
- **NoneType**: `None`

Каждый из этих типов данных имеет свои методы и операции, которые можно использовать для работы с данными соответствующего типа.

## 2. Как обрабатывать ошибки в Python

**Вопрос:**  
Как обрабатывать ошибки в Python?

**Ответ:**  
В Python для обработки ошибок используется механизм исключений. Основные конструкции для обработки ошибок:
- `try`: блок, в котором может возникнуть исключение.
- `except`: блок, который выполняется, если в блоке `try` возникает исключение.
- `else`: блок, который выполняется, если в блоке `try` не возникло исключений.
- `finally`: блок, который выполняется в любом случае, независимо от того, возникло исключение или нет.

Пример:
```python
try:
    result = 10 / 0
except ZeroDivisionError:
    print("Ошибка: Деление на ноль!")
else:
    print("Результат:", result)
finally:
    print("Выполнение завершено")
```

## 3. Какие типы импорта вы знаете и чем они различаются

**Вопрос:**  
Какие типы импорта вы знаете и чем они различаются?

**Ответ:**  
В Python существуют следующие типы импорта:
- **Прямой импорт**: Импорт всего модуля.
  ```python
  import math
  print(math.sqrt(4))
  ```
- **Импорт конкретных объектов**: Импорт отдельных функций или классов из модуля.
  ```python
  from math import sqrt
  print(sqrt(4))
  ```
- **Импорт с псевдонимом**: Импорт модуля или объектов с присвоением им псевдонима.
  ```python
  import math as m
  print(m.sqrt(4))
  
  from math import sqrt as square_root
  print(square_root(4))
  ```

## 4. В чем разница между модулем и пакетом

**Вопрос:**  
В чем разница между модулем и пакетом?

**Ответ:**
- **Модуль**: Это файл с расширением `.py`, содержащий код на Python. Модуль может содержать функции, классы и переменные.
- **Пакет**: Это директория, содержащая модули и файл `__init__.py`. Пакеты позволяют структурировать модули в иерархию, облегчая их организацию и управление.

## 5. Что такое области видимости и как они работают в Python

**Вопрос:**  
Что такое области видимости и как они работают в Python?

**Ответ:**  
Области видимости (scopes) в Python определяют контекст, в котором переменные могут быть использованы. Существует четыре уровня областей видимости:
- **Local (Локальная)**: Внутри функции.
- **Enclosing (Вложенная)**: Внутри внешних функций.
- **Global (Глобальная)**: На уровне модуля.
- **Built-in (Встроенная)**: Встроенные имена, доступные по умолчанию.

Python использует правило LEGB (Local, Enclosing, Global, Built-in) для разрешения имен переменных.

# Regular

## 6. Как Python "знает", где искать модули и пакеты

**Вопрос:**  
Как Python "знает", где искать модули и пакеты?

**Ответ:**  
Python ищет модули и пакеты в директориях, указанных в переменной `sys.path`. Эта переменная включает:
- Директорию текущего скрипта.
- Переменные окружения PYTHONPATH.
- Директории стандартных библиотек.

Можно также вручную добавлять пути в `sys.path`.

## 7. Как справиться с циклическими импортами?

**Вопрос:**  
Как справиться с циклическими импортами?

**Ответ:**  
Циклические импорты возникают, когда два или более модулей зависят друг от друга, что приводит к зацикливанию при попытке загрузить эти модули. Это может вызвать ошибки и проблемы в вашем приложении. Рассмотрим несколько способов справиться с циклическими импортами и приведем примеры кода для каждого метода.

### 1. Переместить импорт внутрь функции или метода

Когда импорт выполняется внутри функции или метода, он не загружается до тех пор, пока не будет вызван этот метод. Это позволяет избежать циклической зависимости при загрузке модулей.

**Пример:**

```python
# module_a.py
def function_a():
    from module_b import function_b
    function_b()

# module_b.py
def function_b():
    print("Hello from function_b")
```

### 2. Рефакторить код, чтобы устранить взаимные зависимости

Если модули сильно зависят друг от друга, возможно, имеет смысл пересмотреть их структуру и объединить некоторые функции в один модуль или выделить общую функциональность в новый модуль.

**Пример:**

```python
# common_module.py
def common_function():
    print("This is a common function")

# module_a.py
from common_module import common_function

def function_a():
    common_function()

# module_b.py
from common_module import common_function

def function_b():
    common_function()
```

### 3. Использовать импорт в конце модуля для разбития циклических ссылок

Перемещение импортов в конец модуля может помочь избежать циклических зависимостей, так как модули будут загружены до того, как выполнится импорт.

**Пример:**

```python
# module_a.py
def function_a():
    print("Function A")

from module_b import function_b  # импорт в конце файла

# module_b.py
def function_b():
    print("Function B")

from module_a import function_a  # импорт в конце файла
```

### 4. Использование ленивого импорта через `importlib`

В некоторых случаях можно использовать модуль `importlib` для динамического импорта модулей только в момент их использования.

**Пример:**

```python
# module_a.py
def function_a():
    import importlib
    module_b = importlib.import_module('module_b')
    module_b.function_b()

# module_b.py
def function_b():
    import importlib
    module_a = importlib.import_module('module_a')
    module_a.function_a()
```

### 5. Использование интерфейсов или абстракций

Разделение зависимостей с помощью интерфейсов или абстракций может помочь уменьшить или устранить циклические зависимости.

**Пример:**

```python
# interface.py
class Interface:
    def function(self):
        raise NotImplementedError

# module_a.py
from interface import Interface

class ModuleA(Interface):
    def function(self):
        print("Function A")

# module_b.py
from interface import Interface

class ModuleB(Interface):
    def function(self):
        print("Function B")
```

Используя эти методы, вы сможете эффективно справляться с циклическими импортами и поддерживать структуру вашего кода чистой и устойчивой к изменениям.

## 8. В чем разница между итератором и генератором

**Вопрос:**  
В чем разница между итератором и генератором?

**Ответ:**
- **Итератор**: Объект, который реализует методы `__iter__()` и `__next__()`. Он возвращает элементы по одному за раз.
- **Генератор**: Специальный вид итератора, который создается с использованием ключевого слова `yield` внутри функции. Генераторы проще в использовании и эффективнее по памяти.

Пример генератора:
```python
def my_generator():
    yield 1
    yield 2
    yield 3

for value in my_generator():
    print(value)
```

## 9. Какие проблемы решает менеджер контекста?

**Вопрос:**  
Какие проблемы решает менеджер контекста?

**Ответ:**  
Менеджер контекста используется для автоматического управления ресурсами, такими как файлы, сетевые соединения и т. д. Он гарантирует, что ресурсы будут корректно закрыты после использования, даже если в коде возникло исключение.

Пример использования:
```python
with open('file.txt', 'r') as file:
    data = file.read()
# Файл автоматически закрывается после выхода из блока with
```

## 10. Какие проблемы решают декораторы?

**Вопрос:**  
Какие проблемы решают декораторы?

**Ответ:**  
Декораторы позволяют добавлять функциональность к существующим функциям или методам без изменения их кода. Они полезны для:
- Логирования
- Управления доступом
- Кэширования
- Проверки аутентификации

Пример декоратора:
```python
def my_decorator(func):
    def wrapper():
        print("Что-то делаем до вызова функции")
        func()
        print("Что-то делаем после вызова функции")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
```

## 11. Какие проблемы решают аннотации типов?

**Вопрос:**  
Какие проблемы решают аннотации типов?

**Ответ:**  
Аннотации типов улучшают читаемость и понимание кода, предоставляя явную информацию о типах переменных и возвращаемых значений функций. Они также помогают инструментам статического анализа находить ошибки до выполнения кода.

Пример:
```python
def greet(name: str) -> str:
    return f"Hello, {name}"
```

# Advanced

## 12. Что такое "утиная типизация" и как Python ее поддерживает?

**Вопрос:**  
Что такое "утиная типизация" и как Python ее поддерживает?

**Ответ:**  
Утиная типизация (duck typing) - это концепция, согласно которой тип объекта определяется не его классом, а его поведением (методами и свойствами). В Python утиная типизация поддерживается динамической природой языка: если объект ведет себя как нужный тип (например, имеет метод `quack`), он может быть использован как этот тип, независимо от его фактического класса.

## 13. Как мы можем управлять доступом к данным экземпляра класса (с дескрипторами)?

**Вопрос:**


Как мы можем управлять доступом к данным экземпляра класса (с дескрипторами)?

**Ответ:**  
Дескрипторы - это объекты, которые управляют доступом к другим объектам через методы `__get__()`, `__set__()` и `__delete__()`. Они позволяют контролировать доступ к атрибутам экземпляра класса.

Пример:
```python
class Descriptor:
    def __get__(self, instance, owner):
        return instance._value
    
    def __set__(self, instance, value):
        instance._value = value
    
    def __delete__(self, instance):
        del instance._value

class MyClass:
    value = Descriptor()

obj = MyClass()
obj.value = 42
print(obj.value)  # 42
del obj.value
```

## 14. Как Python проверяет тип значения объекта перед присваиванием?

**Вопрос:**  
Как Python проверяет тип значения объекта перед присваиванием?

**Ответ:**  
В Python типы значений не проверяются перед присваиванием, так как это динамически типизированный язык. Однако, можно использовать аннотации типов и сторонние инструменты (например, `mypy`) для проверки типов во время статического анализа кода.

## 15. Что такое метакласс и какие у него случаи использования? Когда не следует их использовать?

**Вопрос:**  
Что такое метакласс и какие у него случаи использования? Когда не следует их использовать?

**Ответ:**  
Метакласс - это класс, экземпляры которого являются другими классами. Он определяет поведение и структуру других классов. Метаклассы используются для:
- Автоматической регистрации классов
- Модификации классов при их создании
- Внедрения общих интерфейсов и паттернов

Однако, метаклассы могут усложнить понимание и поддержку кода, поэтому их следует использовать только в случае явной необходимости и если нет более простого решения.