# @Transactional

## propagation

```java
@Transactional(propagation=Propagation.REQUIRED)
```

Если `propagation` не указан, то стратегия распространения по дефолту это `REQUIRED`.

- `REQUIRED`- Означает что целевой метод не может быть запущен без активной транзакции. Если транзакция уже стартовала до вызова этого метода, тогда методы 
выполнится в ней или иначе при вызове метода новая транзакция будет создана.
- `REQUIRES_NEW` - Означает что новая транзакция должна начинаться всякий раз, как целевой метод будет вызываться. Если уже есть начатая транзакция, то она будет 
приостановлена, до начала новой.
- `MANDATORY` - Означает что целевой метод требует активной транзакции для старта. Если ее нет, то выполнение не будет произведено, и выбросится исключение.
- `SUPPORTS` - Означает что целевой метод может быть исполнен вне транзакции. Если есть начатая транзакция, то метод запустится в ней. Если нет запущенной 
транзакции, то метод выполнится все равно, только не в транзакционом контексте. Методы, которые выполняют выборку данных наилучшие кандидаты для этой опции.
- `NOT_SUPPORTED` - Означает что целевой метод не требует транзакционного контекста для выполнения. Если есть начатая транзакция, то она будет приостановлена.
- `NEVER` - Означает что целевой метод выбросит исключение, если выполнится в транзакционном процессе. Не советую использовать эту опцию.

## Isolation level
Я уже писал про побочные эффекты, вызываемые параллельным исполнением запросов. Уровни изоляции транзакций можно рассматривать как механизм, позволяющий решать проблему параллельного доступа к данным и изменения данных без явных ручных блокировок.

Существует четыре уровня изоляции транзакций, в которых подобные побочные эффекты могут происходить, а могут и не происходить:

- `DEFAULT` - используется по умолчанию и представляет собой дефолтный уровень изоляции для используемой БД
- `SERIALIZABLE` - транзакции полностью изолируются друг от друга и ни одна транзакция ни коим образом не влияет на другие. Самая низкая степень параллельности транзакций.
- `REPEATABLE_READ` - изменения данных, которые были прочитаны в транзакции ранее в транзакцию не попадают, другие транзакции не могут изменять данные, прочитанные этой транзакцией. Возможен эффект фантомного чтения, степерь параллельности транзакций выше, чем у Serializable.
- `READ_COMMITTED` - транзакции получают изменения в данных от других транзакций, которые были успешно подтверждены. Возможны эффекты фантомного чтения и неповторяемого чтения. Этот уровень изоляции обычно используется по умолчанию в базах данных и обеспечивает хорошую степень параллельности транзакций.
- `READ_UNCOMMITTED` - самый низший уровень изоляции транзакций, который гарантирует только, что изменения, внёсённые одной транзакцией, не будут перезаписаные другой транзакцией. Подвержден всем эффектам влияния транзакций друг на друга. Обеспечивает наивысшую степерь параллельности транзакций.

В Spring эти уровни представлены в виде enum `Isolation`, члены которого передаются в аннотацию `@Transactional`:

```java
@Transactional(isolation = Isolation.SERIALIZABLE)
```

## rollbackFor

```java
@Transactional(rollbackFor=Exception.class)
```

По умолчанию откат происходит при `rollbackFor=RunTimeException.class`

В спринге, все `API` классы выбрасывают `RuntimeException`, что означает что если любой метод упал, то контейнер всегда произведет откат текущей транзакции.
Проблема только с `checked exceptions`. Так что данная опция может использоваться для декларативного отката транзакции если выбросится `Checked Exception`.

## noRollbackFor

```java
@Transactional(noRollbackFor=IllegalStateException.class)
```

Означает что откат не должен происходить если целевой метод выбросил это исключение.
