# References (Weak, Soft, Strong, Phantom) 

## Strong references

**Strong reference** - это обычная ссылка на Java, которую вы используете каждый день. Например, код:

```java
Widget widget = new Widget();
```

создает новый `Widget()` и сохраняет сильную ссылку на него в буфере переменных. Важная часть сильных ссылок - та часть, которая делает их «сильными» -
это то, как они взаимодействуют со сборщиком мусора. В частности, если объект доступен через цепочку сильных ссылок (строго достижимый), сборщик мусора 
не имеет права на его удалять. Поскольку вы не хотите, чтобы сборщик мусора уничтожал объекты, над которыми вы работаете, обычно это именно то, что вам нужно.

## When strong references are too strong

Приложение нередко использует классы, которые оно не может расширить. Класс может быть просто помечен как `final` или это может быть что-то более сложное, 
например интерфейс, возвращаемый фабричным методом, поддерживаемый неизвестным количеством конкретных реализаций. Предположим, вам нужно использовать класс 
`Widget`, и по какой-либо причине невозможно или практически невозможно расширить `Widget` для добавления новых функций.

Что происходит, когда вам нужно отслеживать дополнительную информацию об объекте? В этом случае предположим, что нам нужно отслеживать `serialNumber` каждого
`Widget`, но класс `Widget` на самом деле не имеет свойства `serialNumber` - и поскольку `Widget` не расширяем, мы не можем добавить его. Вообще нет проблем,
скажете вы. Мы можем использовать `HashMap`, в который положим пару `Widget - serialNumber`:

```java
serialNumberMap.put(widget, widgetSerialNumber);
```

На первый взгляд это может выглядеть нормально, но сильная ссылка на `widget` почти наверняка вызовет проблемы. Мы должны знать (со 100% уверенностью), 
когда `serialNumber` конкретного виджета больше не нужен, чтобы мы могли удалить его запись из мапы. В противном случае у нас будет утечка памяти 
(если мы не удалим виджеты, когда должны), или мы обнаружим, что у нас отсутствуют серийные номера (если мы удалим виджеты, которые все еще используем). 
Если эти проблемы кажутся вам знакомыми: это именно те проблемы, с которыми сталкиваются пользователи языков, не использующих сборщик мусора, при попытке 
управлять памятью, и нам не следует беспокоиться об этом в более цивилизованном языке, таком как Java.

Другая распространенная проблема с сильными ссылками - это кеширование, особенно с очень большими структурами, такими как изображения. Предположим, у вас есть
приложение, которое должно работать с изображениями, предоставляемыми пользователем, например, инструмент дизайна веб-сайтов. Естественно, вы хотите кэшировать
эти изображения, потому что загрузка их с диска очень дорога, и вы хотите избежать возможности одновременного размещения двух копий (потенциально гигантского)
изображения в памяти.

Поскольку предполагается, что кеш изображений не позволяет нам перезагружать изображения, когда в этом нет крайней необходимости, вы быстро поймете, что кеш
всегда должен содержать ссылку на любое изображение, которое уже находится в памяти. Однако с обычными сильными ссылками эта ссылка сама по себе заставит 
изображение оставаться в памяти, что требует от вас (как и выше) каким-то образом определить, когда изображение больше не требуется в памяти, и удалить его 
из кеша, чтобы оно стало доступным для сборки мусора. И снова вы вынуждены дублировать поведение сборщика мусора и вручную определять, должен ли объект 
находиться в памяти.

## WeakReference

Проще говоря, **weak reference** - это ссылка, которая недостаточно сильна, чтобы заставить объект оставаться в памяти. Слабые ссылки позволяют использовать
способность сборщика мусора определять доступность за вас, поэтому вам не нужно делать это самостоятельно. Вы создаете слабую ссылку следующим образом:

```java
WeakReference weakWidget = new WeakReference(widget);
```

а затем в другом месте кода вы можете использовать `weakWidget.get()` для получения фактического объекта `Widget`. Конечно, слабая ссылка недостаточно сильна,
чтобы предотвратить сборку мусора, поэтому вы можете обнаружить (если нет сильных ссылок на виджет), что `weakWidget.get()` внезапно начинает возвращать 
`null`.

Чтобы решить проблему с "серийным номером виджета", описанную выше, проще всего использовать встроенный класс `WeakHashMap`. `WeakHashMap` работает точно так
же, как `HashMap`, за исключением того, что **для ключей (а не значений!)** используются слабые ссылки. Если ключ `WeakHashMap` становится мусором, его запись 
удаляется автоматически. Это позволяет избежать описанных мною ловушек и не требует никаких изменений, кроме переключения с `HashMap` на `WeakHashMap`. 

#### Где можно использовать WeakReference

Как указано в документации Java, слабые ссылки чаще всего используются для реализации канонического маппинга. Маппинг называется каноническим, если он
содержит только один экземпляр определенного значения. Вместо того, чтобы создавать новый объект, он ищет существующий в сопоставлении и использует его.

Конечно, наиболее известным применением этих ссылок является класс `WeakHashMap`. Это реализация интерфейса `Map`, где каждый ключ хранится как слабая ссылка
на данный ключ. Когда сборщик мусора удаляет ключ, объект, связанный с этим ключом, также удаляется.

Еще одна область, где они могут быть использованы, - это проблема с задержанным слушателем - 
[Lapsed Listener Problem](http://ilkinulas.github.io/development/general/2016/04/17/observer-pattern.html).

#### Работа с WeakReference

Слабые ссылки представлены классом `java.lang.ref.WeakReference`. Мы можем инициализировать его, передав референт в качестве параметра. 
При желании мы также можем передать `java.lang.ref.ReferenceQueue`:

```java
Object referent = new Object();
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<>();
 
WeakReference weakReference1 = new WeakReference<>(referent);
WeakReference weakReference2 = new WeakReference<>(referent, referenceQueue);
```

Референт ссылки может быть получен методом `get()` и удален вручную с помощью метода `clear()`:

```java
Object referent2 = weakReference1.get();
weakReference1.clear();
```

Шаблон для безопасной работы с такими ссылками такой же, как и с мягкими ссылками:

```java
Object referent3 = weakReference2.get();
if (referent3 != null) {
    // GC hasn't removed the instance yet
} else {
    // GC has cleared the instance
}
```

## Reference queues

Как только `WeakReference` начинает возвращать значение `null`, объект, на который он указывает, становится мусором. Обычно это означает, что требуется 
какая-то очистка. `WeakHashMap`, например, должен удалить такие несуществующие записи, чтобы не удерживать постоянно увеличивающееся количество мертвых
`WeakReferences`.

Класс `ReferenceQueue` позволяет легко отслеживать мертвые ссылки. Если вы передадите `ReferenceQueue` в конструктор `WeakReference`, объект ссылки будет 
автоматически вставлен в очередь ссылок, когда объект, на который он указывает, становится мусором. Затем вы можете через некоторый регулярный интервал
обрабатывать `ReferenceQueue` и выполнять любую очистку, необходимую для мертвых ссылок.

## Different degrees of weakness

До этого момента мы говорили только о `WeakReference` и `strong reference`, но на самом деле существует четыре различных степени силы ссылок: `Strong`, `Soft`,
`Weak` и `Phantom`, в порядке от самой сильной к самой слабой. Мы уже обсудили `Strong` и `Weak` ссылки, поэтому давайте взглянем на два других типа.

## SoftReference

`SoftReference` в точности похожа на слабую ссылку, за исключением того, что она не так сильно стремится выбросить объект, на который она ссылается. 
Объект, который является только слабо достижимым (самые сильные ссылки на него - `WeakReferences`), будет отброшен в следующем цикле сборки мусора, 
но объект, который легко достижим (`SoftReference`), обычно остается какое-то время живым.

`SoftReferences` не обязаны вести себя иначе, чем `WeakReferences`, но на практике мягкодоступные объекты обычно сохраняются до тех пор, пока имеется
достаточный объем памяти. Это делает их отличной основой для кеша, такого как кеш изображений, описанный выше, поскольку вы можете позволить сборщику мусора
отвечать за то, что бы объекты были достижимы при нормальных условиях работы (когда достаточно памяти) и за то когда их удалять (если памяти стало мало).

Когда вызывается сборщик мусора, он начинает перебирать все элементы в куче. GC хранит объекты reference в специальной очереди. После проверки всех объектов 
в куче GC определяет, какие экземпляры следует удалить, удаляя объекты из указанной выше очереди. Эти правила различаются от одной реализации JVM к другой, 
но в документации указано следующее:

>все `SoftReference` гарантированно очищаются до того, как JVM выдаст `OutOfMemoryError`.

Тем не менее, не дается никаких гарантий относительно времени очистки `SoftReference` или порядка очистки набора таких ссылок на различные объекты.

Мягко достижимые объекты будут оставаться активными в течение некоторого времени после последнего обращения к ним. Значение по умолчанию - одна секунда жизни
на один свободный мегабайт в куче. Это значение можно изменить с помощью флага `-XX: SoftRefLRUPolicyMSPerMB`. Например, чтобы изменить значение на 2,5 секунды
(2500 миллисекунд), мы можем использовать:

```java
-XX:SoftRefLRUPolicyMSPerMB=2500
```

По сравнению с `WeakReference`, `SoftReference` могут иметь более длительный срок службы, поскольку они продолжают существовать до тех пор, пока не 
потребуется дополнительная память. Следовательно, это лучший выбор, если нам нужно удерживать объекты в памяти как можно дольше.

#### Работа с SoftReference

У нас есть два варианта его инициализации. Первый способ - передать только референт:

```java
StringBuilder builder = new StringBuilder();
SoftReference<StringBuilder> reference1 = new SoftReference<>(builder);
```

Второй вариант подразумевает передачу ссылки на `java.lang.ref.ReferenceQueue`, а также ссылки на референт. Очереди ссылок предназначены для информирования 
нас о действиях, выполняемых сборщиком мусора. Он добавляет объект ссылки в очередь ссылок, когда решает удалить референт этой ссылки. Вот как инициализировать
`SoftReference` с помощью `ReferenceQueue`:

```java
ReferenceQueue<StringBuilder> referenceQueue = new ReferenceQueue<>();
SoftReference<StringBuilder> reference2 = new SoftReference<>(builder, referenceQueue);
```

`java.lang.ref.Reference` содержит методы `get()` и `clear()` для получения и сброса референта соответственно:

```java
StringBuilder builder1 = reference2.get();
reference2.clear();
StringBuilder builder2 = reference2.get(); // null
```

Каждый раз, когда мы работаем с такими ссылками, нам нужно убедиться, что референт, возвращаемый `get()`, существует:

```java
StringBuilder builder3 = reference2.get();
if (builder3 != null) {
    // GC hasn't removed the instance yet
} else {
    // GC has cleared the instance
}
```

## PhantomReference

`PhantomReference` сильно отличается от `SoftReference` или `WeakReference`. Его захват объекта настолько слаб, что вы даже не можете получить объект - его 
метод `get()` всегда возвращает `null`. Единственное использование такой ссылки - отслеживать, когда она помещается в очередь в `ReferenceQueue`, поскольку в
этот момент вы знаете, что объект, на который она указывает, мертв. Но чем это отличается от `WeakReference`?

Разница в том, когда именно происходит постановка в очередь. `WeakReferences` ставятся в очередь, как только объект, на который они указывают, становится
труднодоступным. Это происходит до вызова `finalize()` или сборки мусора; теоретически объект может быть даже «воскрешен» неортодоксальным методом 
`finalize()`, но `WeakReference` останется мертвым. `PhantomReferences` ставятся в очередь только тогда, когда **объект физически удаляется из памяти**, 
то есть после выполнения метода `finalize()` его референта, а метод `get()` всегда возвращает значение `null` специально, чтобы вы не смогли «воскресить» почти 
мертвый объект.

#### Когда использовать PhantomReferences? 

Во-первых, они позволяют точно определить, когда объект был удален из памяти. Фактически, это единственный способ определить это. Обычно это не так полезно, 
но может пригодиться в определенных очень специфических обстоятельствах, таких как манипулирование большими изображениями: если вы точно знаете, 
что изображение должно быть собрано в мусор, вы можете подождать, пока это действительно произойдет, прежде чем пытаться загрузить следующее изображение, 
и, следовательно, уменьшить вероятность возникновения пугающей ошибки `OutOfMemoryError.`

Во-вторых, `PhantomReferences` позволяет избежать фундаментальной проблемы с финализацией: методы `finalize()` могут «воскрешать» объекты, создавая на них
новые сильные ссылки. Проблема в том, что объект, который переопределяет `finalize()`, теперь должен быть определен как мусор по крайней мере в двух 
отдельных циклах сборки мусора, чтобы его можно было удалить. Когда первый цикл определяет, что это мусор, на нем может быть вызван `finalize()`. 
Из-за (небольшой, но, к сожалению, реальной) возможности того, что объект был «воскрешен» во время финализации, сборщик мусора должен запуститься
снова, прежде чем объект может быть фактически удален. А поскольку финализация могла произойти не вовремя, могло произойти произвольное количество циклов 
сборки мусора, пока объект ожидал финализации. Это может означать серьезные задержки в фактической очистке объектов мусора, и поэтому вы можете получить 
`OutOfMemoryErrors`, даже если большая часть кучи является мусором.

С `PhantomReference` такая ситуация невозможна - когда `PhantomReference` ставится в очередь, нет абсолютно никакого способа получить указатель на теперь
мертвый объект (что хорошо, потому что его больше нет в памяти). Поскольку `PhantomReference` не может использоваться для воскрешения объекта, объект можно 
мгновенно очистить во время первого цикла сборки мусора, в котором он оказывается фантомно достижимым. Затем вы можете распоряжаться всеми необходимыми 
ресурсами по своему усмотрению.

Возможно, метод `finalize()` вообще не должен был предоставляться. `PhantomReferences` определенно безопаснее и эффективнее в использовании, а устранение
`finalize()` сделало бы части виртуальной машины значительно проще. Хорошая новость в том, что по крайней мере у вас есть выбор.

#### Работа с PhantomReference

Теперь давайте реализуем второй вариант использования, чтобы на практике понять, как работают такие ссылки. Во-первых, нам нужен подкласс класса 
`PhantomReference` для определения метода очистки ресурсов:

```java
public class LargeObjectFinalizer extends PhantomReference<Object> {
 
    public LargeObjectFinalizer(Object referent, ReferenceQueue<? super Object> q) {
        super(referent, q);
    }
 
    public void finalizeResources() {
        // free resources
        System.out.println("clearing ...");
    }
    
}
```

Теперь мы собираемся написать расширенную детальную финализацию:

```java
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<>();
List<LargeObjectFinalizer> references = new ArrayList<>();
List<Object> largeObjects = new ArrayList<>();
 
for (int i = 0; i < 10; ++i) {
    Object largeObject = new Object();
    largeObjects.add(largeObject);
    references.add(new LargeObjectFinalizer(largeObject, referenceQueue));
}
 
largeObjects = null;
System.gc();
 
Reference<?> referenceFromQueue;
for (PhantomReference<Object> reference : references) {
    System.out.println(reference.isEnqueued());
}
 
while ((referenceFromQueue = referenceQueue.poll()) != null) {
    ((LargeObjectFinalizer)referenceFromQueue).finalizeResources();
    referenceFromQueue.clear();
}
```

Во-первых, мы инициализируем все необходимые объекты: `referenceQueue` - для отслеживания помещенных в очередь ссылок, `references` - для последующей очистки,
`largeObjects` - для имитации большой структуры данных.

Затем мы создаем эти объекты с помощью классов `Object` и `LargeObjectFinalizer`.

Перед тем, как вызвать сборщик мусора, мы вручную освобождаем большой кусок данных, обнуляем `largeObjects`.

Важно знать, что `System.gc()` не запускает сборку мусора сразу - это просто подсказка для JVM, чтобы запустить процесс.

Цикл `for` демонстрирует, как убедиться, что все ссылки помещены в очередь - он распечатает `true` для каждой ссылки.

Наконец, мы использовали цикл `while` для опроса помещенных в очередь ссылок и выполнения работы по очистке для каждой из них.

## Полезные ссылки

[Understanding Weak References - Ethan Nicholas](https://web.archive.org/web/20061130103858/http://weblogs.java.net/blog/enicholas/archive/2006/05/understanding_w.html)

[Soft References - Baeldung](https://www.baeldung.com/java-soft-references)

[Weak References - Baeldung](https://www.baeldung.com/java-weak-reference)

[Phantom References - Baeldung](https://www.baeldung.com/java-phantom-reference)

[Lapsed Listener Problem](http://ilkinulas.github.io/development/general/2016/04/17/observer-pattern.html)
