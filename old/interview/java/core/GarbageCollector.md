# Garbage Collector

Сборщик мусора отслеживает каждый объект, доступный в пространстве кучи JVM, и удаляет неиспользуемые.

Проще говоря, `G`C работает в два простых шага, известных как `Mark` и `Sweep`:
- `Mark` - здесь сборщик мусора определяет, какие части памяти используются, а какие нет.
- `Sweep` - этот шаг удаляет объекты, идентифицированные на этапе «отметки».

## Процесс очистки

Автоматический сбор мусора - это процесс просмотра памяти кучи, определения, какие объекты используются, а какие нет, и удаления неиспользуемых объектов. 
Используемый объект или объект, на который имеется ссылка, означает, что некоторая часть вашей программы все еще поддерживает указатель на этот объект. 
На неиспользуемый объект или объект, на который нет ссылок, больше не ссылается какая-либо часть вашей программы. Таким образом, можно освободить память, 
используемую объектом, на который нет ссылки.

В таком языке программирования, как C, выделение и освобождение памяти выполняется вручную. В Java процесс освобождения памяти автоматически обрабатывается 
сборщиком мусора. Основной процесс можно описать следующим образом.

#### Шаг 1 - Marking

Первый шаг в этом процессе называется маркировкой. Здесь сборщик мусора определяет, какие части памяти используются, а какие нет.

![Screenshot](../../../resources/GC1.png)

Объекты, на которые есть ссылки, показаны синим цветом. Объекты, на которые нет ссылок, показаны золотым. Все объекты сканируются на этапе маркировки, чтобы
сделать это определение. Это может занять очень много времени, если необходимо сканировать все объекты в системе.

#### Шаг 2 - Normal Deletion

При обычном удалении удаляются объекты, на которые нет ссылок, а объекты, на которые есть ссылки, и указатели остаются на свободном месте.

![Screenshot](../../../resources/GC2.png)

Распределитель памяти содержит ссылки на блоки свободного пространства, где может быть размещен новый объект.

#### Шаг 2а - Deletion with Compacting

Для дальнейшего повышения производительности, помимо удаления объектов, на которые нет ссылок, вы также можете сжать оставшиеся объекты, на которые есть 
ссылки. Перемещение ссылочных объектов вместе значительно упрощает и ускоряет выделение новой памяти.

![Screenshot](../../../resources/GC3.png)

## Зачем нужны поколения?

Отмечать и уплотнять все объекты в JVM неэффективно. По мере того, как выделяется все больше и больше объектов, список объектов растет и увеличивается, 
что приводит к увеличению времени сборки мусора. Однако эмпирический анализ приложений показал, что большинство объектов недолговечны.

Вот пример таких данных. Ось`Y` показывает количество выделенных байтов, а доступ `X` показывает количество байтов, выделенных с течением времени.

![Screenshot](../../../resources/GC4.gif)

Как видите, со временем остается все меньше и меньше объектов. На самом деле у большинства объектов очень короткий срок службы, о чем свидетельствуют более 
высокие значения в левой части графика.

## Поколения в JVM

Информация, полученная из поведения распределения объектов, может использоваться для повышения производительности JVM. Поэтому куча разбивается на более 
мелкие части или поколения. Части кучи: молодое поколение, старое или постоянное поколение и постоянное поколение.

![Screenshot](../../../resources/GC5.png)

`Young Generation` - это то место, где размещаются и выдерживаются все новые объекты. Когда молодое поколение заполняется, это вызывает небольшую сборку 
мусора. Незначительные коллекции можно оптимизировать, предполагая высокий уровень смертности объектов. Молодое поколение, полное мертвых предметов, очищается
очень быстро. Некоторые уцелевшие объекты стареют и со временем переходят к старому поколению.

`Stop the World Event` - Все `второстепенные сборщики мусора(minor garbage collection)` являются событиями «`Stop the World`». Это означает, что все потоки 
приложения останавливаются до завершения операции. Незначительные сборщики мусора всегда являются событиями `Stop the World`.

`Old Generation` используется для хранения давно уцелевших объектов. Обычно порог устанавливается для объекта молодого поколения, и когда этот возраст 
достигается, объект перемещается в старое поколение. В конце концов нужно собрать старое поколение. Это событие называется `большой сборкой мусора 
(major garbage collection)`.

Крупная сборка мусора - это также события `Stop the World`. Часто большая очистка выполняется намного медленнее, потому что в нее входят все живые объекты.
Поэтому для отзывчивых приложений следует минимизировать сборку мусора. Также обратите внимание, что продолжительность события `Stop the World` для крупной 
сборки мусора зависит от типа сборщика мусора, который используется для пространства старого поколения.

`Permanent Generation` содержит метаданные, необходимые JVM для описания классов и методов, используемых в приложении. Постоянное поколение заполняется JVM 
во время выполнения на основе классов, используемых приложением. Кроме того, здесь могут храниться классы и методы библиотеки Java SE.

Классы могут быть очишены (выгружены), если JVM обнаружит, что они больше не нужны, и может потребоваться место для других классов. 
Постоянное поколение включено в `полную сборку мусора (full garbage collection)`.

## Что такое Stop the world

Когда поток сборщика мусора работает, другие потоки останавливаются, то есть приложение останавливается на мгновение. 

В зависимости от потребностей приложения сборка мусора «`Stop the world`» может вызвать недопустимое зависание. Вот почему важно выполнить настройку сборщика 
мусора и оптимизацию JVM, чтобы возникшее зависание было как минимум приемлемым.

## Преимущества и Недостатки

**Преимущества**
- Нет необходимости вручную выделять / освобождать память, поскольку неиспользуемое пространство памяти автоматически обрабатывается `GC`.
- Нет накладных расходов на обработку 
[Dangling Pointer](https://ru.wikipedia.org/wiki/%D0%92%D0%B8%D1%81%D1%8F%D1%87%D0%B8%D0%B9_%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C) (это
указатели, не указывающие на допустимый объект соответствующего типа. Это особый случай нарушения безопасности памяти.)
- Автоматическое управление утечками памяти (сам по себе сборщик мусора не может гарантировать полное решение проблемы утечки памяти, однако большую ее 
часть он устраняет)

**Недостатки:**
- Поскольку JVM должна отслеживать создание / удаление ссылки на объект, для этого действия требуется больше мощности ЦП, чем исходное приложение. 
Это может повлиять на производительность запросов, требующих большого объема памяти.
- Программисты не контролируют планирование времени ЦП, выделяемого на освобождение ненужных объектов.
- Использование некоторых реализаций `GC` может привести к непредсказуемой остановке приложения.
- Автоматизированное управление памятью не будет таким эффективным, как правильное выделение / освобождение памяти вручную.

## Как вызвать garbage collector?

`System.gc()`; или `Runtime.getRuntime().gc();`

## Почему не стоит вызывать garbage collector вручную?

- Это достаточно дорогая (ресурсоёмкая) задача
- Сборка мусора запускается не сразу - это просто подсказка для JVM запустить сборку мусора.
- JVM лучше знает, когда нужно вызвать GC

Если нам нужно принудительно использовать сборку мусора, мы можем использовать для этого jconsole.

## Реализации

Для лучшей стабильности приложения выбор правильного алгоритма сборки мусора имеет решающее значение.

`JVM` имеет четыре типа реализации `GC`:
- Serial Garbage Collector
- Parallel Garbage Collector
- CMS Garbage Collector
- G1 Garbage Collector

```java
-XX:+UseSerialGC
-XX:+UseParallelGC
-XX:+USeParNewGC
-XX:+UseG1GC
```

## GC Logging

Чтобы строго контролировать работоспособность приложения, мы всегда должны проверять производительность сборки мусора JVM. Самый простой способ сделать это 
- залогировать активность `GC` в удобочитаемом формате.

Используя следующие параметры, мы можем логировать активность `GC`:

```java
-XX:+UseGCLogFileRotation 
-XX:NumberOfGCLogFiles=< number of log files > 
-XX:GCLogFileSize=< file size >[ unit ]
-Xloggc:/path/to/gc.log
```

- `UseGCLogFileRotation` - определяет политику прокрутки файла журнала, как и `log4j`, `sl4j` и т. Д. 
- `NumberOfGCLogFiles` - обозначает максимальное количество файлов журнала, которые могут быть записаны за один жизненный цикл приложения. 
- `GCLogFileSize` - указывает максимальный размер файла. 
- `loggc` -  обозначает его местоположение.

Здесь следует отметить, что доступны еще два параметра JVM (`-XX: + PrintGCTimeStamps` и `-XX: + PrintGCDateStamps`), которые можно использовать для печати
отметки времени с указанием даты и времени в логах `GC`.

Например, если мы хотим назначить максимум `100` файлов журнала `GC`, каждый из которых имеет максимальный размер `50 МБ`, и хотим сохранить их в папке «`
/home/user/log/`», мы можем использовать следующий синтаксис:

```java
-XX:+UseGCLogFileRotation  
-XX:NumberOfGCLogFiles=10
-XX:GCLogFileSize=50M 
-Xloggc:/home/user/log/gc.log
```

Однако проблема в том, что один дополнительный `daemon` поток всегда используется для мониторинга системного времени в фоновом режиме. 
Такое поведение может создать узкое место в производительности; поэтому в продакшене с этим параметром всегда лучше не играть.

## Serial Garbage Collector

Это простейшая реализация `GC`, поскольку она в основном работает с одним потоком. В результате эта реализация `GC` замораживает все потоки приложения при
выполнении очистки. Следовательно, использовать его в многопоточных приложениях, таких как серверные среды, не рекомендуется.

Однако инженеры `Twitter` на `QCon 2012` подробно [обсудили](https://www.infoq.com/presentations/JVM-Performance-Tuning-twitter-QCon-London-2012/) 
производительность `Serial Garbage Collector`.

`Serial Garbage Collector` является предпочтительным сборщиком мусора для большинства приложений, которые не имеют небольших требований к времени паузы и 
работают на машинах клиентского типа. Чтобы включить последовательный сборщик мусора, мы можем использовать следующий аргумент:

```java
java -XX: + UseSerialGC -jar Application.java
```

## Parallel Garbage Collector

Это сборщик мусора по умолчанию `JVM`, иногда называемый сборщиками пропускной способности (`Throughput Collectors`). В отличие от `Serial Garbage Collector`,
он использует несколько потоков для управления пространством кучи. Но он также замораживает другие потоки приложения при выполнении `GC`.

Если мы используем этот сборщик мусора, мы можем указать максимальное количество потоков сборки мусора и время паузы, пропускную способность и размер 
(размер кучи).

Количество потоков сборщика мусора можно контролировать с помощью параметра командной строки `-XX: ParallelGCThreads = <N>`.

Максимальное целевое время паузы (промежуток в миллисекундах между двумя GC) указывается с помощью параметра командной строки `-XX: MaxGCPauseMillis = <N>`.

Целевая максимальная пропускная способность (измеряется относительно времени, затраченного на сборку мусора, по сравнению со временем, затраченным на сборку 
мусора), определяется параметром командной строки `-XX: GCTimeRatio = <N>`.

Максимальный размер кучи (объем памяти кучи, который требуется программе во время работы) указывается с помощью параметра `-Xmx <N>`.

Чтобы включить параллельный сборщик мусора, мы можем использовать следующий аргумент:

```java
java -XX: + UseParallelGC -jar Application.java
```

## CMS Garbage Collector

Реализация `Concurrent Mark Sweep (CMS)` использует несколько потоков сборщика мусора для сборки мусора. Он разработан для приложений, которые предпочитают 
более короткие паузы при сборке мусора и могут позволить себе совместно использовать ресурсы процессора с сборщиком мусора во время работы приложения.

Проще говоря, приложения, использующие этот тип сборки мусора, в среднем отвечают медленнее, но не перестают отвечать на сборку мусора.

Следует отметить, что, поскольку этот сборщик мусора является параллельным, вызов явной сборки мусора, такой как использование `System.gc()` во время работы 
параллельного процесса, приведет к сбою / прерыванию параллельного режима.

Если более `98%` общего времени тратится на сборку мусора `CMS` и восстанавливается менее `2%` кучи, сборщик `CMS` выдает ошибку `OutOfMemoryError`. 
При необходимости эту функцию можно отключить, добавив параметр `-XX: -UseGCOverheadLimit` в командную строку.

Этот сборщик также имеет режим, известный как инкрементный режим, который устарел в Java SE 8 и может быть удален в будущем основном выпуске.

Чтобы включить сборщик мусора `CMS`, мы можем использовать следующий флаг:

```java
java -XX:+UseParNewGC -jar Application.java
```

Начиная с `Java 9`, сборщик мусора `CMS` устарел. Поэтому `JVM` выводит предупреждающее сообщение, если мы пытаемся его использовать:

```java
>> java -XX:+UseConcMarkSweepGC --version
Java HotSpot(TM) 64-Bit Server VM warning: Option UseConcMarkSweepGC was deprecated 
in version 9.0 and will likely be removed in a future release.
java version "9.0.1"
```

Более того, `Java 14` **полностью отказалась от поддержки** `CMS`:

```java
>> java -XX:+UseConcMarkSweepGC --version
OpenJDK 64-Bit Server VM warning: Ignoring option UseConcMarkSweepGC; 
support was removed in 14.0
openjdk 14 2020-03-17
```

## G1 Garbage Collector

Сборщик мусора `G1 (Garbage First)` разработан для приложений, работающих на многопроцессорных машинах с большим объемом памяти. Он доступен, начиная с 
обновления 4 JDK7 и в более поздних выпусках.

Сборщик `G1` заменит сборщик `CMS`, поскольку он более эффективен.

В отличие от других сборщиков, сборщик `G1` разделяет кучу на набор областей кучи равного размера, каждая из которых представляет собой непрерывный диапазон 
виртуальной памяти. При выполнении сборок мусора `G1` показывает параллельную фазу глобальной маркировки (т. Е. Фазу 1, известную как маркировка), чтобы 
определить жизнеспособность объектов во всей куче.

После завершения фазы `mark` `G1` знает, какие области в основном пусты. Сначала он очищает в этих областях, что обычно дает значительный объем свободного
пространства (т. Е. Фаза 2, известная как уборка (`sweeping`)). Вот почему этот метод сборки мусора называется `Garbage-First`.

Чтобы включить сборщик мусора `G1`, мы можем использовать следующий аргумент:

```java
java -XX:+UseG1GC -jar Application.java
```

## Изменения в Java 8

В Java 8u20 появился еще один параметр `JVM` для уменьшения ненужного использования памяти за счет создания слишком большого количества экземпляров одной и 
той же `String`. Это оптимизирует память кучи, удаляя повторяющиеся строковые значения в один глобальный массив `char[]`.

Этот параметр можно включить, добавив `-XX: + UseStringDeduplication` в качестве параметра JVM.

## Полезные ссылки

[JVM Garbage Collectors - Baeldung](https://www.baeldung.com/jvm-garbage-collectors#3-cms-garbage-collector)

[Управление памятью - вопросы на интервью - Baeldung](https://www.baeldung.com/java-memory-management-interview-questions)

[The Most Important JVM Parameters - Baeldung](https://www.baeldung.com/jvm-parameters)

[Java Garbage Collection Basics - Oracle](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html)
