# Lambda (Лямбды)

Поддержка лямбда-выражений, реализованная в Java 8, стала одним из наиболее значимых нововведений за последнее время. 
Будучи упрощённой записью анонимных классов, лямбды позволяют писать более лаконичный код при работе со `Stream` или `Optional`.

**Лямбда-выражение** или просто лямбда в Java — **упрощённая запись анонимного класса, реализующего функциональный интерфейс**.

## Структура лямбда-выражения

Сигнатура лямбда-выражения соответствует сигнатуре абстрактного метода реализуемого функционального интерфейса. Можно даже сказать, что лямбда-выражение 
**является реализацией абстрактного метода этого функционального интерфейса**. Главное отличие сигнатуры лямбда-выражения от сигнатуры метода в том, 
что она состоит только из двух частей: списка аргументов и тела, разделённых при помощи «`->`». 
Возвращаемый тип и возможные выбрасываемые исключения JVM берёт из интерфейса.

Типы аргументов лямбда-выражения опциональны, так как они декларируются интерфейсом, но при использовании дженериков с `extends/super` может возникнуть 
необходимость в указании конкретных типов аргументов. При этом стоит отметить, что типы либо указываются для всех аргументов, либо не указываются вообще. 
Это же касается и использования `var`, введённой в Java 11. Всё это можно свести к такому правилу: **все аргументы объявляются либо с типами, либо с `var`, либо без них.**

Если у лямбда-выражения всего один аргумент, и для него не требуется объявление типа или `var`, то круглые скобки можно опустить. 
В остальных случаях, в том числе если лямбда не принимает никаких аргументов, скобки нельзя опустить.

Аналогичная ситуация и с телом лямбда-выражений: если оно состоит только из одной строки, то фигурные скобки, точку с запятой и директиву `return` можно тоже опустить.

В качестве тела лямбда-выражения может использоваться ссылка на метод.

## Создание лямбда-выражений

```java
@FunctionalInterface
public interface CarFilter {
    boolean test(Car car);
}
```

Допустим, нам нужна реализация `CarFilter`, которая проверяла бы, что автомобиль выпущен не раньше 2010 года. Если мы будем использовать анонимный класс, 
то создание объекта `CarFilter` будет выглядеть примерно следующим образом:

```java
CarFilter carFilter = new CarFilter() {
    public boolean test(Car car) {
        return car.getYear() >= 2010;
    }
};
```

Но мы можем описать объект `CarFilter` при помощи лямбда-выражения:

```java
CarFilter carFilter = (Car car) -> {
    return car.getYear() >= 2010;
};
```

Однако, эту запись можно сделать ещё меньше:

```java
CarFilter carFilter = car -> car.getYear() >= 2010;
// or JDK11+
var carFilter = (CarFilter) car -> car.getYear() >= 2010;
```

Согласитесь, что такая запись зачительно меньше и лаконичнее, чем использование анонимного класса.

## Применение лямбда-выражений

Допустим у нас есть задача написать метод, выводящий из полученного списка автомобили, у которых тип кузова (`body`) — `STATION_WAGON` 
и мощность (`power`) — больше 200 л.с.

Скорее всего, мы напишем что-то вроде:

```java
public static void printCars(List<Car> cars) {
    for(Car car : cars) {
        if (car.body == Car.Body.STATION_WAGON && car.power > 200) {
            System.out.println(car.toString());
        }
    }
}
```

В целом, если нам требуется всего один подобный метод, то этот код можно оставить без изменений и даже не задумываться об использовании лямбда-выражений. 
Но, допустим, у нас появляется задача реализовать ещё один метод, который бы выводил все автомобили, у которых кузов не `PICKUP_TRUCK`, или метод, 
который бы сохранял в БД все автомобили с мощностью двигателя более 150 л.с.

В этом случае логично было бы использовать сразу два функциональных интерфейса: `java.util.function.Predicate` — для фильтрации 
и `java.util.function.Consumer` — для действия, применяемого к подходящим объектам.

`java.util.function.Predicate` декларирует абстрактный метод `test`, который принимает объект и возвращает значение типа `boolean` в зависимости 
от соответствия переданного объекта требуемым критериям.

`java.util.function.Consumer` декларирует абстрактный метод `accept`, который принимает объект и выполняет над ним требуемые действия.

Метод `printCars()` превратится во что-то похожее на следующий метод:

```java
public static void processCars(List<Car> cars, Predicate<Car> predicate, Consumer<Car> consumer) {
    for(Car car : cars) {
        if (predicate.test(car)) {
            consumer.accept(car);
        }
    }
}
```

И первоначальную задачу вывести из полученного списка автомобили, у которых тип кузова (`body`) — `STATION_WAGON` и мощность (`power`) — больше 200 л.с. 
мы решили бы следующим вызовом метода `processCars()` с использованием лямбда-выражений:

```java
processCars(cars, // cars list
            car -> car.body == Car.Body.STATION_WAGON && car.power > 200, // predicate
            car -> System.out.println(car.toString())); // consumer
```

Или при помощи анонимных классов:

```java
processCars(cars, new Predicate<Car>() {
    @Override
    public boolean test(Car car) {
        return car.body == Car.Body.STATION_WAGON && car.power > 200;
    }
}, new Consumer<Car>() {
    @Override
    public void accept(Car car) {
        System.out.println(car.toString());
    }
});
```

Вариант вызова метода processCars с использованием лямбда-выражений значительно компактнее.

## Лямбды, анонимные классы и обычные классы

Как уже было написано, лямбда-выражения могут заменить анонимные классы, которые реализуют функциональные интерфейсы, но в остальных случаях анонимные 
классы не теряют актуальности.

Если одно и то же лямбда-выражение (или анонимный класс) используется в нескольких случаях, то появляется смысл сделать его членом класса или объекта, 
или и вовсе написать полноценный класс, реализующий необходимый интерфейс.

Но в большинстве случаев, там где можно применять лямбда-выражения, например в `Stream`, `Optional` или `ompletableFuture`, логичнее применять именно лямбды.

## Как отсортировать список строк используя лямбды?

```java
private void sortUsingJava8(List<String> names) {
  Collections.sort(names, (s1, s2) -> s1.compareTo(s2));
}
```

## К каким переменным есть доступ у лямбда выражений?

Лямбда-выражения имеют доступ к переменным области видимости, в которой их определили. Но доступ возможен только при условии, что переменные являются 
**effective final**, то есть либо явно имеют модификатор `final`, либо не меняют своего значения после инициализации, если переменной присваивается значение 
во второй раз, лямбда-выражение вызывает **ошибку компиляции**.

## Что такое ссылка на метод?

Ссылки на метод - **компактные лямбда-выражения** которые позволяют передавать ссылки на методы или конструкторы. Для этого нужно использовать 
языковую конструкцию "`::`". 

Ссылочные методы внедряют полезный синтаксис, чтобы ссылаться на существующие методы или конструкторы Java-классов или объектов (экземпляров). 
Совместно с лямбда-выражениями, ссылочные методы делают языковые конструкции компактными и лаконичными, делая его шаблонным.

**Виды ссылок на метод**
- На статический: `Strings::isBlank`
- На обычный метод класса: `User::getName` (`User` - класс)
- На метод конкретной сущности: `user::getName` (`user` - объект класса `User`)
- На конструктор: `User::new`

## Полезные ссылки

[Лямбда-выражения в Java - alexkosarev](https://alexkosarev.name/2019/03/11/lambdas-in-java/)
