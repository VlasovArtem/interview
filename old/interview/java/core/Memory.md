# Memory

Для оптимального запуска приложения JVM делит память на стек и кучу. Каждый раз, когда мы объявляем новые переменные и объекты, вызываем новый метод, 
объявляем `String` или выполняем аналогичные операции, JVM выделяет память для этих операций либо из памяти стека, либо из пространства кучи.

## Stack

Стек - это область оперативной памяти, которая создается для каждого потока. Он работает в порядке **LIFO** (Last In, First Out), 
то есть последний добавленный в стек кусок памяти будет первым в очереди на вывод из стека. Каждый раз, когда функция объявляет новую переменную, 
она добавляется в стек, а когда эта переменная пропадает из области видимости (например, когда функция заканчивается), она автоматически удаляется из стека.
Когда стековая переменная освобождается, эта область памяти становится доступной для других стековых переменных. Размер стековой памяти намного меньше объема 
памяти в куче.

Некоторые особенности стековой памяти:

- Он увеличивается и уменьшается по мере вызова и возврата новых методов соответственно.
- Переменные внутри стека существуют только до тех пор, пока работает метод, который их создал.
- Он автоматически выделяется и освобождается, когда метод завершает выполнение.
- Если эта память заполнена, Java выдает ошибку `java.lang.StackOverFlowError`.
- Доступ к этой памяти быстрый по сравнению с памятью кучи.
- Эта память является `потокобезопасной`, поскольку каждый поток работает в своем собственном стеке.

## Heap

**Java Heap (Куча)**  - динамически распределяемая область памяти, создаваемая при старте JVM. Используется Java Runtime для выделения памяти под объекты и 
JRE классы. Создание нового объекта также происходит в куче. Здесь работает сборщик мусора: освобождает память путем удаления объектов, на которые нет 
каких-либо ссылок.

Пространство кучи в Java используется для динамического выделения памяти для объектов Java и классов JRE во время выполнения. Новые объекты всегда создаются в
куче, а ссылки на эти объекты хранятся в стековой памяти.

Любой объект, созданный в куче, имеет глобальный доступ и на него могут ссылаться с любой части приложения.

Эта модель памяти разбита на более мелкие части, называемые поколениями, а именно:

- `Молодое поколение (Young Generation)` - здесь размещаются и выдерживаются все новые объекты. При заполнении происходит небольшая сборка мусора.
- `Старое или постоянное поколение (Old or Tenured Generation)` - здесь хранятся объекты долгожители. Когда объекты хранятся в молодом поколении, 
устанавливается порог возраста объекта, и когда этот порог достигается, объект перемещается в старое поколение.
- `Постоянное поколение (Permanent Generation)` - это метаданные JVM для классов времени выполнения и методов приложения.
Эти различные части также обсуждаются в этой статье - Различия между JVM, JRE и JDK.

Некоторые особенности кучи:

- Доступ к ней осуществляется с помощью сложных методов управления памятью, включая молодое поколение, старое или постоянное поколение.
- Если пространство кучи заполнено, Java выдает `java.lang.OutOfMemoryError`.
- Доступ к этой памяти относительно медленнее, чем к стековой памяти.
- Эта память, в отличие от стека, `автоматически не освобождается`. Сборщик мусора необходим для освобождения неиспользуемых объектов, чтобы сохранить 
эффективность использования памяти.
- В отличие от стека, куча `не является потокобезопасной` и ее необходимо защищать путем правильной синхронизации кода.

## Пример

Основываясь на том, что мы узнали до сих пор, давайте проанализируем простой код Java и оценим, как здесь управляется память:

```java
class Person {
    int id;
    String name;
 
    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }
}
 
public class PersonBuilder {
    private static Person buildPerson(int id, String name) {
        return new Person(id, name);
    }
 
    public static void main(String[] args) {
        int id = 23;
        String name = "John";
        Person person = null;
        person = buildPerson(id, name);
    }
}
```

Разберем это пошагово:

1. После входа в метод `main()` в стековой памяти будет создано пространство для хранения примитивов и ссылок этого метода.
- Примитивное значение `int id` будет храниться непосредственно в памяти стека.
- Ссылочная переменная `Person person` также будет создана в стековой памяти, которая будет указывать на фактический объект в куче.
2. Вызов параметризованного конструктора `Person(int, String)` из `main()` выделит дополнительную память поверх предыдущего стека. Там будет храниться:
- Ссылка на `this` объект вызывающего объекта в стековой памяти
- Примитивное значение `id` в стековой памяти
- Ссылочная переменная `String name`, которая будет указывать на фактическую строку из пула строк в памяти кучи
3. Дальше метод `main()` вызывает статический метод `buildPerson()`, для которого дальнейшее выделение будет происходить в стековой памяти поверх предыдущего 
стека. Это снова сохранит переменные, как описано выше.
4. Однако для вновь созданного объекта `Person person` все переменные экземпляра будут храниться в памяти кучи.

Это распределение поясняется на этой диаграмме:

![Screenshot](../../../resources/HeapStack.png)

## Сравнение

| Параметр | Стек | Куча |
|----------|------|------|
|Использование|стек используется только одним потоком выполнения программы|Куча используется всеми частями приложения|
|Размер|Стек имеет ограничения по размеру в зависимости от ОС и обычно меньше, чем куча|Размер кучи не ограничен|
|Что хранит|Сохраняет только примитивные переменные и ссылки на объекты, созданные в куче|Здесь хранятся все вновь созданные объекты|
|Порядок|Доступ к нему осуществляется с помощью системы распределения памяти `Last-in First-Out (LIFO)`|Доступ к этой памяти осуществляется с помощью сложных методов управления памятью, включая молодое поколение, старое или постоянное поколение|
|Жизненный цикл|Память стека существует только до тех пор, пока выполняется текущий метод|Пространство в куче существует, пока приложение работает|
|Эффективность|Cтековая память работает намного быстрее кучи|Работает медленно из-за объемов данных|
|Распределение|Эта память автоматически выделяется и освобождается при вызове и возврате метода соответственно|Пространство кучи выделяется при создании новых объектов и освобождается с помощью Gargabe Collector, когда на них больше нет ссылок|
|Доступность|Cтековая память не может быть доступна для других потоков|Объекты в куче доступны с любой точки программы|
|Переполнение|Если память стека полностью занята, то Java Runtime бросает **java.lang.StackOverflowError**|если память кучи заполнена, то бросается исключение **java.lang.OutOfMemoryError: Java Heap Space**|

## Управление кучей

Одна из наиболее распространенных практик, связанных с производительностью, - инициализация кучи памяти в соответствии с требованиями приложения.

Поэтому мы должны указать минимальный и максимальный размер кучи. Для этого можно использовать следующие параметры:

```java
-Xms<heap size>[unit] 
-Xmx<heap size>[unit]
```

Здесь `unit` обозначает единицу, в которой память (обозначенная размером кучи) должна быть инициализирована. `unit` могут быть отмечены как «`g`» для ГБ, 
«`m`» для МБ и «`k`» для КБ. Например, если мы хотим назначить JVM минимум `2 ГБ` и максимум `5 ГБ`, нам нужно написать:

```java
-Xms2G -Xmx5G
```

Начиная с Java 8 размер `Metaspace` не определен. Как только он достигает глобального предела, JVM автоматически увеличивает его, однако, чтобы преодолеть
любую ненужную нестабильность, мы можем установить размер `Metaspace` с помощью:

```java
-XX:MaxMetaspaceSize=<metaspace size>[unit]
```

Здесь `metaspace size` обозначает объем памяти, который мы хотим назначить метапространству.

Согласно рекомендациям Oracle, после общего объема доступной памяти вторым по значимости фактором является доля кучи, зарезервированная для молодого поколения.
По умолчанию минимальный размер `YG` составляет `1310 МБ`, а максимальный размер не ограничен. Мы можем назначить их явно:

```java
-XX:NewSize=<young size>[unit] 
-XX:MaxNewSize=<young size>[unit]
```
Также есть некоторые дополнительные конфигурации:

- `-XX:+UseStringDeduplication` - Java 8u20 ввел этот параметр JVM для уменьшения ненужного использования памяти за счет создания слишком большого количества 
экземпляров одной и той же `String`; это оптимизирует память кучи, уменьшая повторяющиеся значения `String` до одного глобального массива `char[]`
- `-XX:MaxHeapFreeRatio` - устанавливает максимальный процент свободной кучи после сборки мусора, чтобы избежать сжатия.
- `-XX:MinHeapFreeRatio` - устанавливает минимальный процент свободной кучи после сборки мусора, чтобы избежать расширения; для мониторинга использования кучи
вы можете использовать `VisualVM`, поставляемый с JDK.

## Handling out of Memory

В больших приложениях очень часто возникает ошибка нехватки памяти, которая, в свою очередь, приводит к сбою приложения. Это очень важный сценарий, 
и его очень сложно воспроизвести для устранения проблемы.

Вот почему JVM поставляется с некоторыми параметрами, которые выгружают память кучи в физический файл, который можно использовать позже для обнаружения утечек:

```java
-XX:+HeapDumpOnOutOfMemoryError 
-XX:HeapDumpPath=./java_pid<pid>.hprof
-XX:OnOutOfMemoryError="< cmd args >;< cmd args >" 
-XX:+UseGCOverheadLimit
```

Здесь следует отметить пару моментов:

- `HeapDumpOnOutOfMemoryError` говорит JVM сбрасывать кучу в физический файл в случае `OutOfMemoryError`.
- `HeapDumpPath` обозначает путь, по которому файл должен быть записан; можно указать любое имя файла; однако, если JVM находит тег `<pid>` в имени, 
идентификатор текущего процесса, вызывающего ошибку нехватки памяти, будет добавлен к имени файла в формате `.hprof`.
- `OnOutOfMemoryError` используется для выдачи аварийных команд, которые будут выполняться в случае ошибки нехватки памяти; требуемая команда должна 
использоваться в пространстве аргументов `cmd`. Например, если мы хотим перезапустить сервер, как только произойдет нехватка памяти, мы можем установить 
параметр:

```java
-XX: OnOutOfMemoryError = "shutdown -r"
```

- `UseGCOverheadLimit` - это политика, которая ограничивает долю времени виртуальной машины, которое тратится на сборку мусора, до того, как будет выдана 
ошибка `OutOfMemory`.

## Полезные ссылки

[Stack и Heap - Baeldung](https://www.baeldung.com/java-stack-heap)

[JVM параметры - Baeldung](https://www.baeldung.com/jvm-parameters)
