# Generics (Дженерики)

Дженерики (или обобщения) - это параметризованные типы.

**Зачем нужны?**
Чтобы проверять типы во время компиляции и устранить необходимость явного приведения.

## Raw types

Сначала вспомним, что такое raw type. В Java так называют generic-типы без указания типа-параметра (без использования diamond `<>` оператора). 
Такая языковая конструкция валидна, но в большинстве случаев приводит к предупреждению компилятора. 

Пример: `List<String> a = new ArrayList();`

Когда нужно использовать raw types?

Предупреждение связано с риском получения проблемы [heap pollution](#что-такое-heap-pollution). Использование raw types **никогда не оправдано** – 
спецификация языка явно говорит: их поддержка остается только для обратной совместимости.

Есть всего три случая, когда использовать обобщенный тип без параметра правильно:
- Целевая версия Java < 5.0 (2002 год и ранее – вряд ли это ваш случай);
- В литерале класса. `List<String>.class` не сработает, нужно писать `List.class`;
- В операторе `instanceof`. Вместо `instanceof Set<Integer>` должно быть `instanceof Set`.

## Как работает вывод типов? Type Inference

Для начала разберемся, что такое вывод типов. 
**Type inference** – это способность компилятора догадаться, какой тип нужно подставить, и сделать это за вас. 
На обычном интервью никто не спросит детали алгоритма вывода типов, достаточно будет сказать, что вывод происходит статически, 
только на основании типов аргументов и ожидаемого типа результата. По сути, вопрос заключается не в «как работает?», а «что это и когда возникает?».

Первое, что многим приходит в голову при фразе «вывод типов» – 
[**diamond** operator `<>`](https://stackoverflow.com/questions/4166966/what-is-the-point-of-the-diamond-operator-in-java-7). Он появился в Java с версии 7. 
Его применяют к конструкторам дженерик классов, чтобы отличать требование автоматического вывода типа от raw type.

С **Java 9** diamond operator заработал и для анонимных классов. Для дженерик методов можно указывать параметр явно, 
но diamond синтаксически недопустим – вывод и так сработает по умолчанию.

В **Java 10** для вывода типа локальной переменной добавлено ключевое слово `var`. Работает это так же, как в большинстве современных языков – 
ключевое слово ставится вместо типа при объявлении. Типы выводимых параметров лямбда-выражения также можно не указывать. 

С **Java 11** вместо типа указывается ключевое слово `var`. 
Такой синтаксис дает возможность добавлять параметру модификаторы и аннотации.

```java
<T> T gen(T param) {}

gen(1); // T = Integer
this.<Object>gen(2); // T = Object
Number number = gen(3); // T = Number

List<String> a = new ArrayList(); // Тип непредсказуем
List<?> b = new ArrayList<String>; // Тип неважен
List<String> c = new ArrayList<>(); // Тип очевиден

Supplier<String> supplier = new Supplier<>() {
  @Override
  public String get() { 
    return "Так работает с Java 9";
  }
}

var strVar = "А это с Java 10"; // Переменная strVar имеет тип String
int transformed = strVar.transform(
  (@NonNull final var s) -> s.hashCode();
); // Java 11
```

## Как инстанцировать экземпляр generic типа?

Внутри класса `class Foo<T>` на generic параметре `T` невозможно выполнить никакой оператор: нельзя взять его `.class`, нельзя применить его в `instanceof`. 
Также и вызов на нем оператора `new` приведет к ошибке.

Причина этих ограничений кроется в стирании типов. Дженерик параметры правильно воспринимать скорее как ограничения типов, чем как конкретные типы. 
Эти ограничения действуют для более строгих проверок на этапе компиляции. В рантайме же информация о конкретных переданных типах-параметрах стирается. 
А все эти операторы выполняются именно в рантайме.

Стандартный простой способ действия здесь – кроме значения типа `T` передавать еще и объект-дескриптор для этого типа, экземпляр класса `Class<T>`. 
Объект может быть создан из дескриптора рефлекшеном.

Но существует один хак, способный справиться со стиранием типов. Тип-параметр все-таки остается в одном месте в рантайме. 
Метод метакласса наследника определившего конкретный тип `getGenericSuperclass()` возвращает класс, которым параметризован родитель. 

```java
class Bar {}

class Foo<T> {
  
  T instantiateWithHack() throws Exception {
    Type genericSuperclass = getClass().getGenericSuperclass();
    ParametrizedType superType = (ParametrizedType) genericSuperclass;
    Class<T> clazz = (Class<T>) superType.getActualTypeArguments()[0];
    return clazz.newInstance();
  }

  T instantiateWithMetaclass(Class<T> clazz) throws Exception {
    // clazz придется передавать вручную
    // но компилятор позволить передать только то, единственно правильно решение
    return clazz.newInstance();
  }

}

// использование
new Foo<Bar>(){}.instantiateWithHack();
new Foo<Bar>().instantiateWithMetaclass(Bar.class);
```

## Что такое ковариантность и контравариантность?

Формально, ковариантность/контравариантность типов – это сохранение/обращение порядка наследования для производных типов. 
Проще говоря, когда у ковариантных сущностей типами-параметрами являются родитель и наследник, они сами становятся как бы родителем и наследником. 
Контравариантные наоборот, становятся наследником и родителем.

Легче всего осознать эти понятия на примерах:
- **Ковариантность**: `List<Integer>` можно присвоить в переменную типа `List<? extends Number>` (как будто он наследник `List<Number>`).
- **Контравариантность**: в качестве параметра метода `List<Number>#sort` типа `Comparator<? super Number>` может быть передан `Comparator<Object> `
(как будто он родитель `Comparator<Number>`)

Отношение типов «можно присвоить» – не совсем наследование, такие типы называются совместимыми (отношение «is a»).

Существует еще одно связанное понятие – инвариантность. **Инвариантность** – это отсутствие свойств ковариантности и контрвариантности. 
Дженерики без вайлдкардов **инвариантны**: `List<Number>` нельзя положить ни в переменную типа `List<Double>`, ни в `List<Object>`.

Массивы **ковариантны**: в переменную `Object[]` можно присвоить значение типа `String[]`.

Переопределение методов начиная с Java 5 ковариантно относительно типа результата и типов исключений.

```java
class Parent {
  public Number run(String s) {}
}

class Child extends Parent {
  // В типе наследнике используются типы наследники - КОвариантность
  @Override
  public Integer run(String s) {} 
}
```

## Что такое стирание типов (Type Erasure)

Компилятор удаляет из байткода класс-файла информацию о типах-дженериках. Этот процесс и называется стирание типов (type erasure). 
Он появился в Java 5 вместе с самими дженериками. Такое решение позволило сохранить обратную совместимость без перекомпилляции кода Java 4.

Стирание состоит из трех действий:
- Если параметры ограничены (bounded), вместо типа-параметра в местах использования подставляется верхняя граница, иначе `Object`;
- В местах присвоения значения типа-параметра в переменную обычного типа добавляется каст к этому типу;
- Генерируются [bridge-методы](#bridge-методы).

Информация о типах стирается только из методов и полей, но остается в метаинформации самого класса. 
Получить эту информацию в рантайме можно с помощью рефлекшна, методом `Field#getGenericType`.

Тип со стертой информацией о дженериках называется **Non-reifiable**.

Стирание типов позволяет не создавать при применении дженериков новые классы, в отличие от, например, шаблонов C++.

До Type Erasure
```java
public class Person<T> {
  public int compareTo(T o) {
    return 0;
  }
}
```

После Type Erasure
```java
public class Person {
  public int compareTo(Object o) {
    return 0;
  }
}
```

## Bridge методы

В Java отсутствует ковариантность переопределенных методов по параметрам – их типы должны совпадать с типами параметров метода в родительском классе. 
Когда дженерик параметр конкретизируется в наследнике, методы с аргументами этого дженерик типа больше не совпадают в байткоде – в наследнике тип конкретный, 
а в родителе стертый до верхней границы.

Проблема решается простым и безопасным кастом. Компилятор генерирует новый метод, который совпадает по сигнатуре с родительским. 
В его теле параметр кастуется и вызов делегируется в пользовательский метод. Это и называется bridge методом.

Bridge method можно увидеть с помощью рефлекшна. Его имя совпадает с оригинальным методом, но параметр имеет тип, в который сотрется дженерик родителя. 
Этот метод будет помечен флагом synthetic, что значит, что он написан не программистом а компилятором.

Попытка написать такой же метод вручную приведет к ошибке компиляции. 

До Type Erasure
```java
public class Person implements Comparable<Person> {
  @Override
  public int compareTo(Person o) {
    return 0;
  }
}
```

После Type Erasure
```java
public interface Comparable {
  public int compareTo(Object o);
}

public class Person implements Comparable {

  @Override
  public int compareTo(Person o) {
    return 0;
  }
  
  // Этот Bridge метод добавлен компилятором.
  public int compareTo(Object o) {
    return compareTo((Person) o);
  }
  
}
```

[Подробнее о стирании типов с примерами](https://www.baeldung.com/java-type-erasure)

## Можно ли выбрасывать исключение generic-типа?

Короткий ответ – да. Как в большинстве каверзных вопросов про дженерики, ответ становится очевидным если подумать, во что сотрутся типы-параметры.

Чтобы объявить, что метод выбрасывает исключение обобщенного типа `T`, этот тип `T` должен быть объявлен расширяющим `Throwable`. 
Именно в `Throwable` в таком случае сотрется `T` при компиляции. Также в качестве типа-верхней границы можно использовать любого наследника `Throwable`:

```java
class MyClass<T extends IOException> {
    void foo() throws T {
         // ...
    }
}
```

## Дженерики в исключениях – что можно, а что нельзя?

- Можно выбрасывать исключение generic-типа.
Тип-параметр `T` может использоваться в `throws`, переменная типа `T` может использоваться в `throw`.
- Можно реализовывать исключением generic-интерфейс.
Исключение вполне может быть например `Comparable` или `Iterable`. Механизм обработки исключений работает на классах, никак не затрагивая интерфейсы.
- Нельзя использовать дженерик в `catch`.
Множественные блоки `catch` должны идти без повторений, в определенном порядке – от специфичного класса к более базовому. 
Стирание типов-параметров в связи с этими правилами добавило бы путаницу, не неся особой пользы.
- Нельзя параметризовать класс-исключение типами.
Если вы попытаетесь скомпилировать конструкцию вида `class MyException<T> extends Throwable {}`, 
то увидете ошибку `generic class may not extend java.lang.Throwable`.

## Как ограничить upcasting типа-параметра?

Задача: запретить этому методу принимать параметры разных типов. `<T> void pair(T a, T b) {}`

То есть, нужно разрешить вызывать `pair(Foo, Foo)`, но запретить `pair(Foo, Bar)`.

**Upcasting** – приведение к типу-родителю. `String → Object`, `Integer → Number`.

Дело в том, что у любых двух классов есть общий предок: как минимум `Object`. 
Если вызвать этот метод с параметрами `String` и `Boolean` – согласно правилам вычисления типа-границы, параметр `T` будет стерт в `Object`.

Использовать `super` тоже не поможет: для этого нужно знать заранее, какой именно тип будет передаваться.

Фокус в том, что на этапе компиляции это невозможно. Объект любого типа всегда является объектом типа-родителя (отношение `is a`). 
Это фундаментальное правило ООП, которое невозможно нарушить. К тому же, подобный метод нарушал бы принцип подстановки Лисков.

Единственная возможность добиться желаемого поведения – с помощью `getClass()` сравнивать классы объектов в рантайме.

## Что такое heap pollution?

Как было сказано ранее, массивы в Java ковариантны. А значит, можно обратиться к объекту типа `String[]` через переменную типа `Object[]`, 
и положить туда например `Integer`. Такой код скомпилируется, но в момент записи произойдет `ArrayStoreException`.

Дженерики защищены инвариантностью. Если попытаться положить `List<Object>` в `List<String>`, эта же по сути ошибка произойдет уже на этапе компиляции.

**Heap pollution** – ситуация, когда эта защита не срабатывает, и переменная параметризованного типа хранит в себе объект, 
параметризованный другим типом. Простейший пример:

```java
public class HeapPollutionDemo
{
   public static void main(String[] args)
   {
      Set s = new TreeSet<Integer>();
      Set<String> ss = s;            // unchecked warning
      s.add(new Integer(42));        // another unchecked warning
      Iterator<String> iter = ss.iterator();
      while (iter.hasNext())
      {
         String str = iter.next();   // ClassCastException thrown
         System.out.println(str);
      }
   }
}
```

Heap pollution может произойти в двух случаях: 
- при использовании массивов дженериков 
- при смешивании параметризованных и raw-типов.

Пример с raw types, приводящий к heap pollution, уже был описан выше:
`List<String> strings = (List) new ArrayList<Integer>();`

Компилятор не даст создать массив параметризованного типа, это приведет к ошибке **generic array creation**. 
Код ниже иллюстрирует, к чему это могло бы привести.

```java
List<String>[] strings = new List<String>[42]; // generic array creation
Object[] stringsAsObjects = strings; // Благодаря ковариантности массивов это можно было бы сделать
stringsAsObjects[0] = new ArrayList<Number>(); // И здесь мы бы получили heap pollution

List<?>[] objects = new List<?>[42]; // Это единственный безопасный вариант дженерик массива
```

Параметризованный тип `varargs`-аргумента метода вызывает ту же проблему, т.к. `arargs` – не что иное как параметр-массив. 
Вот почему он так же приводит к предупреждению компилятора «possible heap pollution». 
Если вы уверены что риска нет, с Java 7 это предупреждение заглушается аннотацией `@SafeVarargs`.

## Как ограничивается тип generic параметра? (Bound)

В объявлении дженерик-параметра класса или метода может быть указана его верхняя граница (**bound**): `class Foo<T extends Number>`
  
Ключевое слово `extends` применяется как для классов, так и для интерфейсов. 
Фактическим параметром такого класса `Foo` может быть или сам `Number`, или его наследники.

Помимо ограничения возможных применяемых типов, bounded-параметр дает право использовать в реализации методы и поля типа-ограничителя – 
он будет как минимум предком фактического типа. Это достигается стиранием типа-параметра до верхней границы.

Тип-параметр может иметь **несколько верхних границ**, то есть границу-пересечение типов: `<T extends Comparable & Serializable>`. 
Стирание произойдет до первой из границ, остальные послужат только ограничением вариантов фактического типа. 
Поэтому граница-класс, при наличии, должна быть указана раньше границ-интерфейсов.

## Wildcard

При указании значения дженерик-параметра переменной может быть использован **wildcard** – символ `?`. Вайлдкард значит, что мы не собираемся 
использовать информацию о конкретном типе, этот тип может быть любым. 

**Это не то же самое, что не указать дженерик параметр совсем.**

Для вайлдкарда также как и для объявления типа-параметра можно обозначить верхнюю границу. 
Но в отличие от объявления, здесь нельзя использовать пересечение типов, по крайней мере 
[пока](https://stackoverflow.com/questions/6643241/why-cant-you-have-multiple-interfaces-in-a-bounded-wildcard-generic/6645454#6645454).

Кроме того, в случае вайлдкарда можно задать нижнюю границу: `Foo<? super Number> foo;`
Означает, что мы не будем использовать информацию о конкретном типе, но будем знать что это предок класса Number. То есть или сам `Number`, или `Object`.

В объявлении класса или метода использование super запрещено, так как 
[не имеет смысла](https://stackoverflow.com/questions/37411256/why-super-keyword-in-generics-is-not-allowed-at-class-level/37411519#37411519).

Лучше разобраться в механике использования ограниченных вайлдкардов поможет это 
[видео](https://www.youtube.com/watch?v=_0c9Fd9FacU&feature=youtu.be&t=1204&ab_channel=JUG.ru).

## PECS 

Хороший API должен уметь эффективно работать с классами-наследниками, то есть быть ко- или контравариантным где это необходимо. 
При этом без bounded вайлдкардов не обойтись. Чтобы запомнить, какая граница нужна в каких случаях, Joshua Bloch предложил мнемонику
[PECS: Producer-extends, Consumer-super.](https://stackoverflow.com/questions/2723397/what-is-pecs-producer-extends-consumer-super)

If a parametrized type represents a `T` producer, use `<? extends T>`

If a parametrized type represents a `T` consumer, use `<? super T>`

Пример:

```java
public static <T> T max(Collection<? extends T> coll, Comparator<? super T> comp)
```

В данном примере коллекция является продюсером элементов, потому что из неё мы получаем элементы.

Компаратор же забирает элементы, поэтому он консьюмер.

Вот какую гибкость мы получаем:

```java
Collections.max(List<Integer>, Comparator<Number>);
Collections.max(List<String>, Comparator<Object>);
```

## Поиграем с дженериками

#### Что можно добавить в `List<? extends Number> numbers = new ArrayList<>()`

Казалось бы, всё, что наследуется от `Number`: `Number`, `Long`, `Integer`, `Double`... Но нет. 

Что видит компилятор? Компилятор всегда видит только левую часть выражения: `List<? extends Number> numbers = ???`. 

Что в него можно присвоить? Присвоить можно всё, что параметризовано `List<? extends Number>`. 
Важный момент - в этот лист нельзя добавить `<? extends Number?`, этот лист можно присвоить чему-то, что будет параметризировано как `? extends Number`.
```java
List<? extends Number> numbers = new ArrayList<Number>();
List<? extends Number> numbers = new ArrayList<Long>();
List<? extends Number> numbers = new ArrayList<Integer>();
```

И вот пример
```java
public void process(List<? extends Number> numbers) {
  numbers.add(234L); // не сработает
  numbers.add(null); // сработает
}
```

В примере мы пытаемся положить в лист тип `Long`. Такое добавление будет безопасно только для листов `List<Number>` и `List<Long>`

Компилятор не знает, чем на самом деле параметризован `List`, который прийдет в метод `process`, поэтому безопасно можно добавть **только null** 

#### Что можно добавить в `List<? super Number> numbers = new ArrayList<>()`

Казалось бы: `Object` и `Number`. Да, можно `Number`, но `Object` нельзя.  

На самом деле можно добавить: `? extends Number`, `Number`, `Double`, `Integer`, `null`

Что видит компилятор? Компилятор всегда видит только левую часть выражения: `List<? super Number> numbers = ???`. \

Что в него можно присвоить?
```java
List<? super Number> numbers = new ArrayList<Object>();
List<? super Number> numbers = new ArrayList<Number>();
```

И вот пример
```java
public void process(List<? super Number> numbers) {
  numbers.add(234L); // сработает
  numbers.add(100D); // сработает
  numbers.add(null); // сработает
  numbers.add(new Object()); // НЕ сработает
}
```

В примере мы пытаемся положить в лист тип `Object`. Такое добавление будет безопасно только для листов пераметризированных как `List<Object>`, 
но не `List<Number>`.

#### Отличается ли `List<?>` от `List<? extends Object>?`

Все классы без исключения наследуются от `Object`. Поэтому неограниченный wildcard `<?>` всегда подразумевает его в качестве верхней границы. 
Оба этих типа в рантайме сотрутся в `List<Object>`, функциональных отличий нет.

Не смотря на одинаковое поведение, существует одно синтаксическое различие. 
Неограниченный дженерик – **reifiable** тип. Это значит, что он представлен в рантайме. 
Такой тип можно использовать в операторе `instanceof`, тогда как синтаксическая конструкция `x instanceof List<? extends Object>` приведет к ошибке компиляции.

Тип `List` без параметра имеет больше отличий, мы уже говорили о них ранее, в разделах про [raw types](#raw-types) и 
проблему [heap pollution](#что-такое-heap-pollution).
## Полезные ссылки

[Введение в дженерики - Baeldung](https://www.baeldung.com/java-generics)

[Неочевидные дженерики - YouTube](https://youtu.be/_0c9Fd9FacU)

[Зачем нужен diamond оператор - Stackoverflow](https://stackoverflow.com/questions/4166966/what-is-the-point-of-the-diamond-operator-in-java-7)

[Heap pollution - Wiki](https://en.wikipedia.org/wiki/Heap_pollution)

[Подробнее о стирании типов с примерами - Baeldung](https://www.baeldung.com/java-type-erasure)

[Почему нельзя иметь несколько интерфейсов в wildcard - Stackoverflow](https://stackoverflow.com/questions/6643241/why-cant-you-have-multiple-interfaces-in-a-bounded-wildcard-generic/6645454#6645454).

[PECS: Producer-extends, Consumer-super. - Stackoverflow](https://stackoverflow.com/questions/2723397/what-is-pecs-producer-extends-consumer-super)

[Java interview review - Telegram](https://t.me/JavaSobes)
