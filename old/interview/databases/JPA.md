# JPA

`Java Persistence API (JPA)` - это спецификация Java, которая используется для сохранения данных между объектом Java и реляционной базой данных. JPA действует как 
мост между объектно-ориентированными моделями предметной области и системами реляционных баз данных. Поскольку `JPA` - это просто спецификация, он не выполняет
никаких операций сам по себе. Это требует реализации. Следовательно, инструменты `ORM`, такие как `Hibernate`, `TopLink` и `iBatis`, реализуют спецификации `JPA` 
для сохранения данных. Первая версия `JPA 1.0`, была выпущена в 2006 году как часть спецификации `EJB 3.0`.

## Выполняет ли JPA задачу, такую как доступ, сохранение и управление данными?

Нет, `JPA` - это всего лишь спецификация. Инструменты `ORM`, такие как `Hibernate`, `iBatis` и `TopLink`, реализуют спецификацию `JPA` и выполняют такие задачи.

## Что такое оobject-relational mapping?

`Object-relational mapping` - это механизм, который используется для разработки и поддержания связи между объектом и реляционной базой данных путем отображения
состояния объекта в столбец базы данных. Он преобразует атрибуты программного кода в столбцы таблицы. Он способен легко обрабатывать различные операции с базой
данных, такие как вставка, обновление, удаление и тд.

![Screenshot](../../resources/ORM.png)

## Преимущества JPA

- Меньше взаимодействия с базой данных.
- Стоимость создания файла конфигураций снижается за счет использования аннотаций.
- Мы можем объединить приложения, используемые с другими поставщиками JPA.
- Использование различных реализаций может добавить функции к стандартной реализации, которая позже может стать частью спецификации JPA.

## Что такое встраиваемые классы?

Встраиваемые классы представляют состояние объекта, но не имеют собственного постоянного идентификатора. Объекты таких классов разделяют идентичность классов 
сущностей, которым они принадлежат. Сущность может иметь однозначные или многозначные атрибуты встраиваемого класса.

## Что такое JPQL?

`Java Persistent Query Language (JPQL)` является частью спецификации `JPA`, которая определяет поиск по сущностям. Это объектно-ориентированный язык запросов, 
который используется для выполнения операций базы данных с `persistent` объектами. Вместо таблицы базы данных `JPQL` использует объектную модель сущности для 
обработки запросов `SQL`. Здесь роль `JPA` заключается в преобразовании `JPQL` в `SQL`. Таким образом, он предоставляет разработчикам простую платформу для решения
задач `SQL`. `JPQL` - это расширение языка запросов `Entity JavaBeans (EJBQL)`.

## Что такое orphal removing?

Если целевая сущность в сопоставлении «один-к-одному» или «один-ко-многим» удаляется из сопоставления, тогда операция удаления может быть передана каскадно целевой
сущности. Такие целевые объекты называются `orphans (сиротами)`, и атрибут `orphanRemoval` может использоваться для указания того, что объекты `orphans (сироты)`
должны быть удалены.

## Объясните жизненный цикл персистентности объекта

В жизненном цикле персистентности объект находится в следующих состояниях:

- `Transient` - объект находится в состоянии `transient`, когда он только объявлен с использованием ключевого слова `new`. Когда объект остается в `transient` 
состоянии, он не содержит идентификатора (первичного ключа) в базе данных.
- `Persistent` - в этом состоянии объект связан с сессией и либо только сохранился в базу данных, либо был извлечен из неё. Когда объект остается в состоянии 
`persistent`, он содержит строку базы данных и значение идентификатора. Мы можем сделать объект постоянным, связав его с `сессией hibernate`. Изменения, внесенные 
в `persistent` объекты, отображаются на объекте в базе данных.
- `Detached` - объект переходит в `detached` состояние при закрытии `сессии hibernate`. Изменения, внесенные в `detached` объекты, не отображаются на объекте в 
базе данных.

## Что такое Entity?

`Entity` это легковесный хранимый объект бизнес логики (`persistent domain object`). Основная программная сущность это `entity` класс, который так же может
использовать дополнительные классы, который могут использоваться как вспомогательные классы или для сохранения состояния `еntity`.

## Может ли Entity класс наследоваться от не Entity классов (non-entity classes)?

Может

## Может ли Entity класс наследоваться от других Entity классов

Может

## Может ли не Entity класс наследоваться от Entity класса

Может

## Может ли Entity быть абстрактным классом

Может, при этом он сохраняет все свойства Entity, за исключением того что его нельзя непосредственно инициализировать.

## Какие существуют ограничения на класс Entity?

Класс сущности должен соответствовать следующим требованиям:

- У класса должен быть конструктор без аргументов.
- Класс не может быть `final`.
- Класс должен быть аннотирован аннотацией `@Entity`.
- Класс не может содержать финальные поля или методы, если они участвуют в маппинге (persistent final methods or persistent final instance variables).
- Если объект класса будет передаваться по значению как отдельный объект (`detached object`), например через удаленный интерфейс, он так же должен реализовывать 
`Serializable` интерфейс.
- Класс должен содержать первичный ключ, то есть атрибут или группу атрибутов которые уникально определяют запись этого Enity класса в базе данных,

## Что произойдет, если будет отсутствовать конструктор без аргументов у Entity Bean?

Hibernate использует рефлексию для создания экземпляров `Entity` бинов при вызове методов `get()` или `load()`. Для этого используется метод `Class.newInstance()`, 
который требует наличия конструктора без параметров. Поэтому, в случае его отсутствия, вы получите ошибку `HibernateException`.

## Почему мы не должны делать Entity class как final?

Хибернейт использует прокси классы для ленивой загрузки данных (т.е. по необходимости, а не сразу). Это достигается с помощью расширения `entity bean` и, 
следовательно, если бы он был `final`, то это было бы невозможно. Ленивая загрузка данных во многих случаях повышает производительность, а следовательно важна.

## Что такое EntityManager и какие основные его функции вы можете перечислить? 

`EntityManager` это интерфейс, который описывает `API` для всех основных операций над `Enitity`, получение данных и других сущностей `JPA`. По сути главный `API`
для работы с JPA. Основные операции:

1. Для операций над `Entity`: 
- `persist` (добавление `Entity` под управление `JPA`)
- `merge` (обновление) 
- `remove` (удаления)
- `refresh` (обновление данных)
- `detach` (удаление из управление `JPA`)
- `lock` (блокирование `Enity` от изменений в других `thread`)
2) Получение данных: `find` (поиск и получение `Entity`), `createQuery`, `createNamedQuery`, `createNativeQuery`, `contains`, `createNamedStoredProcedureQuery`
3) Получение других сущностей `JPA`: `getTransaction`, `getEntityManagerFactory`, `getCriteriaBuilder`, `getMetamodel`, `getDelegate`
4) Работа с `EntityGraph`: `createEntityGraph`, `getEntityGraph`
4) Общие операции над `EntityManager` или всеми `Entities`: `close`, `isOpen`, `getProperties`, `setProperty`, `clear`

## Какие четыре статуса жизненного цикла Entity объекта (Entity Instance’s Life Cycle) вы можите перечислить? 

У `Entity` объекта существует четыре статуса жизненного цикла:
- `new` — объект создан, но при этом ещё не имеет сгенерированных первичных ключей и пока ещё не сохранен в базе данных
- `managed` — объект создан, управляется `JPA`, имеет сгенерированные первичные ключи
- `detached` — объект был создан, но не управляется (или больше не управляется) `JPA`
- `removed` — объект создан, управляется `JPA`, но будет удален после commit'a транзакции

## Как влияет операция persist на Entity объекты каждого из четырех статусов? 

- Если статус `Entity` `new`, то он меняется на managed и объект будет сохранен в базу при `commit`'е транзакции или в результате `flush` операци 
- Если статус уже `managed`, операция игнорируется, однако зависимые `Entity` могут поменять статус на `managed`, если у них есть аннотации каскадных изменений
- Если статус `removed`, то он меняется на `managed`
- Если статус `detached`, будет выкинут `exception` сразу или на этапе `commit`'а транзакции

## Как влияет операция remove на Entity объекты каждого из четырех статусов? 

- Если статус `Entity` `new`, операция игнорируется, однако зависимые `Entity` могут поменять статус на `removed`, если у них есть аннотации каскадных изменений и 
они имели статус `managed` 
- Если статус `managed`, то статус меняется на `removed` и запись объект в базе данных будет удалена при `commit`'е транзакции (так же произойдут операции `remove` 
для всех каскадно зависимых объектов)
- Если статус `removed`, то операция игнорируется
- Если статус `detached`, будет выкинут `exception` сразу или на этапе `commit`'а транзакции

## Как влияет операция merge на Entity объекты каждого из четырех статусов? 

- Если статус `Entity new`, то будет создана новый `managed entity`, в который будут скопированы данные прошлого объекта
- Если статус `managed`, операция игнорируется, однако операция `merge` сработает на каскадно зависимые `Entity`, если их статус не `managed`
- Если статус `removed`, будет выкинут `exception` сразу или на этапе `commit`'а транзакции
- Если статус `detached`, то либо данные будет скопированы в существующей `managed entity` с тем же первичным ключом, либо создан новый `managed` в который 
скопируются данные

## Как влияет операция refresh на Entity объекты каждого из четырех статусов? 

- Если статус `Entity managed`, то в результате операции будут востановлены все изменения из базы данных данного `Entity`, так же произойдет `refresh` всех 
каскадно зависимых объектов
- Если статус `new`, `removed` или `detached`, будет выкинут `exception`

## Как влияет операция detach на Entity объекты каждого из четырех статусов? 

- Если статус `Entity` `managed` или `removed`, то в результате операции статус `Entity` (и всех каскадно-зависимых объектов) станет `detached`
- Если статус `new` или `detached`, то операция игнорируется

## Какова цель каскадных операций в JPA?

Если мы применим какое-либо действие к одной сущности, тогдаи при использовании каскадных операций, мы сделаем ее применимой и к связанным с ней сущностям.

## Какие типы каскадов поддерживает JPA?

- `PERSIST`: в этой каскадной операции, если родительский объект сохраняется, то все связанные с ним объекты также будут сохранены.
- `MERGE`: в этой каскадной операции, если родительский объект объединяется, то все связанные объекты также будут объединены.
- `DETACH`: в этой каскадной операции, если родительский объект отсоединен, то все связанные с ним объекты также будут отсоединены.
- `REFRESH`: в этой каскадной операции, если родительский объект обновляется, то все связанные с ним объекты также будут обновлены.
- `DELETE`: в этой каскадной операции, если родительский объект удален, то все связанные с ним объекты также будут удалены.
- `ALL`: В этом случае все вышеупомянутые каскадные операции могут применяться к объектам, связанным с родительским объектом.

## Что такое Criteria API?

`Criteria API` - это спецификация, которая предоставляет безопасные по типу и переносимые запросы критериев, написанные с использованием `API` Java. Это один из
наиболее распространенных способов построения запросов для сущностей. Это просто альтернативный метод определения запросов `JPA`. `Criteria API` определяет 
платформенно-независимые критерии запросов, написанные на языке программирования `Java`. Он был представлен в `JPA 2.0`. Основная цель - предоставить 
безопасный для типов способ выражения запроса.

##  Что такое встраиваемый (Embeddable) класс? 

`Embeddable` класс это класс который не используется сам по себе, только как часть одного или нескольких `Entity` классов. `Entity` классы могут содержать как
одиночные встраиваемые классы, так и коллекции таких классов. Также такие классы могут быть использованы как ключи или значения `map`. Во время выполнения каждый
встраиваемый класс принадлежит только одному объекту `Entity` класса и не может быть использован для передачи данных между объектами `Entity` классов (то есть
такой класс не является общей структурой данных для разных объектов). В целом, такой класс служит для того чтобы выносить определение общих атрибутов для
нескольких `Entity`, можно считать что `JPA` просто встраивает в `Entity` вместо объекта такого класса те атрибуты, которые он содержит.

## Может ли встраиваемый (Embeddable) класс содержать другой встраиваемый (Embeddable) класс?

Да

## Какие требования JPA устанавливает к встраиваемым (Embeddable) классам? 

- Такие классы должны удовлетворять тем же правилам что `Entity` классы, за исключением того что они не обязаны содержать первичный ключ и быть отмечены аннотацией 
`Entity`
- `Embeddable` класс должен быть отмечен аннотацией `@Embeddable` или описан в `XML` файле конфигурации `JPA`

## Какие типы связей (relationship) между Entity вы знаете? 

Существуют следующие четыре типа связей:

1. `OneToOne` (связь один к одному, то есть один объект `Entity` может связан не больше чем с один объектом другого `Entity`)
2. `OneToMany` (связь один ко многим, один объект `Entity` может быть связан с целой коллекцией других `Entity`)
3. `ManyToOne` (связь многие к одному, обратная связь для `OneToMany`)
4. `ManyToMany` (связь многие ко многим)

Каждую из которых можно разделить ещё на два вида:

1. `Bidirectional` — ссылка на связь устанавливается у всех `Entity`, то есть в случае `OneToOne` `A-B` в `Entity A` есть ссылка на `Entity B`, в `Entity B` есть
ссылка на `Entity A`, `Entity A` считается владельцем этой связи (это важно для случаев каскадного удаления данных, тогда при удалении `A` также будет удалено `B`, 
но не наоборот).
2. `Unidirectional` - ссылка на связь устанавливается только с одной стороны, то есть в случае `OneToOne` `A-B` только у `Entity A` будет ссылка на `Entity B`, у
`Entity B` ссылки на `A` не будет. 

## Что такое Mapped Superclass? 

`Mapped Superclass` это класс от которого наследуются `Entity`, он может содержать анотации `JPA`, однако сам такой класс не является `Entity`, ему не обязательно 
выполнять все требования установленные для `Entity` (например, он может не содержать первичного ключа). Такой класс не может использоваться в операциях 
`EntityManager` или `Query`. Такой класс должен быть отмечен аннотацией `@MappedSuperclass` или соответственно описан в `XML` файле.

## Какие три типа стратегии наследования мапинга (Inheritance Mapping Strategies) описаны в JPA? 

В `JPA` описаны три стратегии наследования мапинга (`Inheritance Mapping Strategies`), то есть как `JPA` будет работать с классами-наследниками `Entity`: 

1. `одна таблица на всю иерархию наследования` (a single table per class hierarchy) — все `enity`, со всеми наследниками записываются в одну таблицу, для 
идентификации типа `entity` определяется специальная колонка “`discriminator column`”. Например, если есть `entity Animals` c классами-потомками `Cats` и `Dogs`,
при такой стратегии все `entity` записываются в таблицу `Animals`, но при это имеют дополнительную колонку `animalType` в которую соответственно пишется значение 
`cat` или `dog`. Минусом является то что в общей таблице, будут созданы все поля уникальные для каждого из классов-потомков, которые будет пусты для всех других 
классов-потомков. Например, в таблице `animals` окажется и скорость лазанья по дереву от `cats` и может ли пес приносить тапки от `dogs`, которые будут всегда 
иметь `null` для `dog` и `cat` соотвественно.

2. `объединяющая стратегия` (joined subclass strategy) — в этой стратегии каждый класс `enity` сохраняет данные в свою таблицу, но только уникальные колонки (не
унаследованные от классов-предков) и первичный ключ, а все унаследованные колонки записываются в таблицы класса-предка, дополнительно устанавливается связь 
(relationships) между этими таблицами, например в случае классов `Animals` (см.выше), будут три таблицы `animals`, `cats`, `dogs`, причем в `cats` будет записана 
только ключ и скорость лазанья, в `dogs` — ключ и умеет ли пес приносить палку, а в `animals` все остальные данные `cats` и `dogs` c ссылкой на соответствующие 
таблицы. Минусом тут являются потери производительности от объединения таблиц (`join`) для любых операций. 

3. `одна таблица для каждого класса` (table per concrete class strategy) — тут все просто каждый отдельный класс-наследник имеет свою таблицу, т.е. для `cats` и 
`dogs` (см.выше) все данные будут записываться просто в таблицы `cats` и dogs как если бы они вообще не имели общего суперкласса. Минусом является плохая поддержка
полиморфизма (polymorphic relationships) и то что для выборки всех классов иерархии потребуются большое количество отдельных `sql` запросов или использование 
`UNION` запроса.

## Какие шесть видов блокировок (lock) описаны в спецификации JPA (или какие есть значения у enum LockModeType в JPA)? 

У `JPA` есть шесть видов блокировок, перечислим их в порядке увеличения надежности (от самого ненадежного и быстрого, до самого надежного и медленного):

- `NONE` — без блокировки
- `OPTIMISTIC` (или синоним `READ`, оставшийся от `JPA 1`) — оптимистическая блокировка
- `OPTIMISTIC_FORCE_INCREMENT` (или синоним `WRITE`, оставшийся от `JPA 1`) — оптимистическая блокировка с принудительным увеличением поля версионности
- `PESSIMISTIC_READ` — пессимистичная блокировка на чтение
- `PESSIMISTIC_WRITE` — пессимистичная блокировка на запись (и чтение)
- `PESSIMISTIC_FORCE_INCREMENT` — пессимистичная блокировка на запись (и чтение) с принудительным увеличением поля версионности

## Двухфазный коммит

Протокол двухфазного принятия обеспечивает механизм автоматического восстановления на случай, если во время выполнения транзакции произойдет системный сбой или 
ошибка носителя. Протокол двухфазного принятия гарантирует, что все участвующие в транзакции серверы баз данных получат и реализуют одно и то же действие (принятие 
или откат транзакции), невзирая на на какие локальные или сетевые сбои.

Если какой-либо сервер баз данных не сможет принять свою часть транзакции, всем серверам баз данных, участвующим в транзакции, будет запрещено принятие их работы.

## Когда используется протокол двухфазного коммита

Сервер баз данных автоматически использует протокол двухфазного принятия для любой транзакции, которая изменяет данные на нескольких серверах баз данных.
Допустим, у вас соединены друг с другом три сервера баз данных: `australia`, `italy` и `france`, как показано на следующем рисунке:

![Screenshot](../../resources/2PC_1.gif)

Если вы введете команды, показанные в этом примере, будет произведена одна операция обновления и две операции вставки на трех разных серверах баз данных.

```sql
CONNECT TO stores_demo@italy
BEGIN WORK
   UPDATE stores_demo:manufact SET manu_code = 'SHM' WHERE manu_name = 'Shimara'
   INSERT INTO stores_demo@france:manufact VALUES ('SHM', 'Shimara', '30')
   INSERT INTO stores_demo@australia:manufact VALUES ('SHM', 'Shimara', '30')
COMMIT WORK
```

## Понятия двухфазного коммита

Для каждой глобальной транзакции задан координатор и один или несколько участников, как указано ниже:

- Координатор руководит разрешением глобальной транзакции. Он решает, следует ли принять или остановить глобальную транзакцию.

Протокол двухфазного принятия всегда назначает роль координатора текущему серверу баз данных. Роль координатора нельзя изменить в ходе выполнения одной транзакции. 
В примере транзакции выше координатором является сервер `italy`. если вы замените первую строку в этом примере на приведенный ниже оператор, протокол двухфазного 
принятия назначит роль координатора серверу `france`:

```sql
CONNECT TO stores_demo@franceСкопировать код
```

Чтобы определить сервер-координатор для распределенной транзакции, введите команду `onstat -x`.

- Каждый участник руководит выполнением одной ветви транзакции, которая является частью глобальной транзакции с использованием одной локальной базы данных. 
Глобальная транзакция содержит несколько ветвей транзакции, когда:

1. Программа использует несколько процессов для выполнения работы для глобальной транзакции.
2. Работу для одной и той же глобальной транзакции выполняют несколько удаленных программ.

В транзакции выше участниками являются серверы `france` и `australia`. Сервер баз данных, являющийся координатором (`italy`) также функционирует как участник, 
поскольку он выполняет обновление.

Протокол двухфазного принятия использует два типа связи: сообщения и записи логического журнала:

- Сообщения передаются между координатором и каждым из участников. Сообщения от координатора включают в себя идентификационный номер транзакции и инструкции 
(например, `prepare to commit`, `commit` или `roll back`). Сообщения от каждого из участников содержат состояние транзакции и отчеты о выполненных действиях 
(например, `can commit` или `cannot commit`, `committed` или `rolled back`).
- Записи логического журнала для транзакции хранятся на диске, чтобы обеспечить целостность и непротиворечивость данных, даже если на участвующем в транзакции 
сервере баз данных (участнике или координаторе) произойдет сбой.

## Фазы протокола двухфазного коммита

В транзакции с использованием двухфазного принятия координатор посылает все инструкции по изменению данных (например, по выполнению вставки) всем участникам. Затем 
координатор запустит протокол двухфазного принятия. Протокол двухфазного принятия состоит из двух частей, фазы подготовки к принятию и фазы после решения.

#### Фаза подготовки к принятию 

В ходе фазы подготовки к принятию координатор и участники ведут следующий диалог:

- `Координатор`: Координатор указывает каждому серверу баз данных-участнику, что тот должен подготовиться к принятию транзакции.
- `Участники`: Каждый участник сообщает координатору, может ли он принять свою ветвь транзакции.
- `Координатор`: Координатор, в зависимости от ответа каждого из участников, решает, нужно ли произвести принятие или откат транзакции. Координатор решит, что 
нужно принять транзакцию, только если все участники укажут, что могут принять свои ветви транзакции. Если кто-либо из участников укажет, что он не готов принять 
свою ветвь транзакции (или если он не ответит), координатор решит завершить глобальную транзакцию.

#### Фаза после решения

В ходе фазы после решения координатор и участники ведут следующий диалог:

- `Координатор`: Координатор вносит запись о принятии или откате в логический журнал координатора, а затем указывает каждому серверу баз данных-участнику, чтобы 
тот произвел принятие или откат транзакции.
- `Участники`: Если координатор сгенерировал сообщение о принятии, все участник примут транзакцию, внеся запись о принятии в логический журнал и отправив затем 
координатору сообщение, подтверждающее, что транзакция принята. Если координатор сгенерировал сообщение об откате, участники произведут откат транзакции, но не 
отправят подтверждение координатору.
- `Координатор`:  Если координатор сгенерировал сообщение о принятии транзакции, то, прежде чем завершить глобальную транзакцию, он дождется получения 
подтверждения от каждого из участников. Если координатор сгенерировал сообщение об откате транзакции, он не будет ждать подтверждений от участников.

## Как протокол двухфазного коммита обрабатывает ошибки

Протокол двухфазного принятия обеспечивает обработку системных ошибок и ошибок носителей таким образом, чтобы сохранялась целостность данных на всех участвующих в 
транзакции серверах баз данных. Если произойдет ошибка, протокол двухфазного принятия произведет автоматическое восстановление.

#### Типы отказов, обрабатываемых при автоматическом восстановлении

Ниже перечислены события, которые могут вызвать остановку или зависание потока координатора или участника, в связи с чем потребуется автоматическое восстановление:
- Системная ошибка координатора
- Системная ошибка участника
- Ошибка в сети
- Остановка координирующего потока администратором
-Остановка потока участника администратором

#### Роль администратора в автоматическом восстановлении

Единственное, что должен сделать администратор при автоматическом восстановлении - это перевести координатора и/или участника обратно в подключенное состояние 
после системой или сетевой ошибки.

**Важное замечание**

Медленная работа сети может запустить автоматическое восстановление. Ни один из описанных здесь механизмов восстановления не будет задействован, если не произойдет 
ошибка координирующей системы или ошибка сети либо если администратор не прервет координирующий поток.

#### Механизмы автоматического восстановления в случае ошибки координатора

В случае сбоя координирующего потока каждый сервер баз данных, являющийся участником, должен решить, следует ли инициировать автоматическое восстановление до 
принятия или отката транзакции, или после отката транзакции. Эта задача является частью оптимизации предполагаемого завершения.

#### Механизм автоматического восстановления в случае ошибки участника

Восстановление участника происходит каждый раз, когда поток участника производит предварительное принятие элемента работы, прерванного до того, как протокол 
двухфазного принятия сможет завершить работу. Цель восстановления участника - завершить работу протокола двухфазного принятия в соответствии с решением, к которому 
пришел координатор.

Восстановление участника управляется либо координатором, либо участником, в зависимости от того, решил ли координатор произвести принятие или откат глобальной 
транзакции.

**Важное замечание**

Чтобы обеспечить поддержку автоматического восстановления после завершения работы или перезапуска подчиненного сервера в то время, когда открыта межсерверная 
транзакция, в файле `sqlhosts` должна быть запись для каждого сервера баз данных, с которого можно инициировать распределенные операции. Во время автоматического 
восстановления имя координатора будет восстановлено из логических журналов, и подчиненный сервер заново установит соединение с координатором, чтобы завершить 
транзакцию. Координатор всегда идентифицирует себя среди участников по имени, которое указано в параметре конфигурации `DBSERVERNAME` в его собственном файле 
`onconfig`. В этой связи имя координатора должно совпадать с именем `IP-соединения`, которое известно участникам. Однако можно также установить по меньшей мере 
одну настройку `DBSERVERALIASES` с правильным протоколом соединения для обеспечения связи между координатором и подчиненными серверами. Подчиненный сервер должен 
иметь возможность соединиться с координатором, используя заданное для координатора значение `DBSERVERNAME` или `DBSERVERALIASES`.

## Оптимизация предполагаемого завершения

`Оптимизация предполагаемого завершения` - это термин, описывающий, как протокол двухфазного принятия обрабатывает откат транзакции.

Откат обрабатывается следующим образом. Если координатор определит, что нужно произвести откат транзакции, он отправит всем участникам сообщение о том, что они 
должны произвести откат своей части работы. Координатор, не дожидаясь подтверждения получения этого сообщения, приступит к закрытию транзакции и ее удалению из 
совместной памяти. Если участник попытается определить состояние этой транзакции — то есть, определить, была ли транзакция принята или был произведен ее откат 
(например, во время восстановления участника) — он не найдет состояния этой транзакции в совместной памяти. Участник должен будет интерпретировать это как то, что 
был произведен откат транзакции.

## Полезные ссылки

[Шпаргалка Java программиста 1: JPA и Hibernate в вопросах и ответах - habr](https://habr.com/ru/post/265061/)

[Двухфазный коммит - ibm.com](https://www.ibm.com/support/knowledgecenter/ru/SSGU8G_12.1.0/com.ibm.admin.doc/ids_admin_1050.htm)
