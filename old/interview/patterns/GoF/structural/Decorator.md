## `Декоратор / Обёртка (Decorator / Wrapper)`

Декоратор — это структурный паттерн проектирования, который позволяет динамически добавлять объектам 
новую функциональность, оборачивая их в полезные «обёртки»

### `Проблема`

Основой библиотеки является класс `Notifier` с методом `send`, который принимает на вход строку-сообщение и 
высылает её всем администраторам по электронной почте.

В какой-то момент стало понятно, что одних email-оповещений пользователям мало. Некоторые из них хотели бы получать 
извещения о критических проблемах через `SMS`. Другие хотели бы получать их в виде сообщений `Facebook`. 
Корпоративные пользователи хотели бы видеть сообщения в `Slack`. Поэтому мы унаследовались от базового класса `Notifier`
и создали `FacebookNotifier`, `SmsNotifier` и `SlackNotifier`.

Но затем кто-то резонно спросил, почему нельзя выбрать несколько типов оповещений сразу?

Вы попытались реализовать все возможные комбинации подклассов оповещений. Но после того как вы добавили первый десяток 
классов, стало ясно, что такой подход невероятно раздувает код программы.

### `Решение`

Одним из способов обойти эти проблемы является замена наследования агрегацией либо композицией. 
Это когда один объект содержит ссылку на другой и делегирует ему работу, вместо того чтобы самому наследовать его поведение. 

Декоратор имеет альтернативное название — обёртка. Оно более точно описывает суть паттерна: 
вы помещаете целевой объект в другой объект-обёртку, который запускает базовое поведение объекта, 
а затем добавляет к результату что-то своё.

Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, 
с каким объектом работать — чистым или обёрнутым.

### `Структура`

Приложение оборачивает класс данных в шифрующую и сжимающую обёртки, которые при чтении выдают оригинальные данные, 
а при записи — зашифрованные и сжатые.

Декораторы, как и сам класс данных, имеют общий интерфейс. 
Поэтому клиентскому коду не важно, с чем работать — c «чистым» объектом данных или с «обёрнутым».

![Alt text](https://refactoring.guru/images/patterns/diagrams/decorator/example-2x.png)

### `Признаки`

Признаки применения паттерна: Декоратор можно распознать по создающим методам, 
которые принимают в параметрах объекты того же абстрактного типа или интерфейса, что и текущий класс.

### `Применимость`
 
- Когда вам нужно добавлять обязанности объектам на лету, незаметно для кода, который их использует.
- Когда нельзя расширить обязанности объекта с помощью наследования.

### `Источники`

- [Подробнее о паттерне на refactoring.guru](https://refactoring.guru/ru/design-patterns/decorator)

- [Реализация на Java](https://refactoring.guru/ru/design-patterns/decorator/java/example)